import type { Express, RequestHandler } from "express";
import { createServer, type Server } from "http";
import { createHash } from "crypto";
import { setupAuth, registerAuthRoutes, isAuthenticated } from "./replit_integrations/auth";
import { storage } from "./storage";
import { db } from "./db";
import { eq, and, count, sql, gte, lt, lte, isNotNull, inArray, desc, or } from "drizzle-orm";
import { insertDriverProfileSchema, insertTripSchema, updateDriverProfileSchema, insertIncentiveProgramSchema, insertCountrySchema, insertTaxRuleSchema, insertExchangeRateSchema, insertComplianceProfileSchema, trips, countryPricingRules, stateLaunchConfigs, killSwitchStates, userTrustProfiles, driverProfiles, walletTransactions, cashTripDisputes, riderProfiles, tripCoordinatorProfiles, rides, wallets, riderWallets, users, bankTransfers, riderInboxMessages, driverInboxMessages, insertRiderInboxMessageSchema, notificationPreferences, cancellationFeeConfig, marketingMessages, walletFundingTransactions, walletFundingSettings, driverWallets, directorFundingTransactions, directorFundingSettings, directorFundingAcceptance, directorFundingSuspensions, directorProfiles, directorDriverAssignments, directorActionLogs, driverCoachingLogs, directorCells, directorCommissionSettings, directorPayoutSummaries, referralCodes, directorFraudSignals, directorDisputes, directorDisputeMessages, directorWindDowns, welcomeAnalytics, directorPerformanceScores, directorPerformanceWeights, directorIncentives, directorRestrictions, directorPerformanceLogs, directorSuccessions, directorTerminationTimeline, directorStaff, riderTrustScores, riderTrustWeights, riderLoyaltyIncentives, riderTrustLogs, fundingRelationships, fundingAbuseFlags, thirdPartyFundingConfig, fundingAuditLogs, sponsoredBalances, directorCoachingLogs, directorTrainingModules, directorTermsAcceptance, directorTrustScores } from "@shared/schema";
import { evaluateDriverForIncentives, approveAndPayIncentive, revokeIncentive, evaluateAllDrivers, evaluateBehaviorAndWarnings, calculateDriverMatchingScore, getDriverIncentiveProgress, assignFirstRidePromo, assignReturnRiderPromo, applyPromoToTrip, voidPromosOnCancellation } from "./incentives";
import { notificationService } from "./notification-service";
import { getCurrencyFromCountry, getCountryConfig, FINANCIAL_ENGINE_LOCKED } from "@shared/currency";
import { getPayoutProviderForCountry, generatePayoutReference, validatePaystackWebhook, validateFlutterwaveWebhook, type TransferStatus } from "./payout-provider";
import { generateTaxPDF, generateTaxCSV, generateBulkTaxCSV, type TaxDocumentData, type CountryTaxRules } from "./tax-document-generator";
import { validateRideRequest, assertFinancialEngineLocked } from "./financial-guards";
import { getSimulationConfig, assertSimulationEnabled, logSimulationStatus, SimulationDisabledError } from "./simulation-config";
import { 
  IDENTITY_ENGINE_LOCKED, 
  assertIdentityEngineLocked,
  checkDriverCanGoOnline,
  checkDriverCanAcceptRide,
  adminApproveIdentity,
  adminRejectIdentity,
  adminVerifyDriverLicense,
  hashIdentityDocument,
  validateIdentitySubmission,
} from "./identity-guards";
import {
  NAVIGATION_ENGINE_LOCKED,
  assertNavigationEngineLocked,
  checkNavigationSetup,
  validateDriverGps,
  processGpsUpdate,
  triggerAutoOffline,
  launchNavigation,
  closeNavigation,
  reportAppState,
  checkStaleGpsHeartbeats,
  canDriverGoOnline as canDriverGoOnlineNavigation,
} from "./navigation-guards";
import { NAVIGATION_PROVIDERS } from "@shared/navigation-config";
import { insertUserIdentityProfileSchema } from "@shared/schema";
import { getIdentityConfig, isValidIdTypeForCountry } from "@shared/identity-config";
import { getTemplateResponse, matchTemplate, type ZibraRole } from "@shared/zibra-templates";
import { applyTone } from "@shared/zibra-tone";
import { scanForLegalRisks } from "@shared/zibra-legal-guard";
import type { ToneStyle } from "@shared/country-profiles";

function generateSupportResponse(input: string, role: string, _isPrivileged: boolean): string {
  const zibraRole: ZibraRole = (role === "admin" || role === "super_admin" || role === "rider" || role === "driver" || role === "director") ? role as ZibraRole : "general";
  return getTemplateResponse(input, zibraRole);
}

// Helper function to get user's currency based on their country
async function getUserCurrency(userId: string): Promise<string> {
  const userRole = await storage.getUserRole(userId);
  const countryCode = userRole?.countryCode || "NG";
  return getCurrencyFromCountry(countryCode);
}

const requireRole = (allowedRoles: string[]): RequestHandler => {
  return async (req: any, res, next) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        console.warn(`[SECURITY AUDIT] Unauthenticated access attempt to ${req.path}`);
        return res.status(401).json({ message: "Unauthorized" });
      }
      
      const { enabled: simEnabled } = getSimulationConfig();
      if (simEnabled) {
        const simSession = await storage.getActiveSimulationSession(userId);
        if (simSession && new Date(simSession.expiresAt) > new Date()) {
          const simRole = simSession.role;
          if (allowedRoles.includes(simRole)) {
            req.userRole = simRole;
            req.userRoleData = { role: simRole, userId, _simulation: true };
            return next();
          }
          return res.status(403).json({ message: "Access denied for simulated role" });
        }

        if (req.user?._isSimulated) {
          const sessionData = (req as any).session;
          const simRole = sessionData?.simulatedRole;
          if (simRole && allowedRoles.includes(simRole)) {
            req.userRole = simRole;
            req.userRoleData = { role: simRole, userId, _simulation: true };
            return next();
          }
          return res.status(403).json({ message: "Access denied for simulated role" });
        }
      }

      const allRoles = await storage.getAllUserRoles(userId);
      if (!allRoles || allRoles.length === 0) {
        console.warn(`[SECURITY AUDIT] User ${userId} has no role, denied access to ${req.path}`);
        return res.status(403).json({ message: "Access denied" });
      }
      
      const matchedRole = allRoles.find(r => r.role === "super_admin") || allRoles.find(r => allowedRoles.includes(r.role));
      if (!matchedRole) {
        console.warn(`[SECURITY AUDIT] Unauthorized access attempt: User ${userId} (roles: ${allRoles.map(r => r.role).join(", ")}) tried to access ${req.path} - Required roles: ${allowedRoles.join(", ")}`);
        return res.status(403).json({ message: "Access denied" });
      }
      
      if (matchedRole.role === "admin") {
        const { valid, reason } = await storage.isAdminValid(userId);
        if (!valid) {
          console.warn(`[SECURITY AUDIT] Admin ${userId} access expired: ${reason}`);
          return res.status(403).json({ message: reason || "Admin access expired" });
        }
      }
      
      req.userRole = matchedRole.role;
      req.userRoleData = matchedRole;
      next();
    } catch (error) {
      console.error("Error checking role:", error);
      return res.status(500).json({ message: "Failed to verify access" });
    }
  };
};

// SUPER_ADMIN only middleware - strictest access control
const requireSuperAdmin: RequestHandler = async (req: any, res, next) => {
  try {
    const userId = req.user?.claims?.sub;
    if (!userId) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    
    const userRole = await storage.getUserRole(userId);
    if (!userRole || userRole.role !== "super_admin") {
      return res.status(403).json({ message: "Super Admin access required" });
    }
    
    req.userRole = userRole.role;
    req.userRoleData = userRole;
    next();
  } catch (error) {
    console.error("Error checking super admin role:", error);
    return res.status(500).json({ message: "Failed to verify access" });
  }
};

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  await setupAuth(app);
  registerAuthRoutes(app);

  // SUPER_ADMIN email binding - both emails have super admin access
  const SUPER_ADMIN_EMAILS = [
    "mosesafonabi951@gmail.com",  // Primary super admin (public/incognito)
    "365ddevotional@gmail.com"    // Replit account owner (preview)
  ];
  
  // Helper to check if email is authorized as SUPER_ADMIN
  const isSuperAdminEmail = (email: string): boolean => {
    return SUPER_ADMIN_EMAILS.includes(email);
  };

  // MULTI-ROLE SYSTEM: Get all roles for the authenticated user
  app.get("/api/user/role", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userEmail = req.user.claims.email;

      const { enabled: simEnabled } = getSimulationConfig();
      if (simEnabled) {
        if (req.user?._isSimulated) {
          const sessionData = (req as any).session;
          const simRole = sessionData?.simulatedRole;
          if (simRole) {
            return res.json({
              role: simRole,
              roles: [simRole],
              roleCount: 1,
              simulating: true,
            });
          }
        }

        const simSession = await storage.getActiveSimulationSession(userId);
        if (simSession && new Date(simSession.expiresAt) > new Date()) {
          return res.json({
            role: simSession.role,
            roles: [simSession.role],
            roleCount: 1,
            simulating: true,
          });
        }
      }
      
      // SERVER-SIDE SUPER_ADMIN ENFORCEMENT: If email matches, ensure super_admin role
      if (isSuperAdminEmail(userEmail)) {
        const hasSuperAdmin = await storage.hasRole(userId, "super_admin");
        if (!hasSuperAdmin) {
          await storage.addRoleToUser(userId, "super_admin");
          console.log(`[SUPER_ADMIN ENFORCEMENT] Auto-assigned super_admin role to ${userEmail}`);
        }
      }
      
      // Get ALL roles for this user
      const allRoles = await storage.getAllUserRoles(userId);
      
      if (!allRoles || allRoles.length === 0) {
        return res.json(null);
      }
      
      // ENFORCE: Only the bound email can be super_admin - revoke from anyone else
      const hasSuperAdminRole = allRoles.some(r => r.role === "super_admin");
      if (hasSuperAdminRole && !isSuperAdminEmail(userEmail)) {
        console.log(`[SUPER_ADMIN ENFORCEMENT] Revoking super_admin from unauthorized email: ${userEmail}`);
        await storage.deleteSpecificRole(userId, "super_admin");
        const remainingRoles = await storage.getAllUserRoles(userId);
        if (remainingRoles.length === 0) {
          return res.json(null);
        }
        // Return remaining roles
        return res.json({ 
          role: remainingRoles[0].role,
          roles: remainingRoles.map(r => r.role),
          roleCount: remainingRoles.length
        });
      }
      
      // MULTI-ROLE RESPONSE: Return primary role + all roles + count
      // Primary role = first role or highest priority role
      const rolesPriority = ["super_admin", "admin", "finance_admin", "director", "trip_coordinator", "support_agent", "driver", "rider"];
      const sortedRoles = allRoles.sort((a, b) => {
        const aPriority = rolesPriority.indexOf(a.role);
        const bPriority = rolesPriority.indexOf(b.role);
        return aPriority - bPriority;
      });
      
      return res.json({ 
        role: sortedRoles[0].role,  // Primary role (for backward compatibility)
        roles: sortedRoles.map(r => r.role),  // All roles
        roleCount: sortedRoles.length  // Total role count
      });
    } catch (error) {
      console.error("Error getting user role:", error);
      return res.status(500).json({ message: "Failed to get user role" });
    }
  });

  // MULTI-ROLE SYSTEM: Add a role to user (prevents duplicates)
  app.post("/api/user/role", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { role, countryCode = "NG" } = req.body;

      // RIDER APP: Only allow rider role from this endpoint
      if (role !== "rider") {
        console.warn(`[RIDER APP SECURITY] Non-rider role selection blocked: userId=${userId}, attemptedRole=${role}, timestamp=${new Date().toISOString()}`);
        return res.status(403).json({ message: "This app is for Riders only" });
      }

      // MULTI-ROLE: Check if user already has rider role
      const hasRiderRole = await storage.hasRole(userId, "rider");
      if (hasRiderRole) {
        return res.status(400).json({ message: "You already have this account type." });
      }

      // Add rider role using multi-role system
      const result = await storage.addRoleToUser(userId, role, countryCode);
      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      // Create rider profile
      await storage.createRiderProfile({ userId });
      
      // DEFAULT RATING: Create trust profile with 5.0 stars on signup
      await storage.getOrCreateUserTrustProfile(userId);

      // WELCOME MESSAGE: Send inbox welcome message to new rider
      try {
        await storage.createRiderInboxMessage({
          userId,
          title: "Welcome to ZIBA",
          body: "Welcome to ZIBA! You can book rides, save your favorite places, and manage your wallet all from the Home tab. If you ever need help, visit the Help section or tap the support button.",
          type: "system_announcement",
        });
      } catch (e) {
        console.warn("[INBOX] Failed to send welcome message:", e);
      }

      // Return all roles for the user
      const allRoles = await storage.getAllUserRoles(userId);
      return res.json({ 
        role: result.role?.role,
        roles: allRoles.map(r => r.role),
        roleCount: allRoles.length
      });
    } catch (error) {
      console.error("Error setting user role:", error);
      return res.status(500).json({ message: "Failed to set user role" });
    }
  });

  // Account deletion endpoint (supports both paths)
  const handleAccountDelete = async (req: any, res: any) => {
    try {
      const userId = req.user.claims.sub;
      const userRole = await storage.getUserRole(userId);
      
      if (!userRole) {
        return res.status(404).json({ message: "Account not found" });
      }

      // Check for active trips
      const activeTrips = await storage.getActiveTripsByUser(userId);
      if (activeTrips.length > 0) {
        return res.status(400).json({ 
          message: "Cannot delete account with an active trip. Please complete or cancel your trip first." 
        });
      }
      
      // Check if driver is online
      if (userRole.role === "driver") {
        const driverProfile = await storage.getDriverProfile(userId);
        if (driverProfile?.isOnline) {
          return res.status(400).json({ 
            message: "Cannot delete account while online. Please go offline first." 
          });
        }
      }

      // Hard delete: remove user from all tables to allow email reuse
      await storage.deleteUserAccount(userId);
      
      console.log(`[ACCOUNT DELETION] User account deleted: userId=${userId}, role=${userRole.role}, timestamp=${new Date().toISOString()}`);
      
      // Destroy session completely and clear cookies
      req.logout(() => {
        req.session.destroy((err: any) => {
          if (err) {
            console.error("Session destroy error:", err);
          }
          res.clearCookie("connect.sid", { path: "/" });
          return res.json({ success: true, message: "Account deleted successfully" });
        });
      });
    } catch (error) {
      console.error("Error deleting account:", error);
      return res.status(500).json({ message: "Failed to delete account" });
    }
  };

  app.delete("/api/account", isAuthenticated, handleAccountDelete);
  app.delete("/api/user/account", isAuthenticated, handleAccountDelete);

  // Admin delete user endpoint
  app.delete("/api/admin/users/:userId", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      
      // Check if user has active trips
      const activeTrips = await storage.getActiveTripsByUser(userId);
      if (activeTrips.length > 0) {
        return res.status(400).json({ 
          message: "Cannot delete user with active trips. Complete or cancel trips first." 
        });
      }
      
      // Check if driver is online
      const driverProfile = await storage.getDriverProfile(userId);
      if (driverProfile?.isOnline) {
        return res.status(400).json({ 
          message: "Cannot delete driver while online. Driver must go offline first." 
        });
      }
      
      await storage.deleteUserAccount(userId);
      return res.json({ message: "User deleted successfully" });
    } catch (error) {
      console.error("Error deleting user:", error);
      return res.status(500).json({ message: "Failed to delete user" });
    }
  });

  // Theme preference routes
  app.get("/api/user/theme-preference", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const preference = await storage.getThemePreference(userId);
      return res.json({ themePreference: preference });
    } catch (error) {
      console.error("Error getting theme preference:", error);
      return res.status(500).json({ message: "Failed to get theme preference" });
    }
  });

  app.post("/api/user/theme-preference", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { themePreference } = req.body;

      if (!["light", "dark", "system"].includes(themePreference)) {
        return res.status(400).json({ message: "Invalid theme preference" });
      }

      await storage.updateThemePreference(userId, themePreference);
      return res.json({ themePreference });
    } catch (error) {
      console.error("Error updating theme preference:", error);
      return res.status(500).json({ message: "Failed to update theme preference" });
    }
  });

  app.get("/api/user/language", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const language = await storage.getLanguagePreference(userId);
      return res.json({ language });
    } catch (error) {
      console.error("Error getting language preference:", error);
      return res.status(500).json({ message: "Failed to get language preference" });
    }
  });

  app.post("/api/user/language", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { language } = req.body;
      const validLanguages = ["en", "fr", "ar", "ha", "ig", "yo", "sw", "zu", "xh", "af", "pt", "es"];
      if (!validLanguages.includes(language)) {
        return res.status(400).json({ message: "Invalid language" });
      }
      await storage.updateLanguagePreference(userId, language, "manual");
      return res.json({ language });
    } catch (error) {
      console.error("Error updating language preference:", error);
      return res.status(500).json({ message: "Failed to update language preference" });
    }
  });

  app.post("/api/user/language/detect", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const currentLang = await storage.getLanguagePreference(userId);
      
      const [userData] = await db.select({ languageSource: users.languageSource }).from(users).where(eq(users.id, userId));
      if (userData?.languageSource === "manual") {
        return res.json({ language: currentLang, source: "manual", changed: false });
      }
      
      const { country } = req.body;
      let detectedLang = "en";
      let source = "default";
      
      if (country) {
        source = "auto_country";
        const countryLower = (country || "").toLowerCase();
        const francophoneCountries = ["senegal", "cote d'ivoire", "ivory coast", "cameroon", "mali", "guinea", "burkina faso", "niger", "chad", "congo", "drc", "togo", "benin", "madagascar", "gabon"];
        const arabicCountries = ["egypt", "morocco", "algeria", "tunisia", "libya", "sudan", "iraq", "saudi arabia", "uae", "jordan", "lebanon", "qatar", "bahrain", "kuwait", "oman", "yemen"];
        
        if (francophoneCountries.some(c => countryLower.includes(c))) {
          detectedLang = "fr";
        } else if (arabicCountries.some(c => countryLower.includes(c))) {
          detectedLang = "ar";
        }
      }
      
      if (currentLang === "en" && (!userData?.languageSource || userData.languageSource === "default")) {
        await storage.updateLanguagePreference(userId, detectedLang, source);
        return res.json({ language: detectedLang, source, changed: true });
      }
      
      return res.json({ language: currentLang, source: userData?.languageSource || "default", changed: false });
    } catch (error) {
      console.error("Error detecting language:", error);
      return res.status(500).json({ message: "Failed to detect language" });
    }
  });

  app.get("/api/admin/exists", async (req: any, res) => {
    try {
      const existingAdmins = await storage.getAdminCount();
      return res.json({ exists: existingAdmins > 0 });
    } catch (error) {
      console.error("Error checking admin:", error);
      return res.status(500).json({ message: "Failed to check admin" });
    }
  });

  app.post("/api/admin/seed", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      const existingAdmins = await storage.getAdminCount();
      if (existingAdmins > 0) {
        return res.status(403).json({ message: "Admin already exists" });
      }

      const existingRole = await storage.getUserRole(userId);
      if (existingRole) {
        return res.status(400).json({ message: "You already have a role assigned" });
      }

      const userRole = await storage.createUserRole({ userId, role: "admin" });
      return res.json({ role: userRole.role, message: "You are now an admin" });
    } catch (error) {
      console.error("Error seeding admin:", error);
      return res.status(500).json({ message: "Failed to seed admin" });
    }
  });

  // Driver registration endpoint - creates driver role
  app.post("/api/driver/register", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;

      const existingRole = await storage.getUserRole(userId);
      if (existingRole) {
        if (existingRole.role === "driver") {
          return res.json({ role: existingRole.role, message: "Already registered as driver" });
        }
        return res.status(400).json({ message: `You already have a ${existingRole.role} account. Please use the appropriate ZIBA app.` });
      }

      const userRole = await storage.createUserRole({ userId, role: "driver" });
      
      // Create driver profile with minimal required fields
      await storage.createDriverProfile({ 
        userId,
        fullName: "",
        phone: "",
        vehicleMake: "",
        vehicleModel: "",
        licensePlate: "",
      });
      
      // DEFAULT RATING: Create trust profile with 5.0 stars on signup
      await storage.getOrCreateUserTrustProfile(userId);

      try {
        await storage.createDriverInboxMessage({
          userId,
          title: "Welcome to ZIBA",
          body: "Welcome to the ZIBA driver platform! Complete your profile setup, add your vehicle details, and wait for admin approval. Once approved, you can start accepting rides.",
          type: "system_announcement",
        });
      } catch (e) { console.warn("[INBOX] Failed to send driver welcome message:", e); }

      console.log(`[DRIVER REGISTRATION] New driver registered: userId=${userId}, timestamp=${new Date().toISOString()}`);
      return res.json({ role: userRole.role, message: "Successfully registered as driver" });
    } catch (error) {
      console.error("Error registering driver:", error);
      return res.status(500).json({ message: "Failed to register as driver" });
    }
  });

  app.get("/api/driver/settlement/summary", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const summary = await storage.getDriverSettlementSummary(userId);
      return res.json(summary);
    } catch (error) {
      console.error("Error getting settlement summary:", error);
      return res.status(500).json({ message: "Failed to get settlement summary" });
    }
  });

  app.get("/api/driver/settlement/pending", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const settlements = await storage.getPendingSettlements(userId);
      return res.json(settlements);
    } catch (error) {
      console.error("Error getting pending settlements:", error);
      return res.status(500).json({ message: "Failed to get pending settlements" });
    }
  });

  app.get("/api/driver/standing", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const standing = await storage.getDriverStanding(userId);
      if (!standing) {
        return res.json({ currentSharePercent: 70, totalTripsCompleted: 0, rating: "5.00", accountAgeDays: 0 });
      }
      return res.json(standing);
    } catch (error) {
      console.error("Error getting driver standing:", error);
      return res.status(500).json({ message: "Failed to get driver standing" });
    }
  });

  app.get("/api/admin/settlements/:driverId", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const { driverId } = req.params;
      const pending = await storage.getPendingSettlements(driverId);
      const summary = await storage.getDriverSettlementSummary(driverId);
      return res.json({ settlements: pending, summary });
    } catch (error) {
      console.error("Error getting driver settlements:", error);
      return res.status(500).json({ message: "Failed to get driver settlements" });
    }
  });

  // =============================================
  // CASH SETTLEMENT LEDGER - DRIVER ROUTES
  // =============================================

  app.get("/api/driver/settlement/ledger", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const entries = await storage.getDriverLedgerEntries(userId);
      const sanitized = entries.map(e => ({
        id: e.id,
        periodStart: e.periodStart,
        periodEnd: e.periodEnd,
        totalCashCollected: e.totalCashCollected,
        settlementStatus: e.settlementStatus,
        currencyCode: e.currencyCode,
      }));
      return res.json(sanitized);
    } catch (error) {
      console.error("Error getting driver ledger:", error);
      return res.status(500).json({ message: "Failed to get settlement ledger" });
    }
  });

  // =============================================
  // CASH SETTLEMENT LEDGER - ADMIN ROUTES
  // =============================================

  app.get("/api/admin/cash-settlements", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const pending = await storage.getAllPendingLedgers();
      return res.json(pending);
    } catch (error) {
      console.error("Error getting pending ledgers:", error);
      return res.status(500).json({ message: "Failed to get pending cash settlements" });
    }
  });

  app.get("/api/admin/cash-settlements/:driverId", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const { driverId } = req.params;
      const entries = await storage.getDriverLedgerEntries(driverId);
      return res.json(entries);
    } catch (error) {
      console.error("Error getting driver cash settlements:", error);
      return res.status(500).json({ message: "Failed to get driver cash settlements" });
    }
  });

  app.post("/api/admin/cash-settlements/:ledgerId/defer", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const { ledgerId } = req.params;
      const { adminNotes } = req.body || {};
      const result = await storage.deferLedgerEntry(ledgerId, adminNotes);
      if (!result) {
        return res.status(404).json({ message: "Ledger entry not found" });
      }
      return res.json(result);
    } catch (error) {
      console.error("Error deferring ledger entry:", error);
      return res.status(500).json({ message: "Failed to defer ledger entry" });
    }
  });

  app.post("/api/admin/cash-settlements/:ledgerId/waive", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const { ledgerId } = req.params;
      const { reason } = req.body;
      if (!reason) {
        return res.status(400).json({ message: "Reason is required for waiving a ledger entry" });
      }
      const adminUserId = req.user.claims.sub;
      const result = await storage.waiveLedgerEntry(ledgerId, adminUserId, reason);
      if (!result) {
        return res.status(404).json({ message: "Ledger entry not found" });
      }
      return res.json(result);
    } catch (error) {
      console.error("Error waiving ledger entry:", error);
      return res.status(500).json({ message: "Failed to waive ledger entry" });
    }
  });

  app.post("/api/admin/cash-settlements/:ledgerId/settle", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const { ledgerId } = req.params;
      const { method } = req.body || {};
      const result = await storage.executePeriodSettlement(ledgerId, method || "card_trip_offset");
      if (!result) {
        return res.status(404).json({ message: "Ledger entry not found" });
      }
      return res.json(result);
    } catch (error) {
      console.error("Error settling ledger entry:", error);
      return res.status(500).json({ message: "Failed to settle ledger entry" });
    }
  });

  app.get("/api/admin/inbox-messages", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { type, userId, limit: limitParam } = req.query;
      const messageLimit = Math.min(parseInt(limitParam as string) || 100, 500);

      let riderMessages: any[] = [];
      let driverMessages: any[] = [];

      if (!type || type === "rider" || type === "all") {
        if (userId) {
          riderMessages = await storage.getRiderInboxMessages(userId as string);
        } else {
          riderMessages = await storage.getAllRiderInboxMessages(messageLimit);
        }
      }

      if (!type || type === "driver" || type === "all") {
        if (userId) {
          driverMessages = await storage.getDriverInboxMessages(userId as string);
        } else {
          driverMessages = await storage.getAllDriverInboxMessages(messageLimit);
        }
      }

      return res.json({
        rider: riderMessages.map(m => ({ ...m, inboxType: "rider" })),
        driver: driverMessages.map(m => ({ ...m, inboxType: "driver" })),
      });
    } catch (error) {
      console.error("Error fetching admin inbox messages:", error);
      return res.status(500).json({ message: "Failed to fetch inbox messages" });
    }
  });

  app.get("/api/admin/cash-abuse-flags", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const pendingLedgers = await storage.getAllPendingLedgers();
      const driverIds = [...new Set(pendingLedgers.map(l => l.driverId))];
      const flags = await Promise.all(
        driverIds.map(async (driverId) => {
          const abuseFlags = await storage.getDriverCashAbuseFlags(driverId);
          return { driverId, ...abuseFlags };
        })
      );
      const flagged = flags.filter(f => f.flagged);
      return res.json(flagged);
    } catch (error) {
      console.error("Error getting cash abuse flags:", error);
      return res.status(500).json({ message: "Failed to get cash abuse flags" });
    }
  });

  app.get("/api/admin/cash-abuse-flags/:driverId", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const { driverId } = req.params;
      const flags = await storage.getDriverCashAbuseFlags(driverId);
      return res.json(flags);
    } catch (error) {
      console.error("Error getting driver abuse flags:", error);
      return res.status(500).json({ message: "Failed to get driver abuse flags" });
    }
  });

  app.get("/api/admin/country-cash-config", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const configs = await storage.getAllCountryCashConfigs();
      return res.json(configs);
    } catch (error) {
      console.error("Error getting country cash configs:", error);
      return res.status(500).json({ message: "Failed to get country cash configs" });
    }
  });

  app.put("/api/admin/country-cash-config/:countryCode", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const { countryCode } = req.params;
      const config = await storage.upsertCountryCashConfig({ ...req.body, countryCode });
      return res.json(config);
    } catch (error) {
      console.error("Error upserting country cash config:", error);
      return res.status(500).json({ message: "Failed to update country cash config" });
    }
  });

  app.post("/api/rider/trip/:tripId/confirm-cash", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { tripId } = req.params;
      const [trip] = await db.select().from(trips).where(eq(trips.id, tripId));
      if (!trip) {
        return res.status(404).json({ message: "Trip not found" });
      }
      if (trip.riderId !== userId) {
        return res.status(403).json({ message: "Access denied" });
      }
      if (trip.status !== "completed") {
        return res.status(400).json({ message: "Trip is not completed" });
      }
      if (trip.paymentSource !== "CASH") {
        return res.status(400).json({ message: "Trip is not a cash trip" });
      }
      const [updated] = await db.update(trips).set({
        riderConfirmedCash: true,
        riderConfirmedCashAt: new Date(),
      }).where(eq(trips.id, tripId)).returning();
      return res.json(updated);
    } catch (error) {
      console.error("Error confirming cash payment:", error);
      return res.status(500).json({ message: "Failed to confirm cash payment" });
    }
  });

  app.post("/api/driver/trip/:tripId/confirm-cash", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { tripId } = req.params;
      const [trip] = await db.select().from(trips).where(eq(trips.id, tripId));
      if (!trip) {
        return res.status(404).json({ message: "Trip not found" });
      }
      if (trip.driverId !== userId) {
        return res.status(403).json({ message: "Access denied" });
      }
      if (trip.status !== "completed") {
        return res.status(400).json({ message: "Trip is not completed" });
      }
      if (trip.paymentSource !== "CASH") {
        return res.status(400).json({ message: "Trip is not a cash trip" });
      }
      const [updated] = await db.update(trips).set({
        driverConfirmedCash: true,
        driverConfirmedCashAt: new Date(),
        driverCollected: true,
      }).where(eq(trips.id, tripId)).returning();
      return res.json(updated);
    } catch (error) {
      console.error("Error confirming cash received:", error);
      return res.status(500).json({ message: "Failed to confirm cash received" });
    }
  });

  app.post("/api/driver/trip/:tripId/dispute-cash", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { tripId } = req.params;
      const [trip] = await db.select().from(trips).where(eq(trips.id, tripId));
      if (!trip) {
        return res.status(404).json({ message: "Trip not found" });
      }
      if (trip.driverId !== userId) {
        return res.status(403).json({ message: "Access denied" });
      }
      if (trip.status !== "completed") {
        return res.status(400).json({ message: "Trip is not completed" });
      }
      if (trip.paymentSource !== "CASH") {
        return res.status(400).json({ message: "Trip is not a cash trip" });
      }
      if (!trip.riderConfirmedCash || trip.driverConfirmedCash) {
        return res.status(400).json({ message: "Invalid dispute conditions" });
      }
      await db.update(trips).set({
        cashDisputeFlag: true,
        cashDisputeReason: "driver_disputes_payment",
      }).where(eq(trips.id, tripId));
      const [dispute] = await db.insert(cashTripDisputes).values({
        tripId,
        riderId: trip.riderId,
        driverId: userId,
        disputeType: "rider_paid_driver_disputes",
        riderClaimed: true,
        driverClaimed: false,
        status: "open",
        temporaryCreditAmount: trip.fareAmount ? String(trip.fareAmount) : "0",
      }).returning();
      try {
        const driverWallet = await storage.getOrCreateWallet(userId, "driver");
        await storage.creditWallet(
          driverWallet.id,
          trip.fareAmount || 0,
          "adjustment",
          tripId,
          undefined,
          `Temporary credit for disputed cash trip`
        );
      } catch (walletError) {
        console.error("Error crediting driver wallet for dispute:", walletError);
      }
      await db.update(riderProfiles).set({
        cashAccessRestricted: true,
        cashAccessRestrictedAt: new Date(),
        cashAccessRestrictedReason: "Cash dispute filed by driver",
      }).where(eq(riderProfiles.userId, trip.riderId));
      await storage.createNotification({
        userId: "admin",
        role: "admin",
        title: "Cash Trip Dispute",
        message: `Driver disputes cash payment for trip ${tripId}. Rider claims paid, driver says not received.`,
        type: "warning",
      });
      return res.json(dispute);
    } catch (error) {
      console.error("Error disputing cash trip:", error);
      return res.status(500).json({ message: "Failed to dispute cash trip" });
    }
  });

  app.post("/api/rider/trip/:tripId/dispute-cash", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { tripId } = req.params;
      const [trip] = await db.select().from(trips).where(eq(trips.id, tripId));
      if (!trip) {
        return res.status(404).json({ message: "Trip not found" });
      }
      if (trip.riderId !== userId) {
        return res.status(403).json({ message: "Access denied" });
      }
      if (trip.status !== "completed") {
        return res.status(400).json({ message: "Trip is not completed" });
      }
      if (trip.paymentSource !== "CASH") {
        return res.status(400).json({ message: "Trip is not a cash trip" });
      }
      if (!trip.driverConfirmedCash || trip.riderConfirmedCash) {
        return res.status(400).json({ message: "Invalid dispute conditions" });
      }
      await db.update(trips).set({
        cashDisputeFlag: true,
        cashDisputeReason: "rider_disputes_confirmation",
      }).where(eq(trips.id, tripId));
      const [dispute] = await db.insert(cashTripDisputes).values({
        tripId,
        riderId: userId,
        driverId: trip.driverId!,
        disputeType: "driver_confirmed_rider_disputes",
        driverClaimed: true,
        riderClaimed: false,
        status: "open",
      }).returning();
      await storage.createNotification({
        userId: "admin",
        role: "admin",
        title: "Cash Trip Dispute",
        message: `Rider disputes driver's cash confirmation for trip ${tripId}. Driver flagged for admin review.`,
        type: "warning",
      });
      return res.json(dispute);
    } catch (error) {
      console.error("Error disputing cash trip:", error);
      return res.status(500).json({ message: "Failed to dispute cash trip" });
    }
  });

  app.get("/api/rider/trip/:tripId/cash-status", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { tripId } = req.params;
      const [trip] = await db.select().from(trips).where(eq(trips.id, tripId));
      if (!trip || trip.riderId !== userId) {
        return res.status(404).json({ message: "Trip not found" });
      }
      const [profile] = await db.select().from(riderProfiles).where(eq(riderProfiles.userId, userId));
      return res.json({
        riderConfirmedCash: trip.riderConfirmedCash,
        driverConfirmedCash: trip.driverConfirmedCash,
        cashDisputeFlag: trip.cashDisputeFlag,
        cashAccessRestricted: profile?.cashAccessRestricted || false,
      });
    } catch (error) {
      console.error("Error getting cash status:", error);
      return res.status(500).json({ message: "Failed to get cash status" });
    }
  });

  app.get("/api/driver/trip/:tripId/cash-status", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { tripId } = req.params;
      const [trip] = await db.select().from(trips).where(eq(trips.id, tripId));
      if (!trip || trip.driverId !== userId) {
        return res.status(404).json({ message: "Trip not found" });
      }
      return res.json({
        riderConfirmedCash: trip.riderConfirmedCash,
        driverConfirmedCash: trip.driverConfirmedCash,
        cashDisputeFlag: trip.cashDisputeFlag,
      });
    } catch (error) {
      console.error("Error getting cash status:", error);
      return res.status(500).json({ message: "Failed to get cash status" });
    }
  });

  app.get("/api/rider/payment-onboarding", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const [profile] = await db.select().from(riderProfiles).where(eq(riderProfiles.userId, userId));
      return res.json({
        seen: profile?.paymentOnboardingSeen || false,
        cashAccessRestricted: profile?.cashAccessRestricted || false,
      });
    } catch (error) {
      console.error("Error getting payment onboarding status:", error);
      return res.status(500).json({ message: "Failed to get payment onboarding status" });
    }
  });

  app.post("/api/rider/payment-onboarding/seen", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      await db.update(riderProfiles).set({
        paymentOnboardingSeen: true,
      }).where(eq(riderProfiles.userId, userId));
      return res.json({ success: true });
    } catch (error) {
      console.error("Error marking onboarding as seen:", error);
      return res.status(500).json({ message: "Failed to mark onboarding as seen" });
    }
  });

  app.get("/api/rider/corporate-account", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      return res.json(null);
    } catch (error) {
      console.error("Error fetching corporate account:", error);
      return res.status(500).json({ message: "Failed to fetch corporate account" });
    }
  });

  app.post("/api/rider/corporate-request", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const { companyName } = req.body;
      const userId = req.user.claims.sub;
      console.log(`[CORPORATE] Access request from user ${userId} for company: ${companyName}`);
      return res.json({ success: true, message: "Corporate access request submitted" });
    } catch (error) {
      console.error("Error submitting corporate request:", error);
      return res.status(500).json({ message: "Failed to submit corporate request" });
    }
  });

  app.post("/api/rider/corporate-join", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const { companyCode } = req.body;
      const userId = req.user.claims.sub;
      console.log(`[CORPORATE] Join request from user ${userId} with code: ${companyCode}`);
      return res.json({ success: true, message: "Join request submitted for approval" });
    } catch (error) {
      console.error("Error submitting join request:", error);
      return res.status(500).json({ message: "Failed to submit join request" });
    }
  });

  // === SPECIAL RIDES ADMIN ENDPOINTS ===
  app.get("/api/admin/special-rides/config", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      return res.json([
        { id: "1", rideType: "group", enabled: true, minDriverTrustScore: 70, vehicleRequirements: "Sedan, SUV", availableCountries: ["NG", "ZA"], availableCities: [], assignedDirectorIds: [], createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
        { id: "2", rideType: "event", enabled: true, minDriverTrustScore: 75, vehicleRequirements: "SUV, Van", availableCountries: ["NG"], availableCities: [], assignedDirectorIds: [], createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
        { id: "3", rideType: "premium", enabled: false, minDriverTrustScore: 85, vehicleRequirements: "Luxury", availableCountries: [], availableCities: [], assignedDirectorIds: [], createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
        { id: "4", rideType: "longdistance", enabled: false, minDriverTrustScore: 80, vehicleRequirements: "SUV, Sedan", availableCountries: [], availableCities: [], assignedDirectorIds: [], createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() },
      ]);
    } catch (error) {
      console.error("Error fetching special rides config:", error);
      return res.status(500).json({ message: "Failed to fetch config" });
    }
  });

  app.get("/api/admin/special-rides/eligible-drivers", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      return res.json([]);
    } catch (error) {
      return res.status(500).json({ message: "Failed to fetch eligible drivers" });
    }
  });

  app.post("/api/admin/special-rides/toggle", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { rideType, enabled } = req.body;
      console.log(`[SPECIAL RIDES] Toggle ${rideType} -> ${enabled}`);
      return res.json({ success: true });
    } catch (error) {
      return res.status(500).json({ message: "Failed to toggle ride type" });
    }
  });

  app.post("/api/admin/special-rides/update-config", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { rideType, minDriverTrustScore, vehicleRequirements } = req.body;
      console.log(`[SPECIAL RIDES] Config update for ${rideType}: trust=${minDriverTrustScore}, vehicle=${vehicleRequirements}`);
      return res.json({ success: true });
    } catch (error) {
      return res.status(500).json({ message: "Failed to update config" });
    }
  });

  // === DIRECTOR CORPORATE RIDES ENDPOINTS ===
  app.get("/api/director/corporate-rides/drivers", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      return res.json([]);
    } catch (error) {
      return res.status(500).json({ message: "Failed to fetch corporate drivers" });
    }
  });

  app.get("/api/director/corporate-rides/activity", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      return res.json({ totalDrivers: 0, activeDrivers: 0, totalRides: 0, monthlyRides: 0, flaggedDrivers: 0 });
    } catch (error) {
      return res.status(500).json({ message: "Failed to fetch activity" });
    }
  });

  app.post("/api/director/corporate-rides/flag-driver", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      console.log(`[DIRECTOR CORPORATE] Flag driver: ${req.body.driverId}`);
      return res.json({ success: true });
    } catch (error) {
      return res.status(500).json({ message: "Failed to flag driver" });
    }
  });

  app.post("/api/director/corporate-rides/recommend", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      console.log(`[DIRECTOR CORPORATE] Recommend driver: ${req.body.driverId}`);
      return res.json({ success: true });
    } catch (error) {
      return res.status(500).json({ message: "Failed to recommend driver" });
    }
  });

  // === DIRECTOR SPECIAL RIDES ENDPOINTS ===
  app.get("/api/director/special-rides/drivers", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      return res.json([]);
    } catch (error) {
      return res.status(500).json({ message: "Failed to fetch special ride drivers" });
    }
  });

  app.get("/api/director/special-rides/demand", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      return res.json([
        { rideType: "group", label: "Group Rides", demandLevel: "moderate", requestCount: 12 },
        { rideType: "event", label: "Event Transport", demandLevel: "low", requestCount: 3 },
        { rideType: "premium", label: "Premium", demandLevel: "high", requestCount: 28 },
        { rideType: "longdistance", label: "Long-Distance", demandLevel: "low", requestCount: 5 },
      ]);
    } catch (error) {
      return res.status(500).json({ message: "Failed to fetch demand" });
    }
  });

  app.post("/api/director/special-rides/recommend", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      console.log(`[DIRECTOR SPECIAL] Recommend driver: ${req.body.driverId}`);
      return res.json({ success: true });
    } catch (error) {
      return res.status(500).json({ message: "Failed to recommend driver" });
    }
  });

  app.post("/api/director/special-rides/suspend", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      console.log(`[DIRECTOR SPECIAL] Suspend driver from special rides: ${req.body.driverId}`);
      return res.json({ success: true });
    } catch (error) {
      return res.status(500).json({ message: "Failed to suspend driver" });
    }
  });

  // === RIDER FUND USER ENDPOINTS ===
  app.post("/api/rider/fund-user/lookup", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const { identifier } = req.body;
      console.log(`[FUND USER] Lookup: ${identifier}`);
      const masked = identifier.includes("@") 
        ? identifier.substring(0, 3) + "***@***" 
        : "***" + identifier.slice(-4);
      return res.json({ 
        found: true, 
        userId: "user_" + Date.now(),
        displayName: identifier.includes("@") ? identifier.split("@")[0] : "ZIBA User",
        maskedIdentifier: masked
      });
    } catch (error) {
      console.error("Error looking up user:", error);
      return res.status(500).json({ message: "Failed to look up user" });
    }
  });

  app.post("/api/rider/fund-user/transfer", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const { recipientId, amount } = req.body;
      const userId = req.user.claims.sub;
      console.log(`[FUND USER] Transfer ${amount} from ${userId} to ${recipientId}`);
      return res.json({ 
        success: true, 
        transactionId: "TXN-" + Date.now(),
        amount,
        recipientId
      });
    } catch (error) {
      console.error("Error transferring funds:", error);
      return res.status(500).json({ message: "Failed to transfer funds" });
    }
  });

  // === DIRECTOR FUND DRIVER ENDPOINTS ===
  app.get("/api/director/cell-drivers", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      return res.json([]);
    } catch (error) {
      return res.status(500).json({ message: "Failed to fetch cell drivers" });
    }
  });

  app.get("/api/director/funding-limits", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      return res.json({ dailyCap: 50000, remainingToday: 50000, currency: "NGN" });
    } catch (error) {
      return res.status(500).json({ message: "Failed to fetch funding limits" });
    }
  });

  app.post("/api/director/fund-driver", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const { driverId, amount, rideRestricted } = req.body;
      const directorId = req.user.claims.sub;
      console.log(`[DIRECTOR FUND] Director ${directorId} funding driver ${driverId}: ${amount} (rideRestricted: ${rideRestricted})`);
      return res.json({ 
        success: true, 
        transactionId: "DIR-TXN-" + Date.now(),
        amount,
        driverId
      });
    } catch (error) {
      console.error("Error funding driver:", error);
      return res.status(500).json({ message: "Failed to fund driver" });
    }
  });

  app.get("/api/admin/cash-disputes", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const { status } = req.query;
      let results;
      if (status) {
        results = await db.select().from(cashTripDisputes).where(eq(cashTripDisputes.status, status as string));
      } else {
        results = await db.select().from(cashTripDisputes);
      }
      return res.json(results);
    } catch (error) {
      console.error("Error getting cash disputes:", error);
      return res.status(500).json({ message: "Failed to get cash disputes" });
    }
  });

  app.post("/api/admin/cash-disputes/:disputeId/resolve", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { disputeId } = req.params;
      const { resolution, adminNotes } = req.body;
      if (!resolution || !["rider_at_fault", "driver_at_fault", "inconclusive"].includes(resolution)) {
        return res.status(400).json({ message: "Invalid resolution" });
      }
      const [dispute] = await db.update(cashTripDisputes).set({
        status: "resolved",
        resolution,
        adminNotes: adminNotes || null,
        resolvedAt: new Date(),
        adminReviewedBy: userId,
      }).where(eq(cashTripDisputes.id, disputeId)).returning();
      if (!dispute) {
        return res.status(404).json({ message: "Dispute not found" });
      }
      if (resolution === "driver_at_fault" || resolution === "inconclusive") {
        await db.update(riderProfiles).set({
          cashAccessRestricted: false,
          cashAccessRestrictedReason: null,
        }).where(eq(riderProfiles.userId, dispute.riderId));
      }
      return res.json(dispute);
    } catch (error) {
      console.error("Error resolving cash dispute:", error);
      return res.status(500).json({ message: "Failed to resolve cash dispute" });
    }
  });

  app.post("/api/admin/riders/:riderId/reinstate-cash", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { riderId } = req.params;
      await db.update(riderProfiles).set({
        cashAccessRestricted: false,
        cashAccessRestrictedReason: null,
      }).where(eq(riderProfiles.userId, riderId));
      console.log(`[ADMIN ACTION] User ${userId} reinstated cash access for rider ${riderId}`);
      return res.json({ success: true });
    } catch (error) {
      console.error("Error reinstating cash access:", error);
      return res.status(500).json({ message: "Failed to reinstate cash access" });
    }
  });

  app.post("/api/admin/riders/:riderId/restrict-cash", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { riderId } = req.params;
      const { reason } = req.body;
      if (!reason) {
        return res.status(400).json({ message: "Reason is required" });
      }
      await db.update(riderProfiles).set({
        cashAccessRestricted: true,
        cashAccessRestrictedAt: new Date(),
        cashAccessRestrictedReason: reason,
      }).where(eq(riderProfiles.userId, riderId));
      return res.json({ success: true });
    } catch (error) {
      console.error("Error restricting cash access:", error);
      return res.status(500).json({ message: "Failed to restrict cash access" });
    }
  });

  app.get("/api/driver/profile", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;

      // SIMULATION MODE: Return a virtual driver profile if simulating as driver
      const { enabled: simEnabled } = getSimulationConfig();
      if (simEnabled) {
        const simSession = await storage.getActiveSimulationSession(userId);
        if (simSession && simSession.role === "driver" && new Date(simSession.expiresAt) > new Date()) {
          const config = JSON.parse(simSession.config || "{}");
          const userEmail = req.user.claims.email || "sim-driver@ziba.com";
          const firstName = req.user.claims.first_name || "Simulation";
          const lastName = req.user.claims.last_name || "Driver";
          return res.json({
            id: `sim-driver-${simSession.id}`,
            userId,
            fullName: `${firstName} ${lastName}`,
            phone: "+234 000 000 0000",
            vehicleMake: "Toyota",
            vehicleModel: "Camry",
            licensePlate: "SIM-0000",
            status: "approved",
            isOnline: true,
            walletBalance: config.walletBalance || "10000.00",
            averageRating: config.ratingState ? parseFloat(config.ratingState) : 4.5,
            totalRatings: 25,
            profilePhoto: null,
            verificationPhoto: null,
            verificationStatus: "verified",
            verificationTimestamp: new Date().toISOString(),
            verificationSessionId: null,
            navigationProvider: "google_maps",
            navigationVerified: true,
            locationPermissionStatus: "granted",
            lastGpsHeartbeat: new Date().toISOString(),
            withdrawalVerificationStatus: "verified",
            isNINVerified: true,
            isDriversLicenseVerified: true,
            isAddressVerified: true,
            isIdentityVerified: true,
            ninHash: null,
            driversLicenseHash: null,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            email: userEmail,
            _simulation: true,
          });
        }
      }

      const profile = await storage.getDriverProfile(userId);
      if (!profile) {
        return res.json(null);
      }
      return res.json(profile);
    } catch (error) {
      console.error("Error getting driver profile:", error);
      return res.status(500).json({ message: "Failed to get driver profile" });
    }
  });

  app.post("/api/driver/profile", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const parsed = insertDriverProfileSchema.safeParse({ ...req.body, userId });
      
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid profile data", errors: parsed.error.flatten() });
      }

      const existingProfile = await storage.getDriverProfile(userId);
      if (existingProfile) {
        return res.status(400).json({ message: "Profile already exists" });
      }

      const profile = await storage.createDriverProfile(parsed.data);
      return res.json(profile);
    } catch (error) {
      console.error("Error creating driver profile:", error);
      return res.status(500).json({ message: "Failed to create driver profile" });
    }
  });

  app.patch("/api/driver/profile", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const parsed = updateDriverProfileSchema.safeParse(req.body);
      
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid profile data", errors: parsed.error.flatten() });
      }

      const profile = await storage.updateDriverProfile(userId, parsed.data);
      if (!profile) {
        return res.status(404).json({ message: "Profile not found" });
      }
      return res.json(profile);
    } catch (error) {
      console.error("Error updating driver profile:", error);
      return res.status(500).json({ message: "Failed to update driver profile" });
    }
  });

  app.get("/api/driver/ride-class-preferences", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getDriverProfile(userId);
      if (!profile) {
        return res.status(404).json({ message: "Driver profile not found" });
      }

      const { getDriverEligibleClasses } = await import("@shared/ride-classes");
      const driverRating = profile.averageRating ? parseFloat(String(profile.averageRating)) : 0;
      const vehicleYear = (profile as any).vehicleYear ? parseInt(String((profile as any).vehicleYear)) : null;
      const eligibleClasses = getDriverEligibleClasses({
        driverRating,
        vehicleYear,
        hasPetApproval: !!(profile as any).petApproved,
        hasBackgroundCheck: !!(profile as any).backgroundCheckVerified,
        hasEliteApproval: !!(profile as any).eliteApproved,
      });

      const acceptedClasses = profile.acceptedRideClasses ?? eligibleClasses.map(ec => ec.id);

      return res.json({
        acceptedClasses,
        eligibleClasses,
      });
    } catch (error) {
      console.error("Error getting ride class preferences:", error);
      return res.status(500).json({ message: "Failed to get ride class preferences" });
    }
  });

  app.post("/api/driver/ride-class-preferences", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { acceptedClasses } = req.body;

      if (!Array.isArray(acceptedClasses)) {
        return res.status(400).json({ message: "acceptedClasses must be an array" });
      }

      const profile = await storage.getDriverProfile(userId);
      if (!profile) {
        return res.status(404).json({ message: "Driver profile not found" });
      }

      const { getDriverEligibleClasses } = await import("@shared/ride-classes");
      const driverRating = profile.averageRating ? parseFloat(String(profile.averageRating)) : 0;
      const vehicleYear = (profile as any).vehicleYear ? parseInt(String((profile as any).vehicleYear)) : null;
      const eligibleClasses = getDriverEligibleClasses({
        driverRating,
        vehicleYear,
        hasPetApproval: !!(profile as any).petApproved,
        hasBackgroundCheck: !!(profile as any).backgroundCheckVerified,
        hasEliteApproval: !!(profile as any).eliteApproved,
      });
      const eligibleIds = eligibleClasses.map(ec => ec.id);

      const invalidClasses = acceptedClasses.filter((c: string) => !eligibleIds.includes(c));
      if (invalidClasses.length > 0) {
        return res.status(400).json({
          message: `You are not eligible for these ride classes: ${invalidClasses.join(", ")}`,
          invalidClasses,
        });
      }

      await db.update(driverProfiles)
        .set({ acceptedRideClasses: acceptedClasses, updatedAt: new Date() })
        .where(eq(driverProfiles.userId, userId));

      return res.json({
        acceptedClasses,
        eligibleClasses,
      });
    } catch (error) {
      console.error("Error updating ride class preferences:", error);
      return res.status(500).json({ message: "Failed to update ride class preferences" });
    }
  });

  // =============================================
  // DRIVER PREFERENCES - FULL SYSTEM
  // =============================================

  // GET all driver preferences
  app.get("/api/driver/preferences", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getDriverProfile(userId);
      if (!profile) {
        return res.status(404).json({ message: "Driver profile not found" });
      }

      const p = profile as any;
      return res.json({
        tripDistancePreference: p.tripDistancePreference || ["short", "medium", "long"],
        cashAcceptance: p.cashAcceptance !== false,
        preferredAreas: p.preferredAreas || [],
        acceptedRideClasses: p.acceptedRideClasses || ["go"],
        preferencesLocked: !!p.preferencesLockedBy,
        preferencesLockedBy: p.preferencesLockedBy || null,
        declineCount: p.declineCount || 0,
        preferenceWarnings: p.preferenceWarnings || 0,
        preferenceRestricted: p.preferenceRestricted || false,
        preferenceRestrictedUntil: p.preferenceRestrictedUntil || null,
      });
    } catch (error) {
      console.error("Error getting driver preferences:", error);
      return res.status(500).json({ message: "Failed to get preferences" });
    }
  });

  // UPDATE driver preferences (with server-side enforcement)
  app.put("/api/driver/preferences", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getDriverProfile(userId);
      if (!profile) {
        return res.status(404).json({ message: "Driver profile not found" });
      }

      const p = profile as any;

      // Check if preferences are locked by admin/director
      if (p.preferencesLockedBy) {
        return res.status(403).json({
          message: "Your preferences have been locked by an administrator. Contact support for assistance.",
          code: "PREFERENCES_LOCKED",
          lockedBy: p.preferencesLockedBy,
        });
      }

      // Check if driver is restricted
      if (p.preferenceRestricted && p.preferenceRestrictedUntil && new Date(p.preferenceRestrictedUntil) > new Date()) {
        return res.status(403).json({
          message: "Your preference changes are temporarily restricted due to excessive ride declines.",
          code: "PREFERENCES_RESTRICTED",
          restrictedUntil: p.preferenceRestrictedUntil,
        });
      }

      const { tripDistancePreference, cashAcceptance, preferredAreas } = req.body;

      // Validate trip distance preferences
      const validDistances = ["short", "medium", "long"];
      const distPrefs = Array.isArray(tripDistancePreference)
        ? tripDistancePreference.filter((d: string) => validDistances.includes(d))
        : ["short", "medium", "long"];

      // Must select at least one distance preference
      if (distPrefs.length === 0) {
        return res.status(400).json({ message: "You must accept at least one trip distance category." });
      }

      // Validate preferred areas (max 5)
      const areas = Array.isArray(preferredAreas) ? preferredAreas.slice(0, 5) : [];

      // Validate cash acceptance (boolean)
      const cash = typeof cashAcceptance === "boolean" ? cashAcceptance : true;

      // Update using raw SQL since these are new columns
      const { db } = await import("./db");
      const { driverProfiles } = await import("@shared/schema");
      const { eq } = await import("drizzle-orm");
      await db.update(driverProfiles).set({
        tripDistancePreference: distPrefs,
        cashAcceptance: cash,
        preferredAreas: areas,
      } as any).where(eq(driverProfiles.userId, userId));

      return res.json({
        message: "Preferences updated successfully",
        tripDistancePreference: distPrefs,
        cashAcceptance: cash,
        preferredAreas: areas,
      });
    } catch (error) {
      console.error("Error updating driver preferences:", error);
      return res.status(500).json({ message: "Failed to update preferences" });
    }
  });

  // RECORD a ride decline (for abuse tracking)
  app.post("/api/driver/record-decline", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getDriverProfile(userId);
      if (!profile) {
        return res.status(404).json({ message: "Driver profile not found" });
      }

      const p = profile as any;
      const currentDeclines = (p.declineCount || 0) + 1;
      const currentWarnings = p.preferenceWarnings || 0;

      const { db } = await import("./db");
      const { driverProfiles } = await import("@shared/schema");
      const { eq } = await import("drizzle-orm");

      // Thresholds for abuse prevention
      const WARNING_THRESHOLD = 5;
      const RESTRICTION_THRESHOLD = 10;
      const RESTRICTION_HOURS = 2;

      let warning = null;
      let restricted = false;

      if (currentDeclines >= RESTRICTION_THRESHOLD) {
        // Apply temporary restriction
        const restrictedUntil = new Date();
        restrictedUntil.setHours(restrictedUntil.getHours() + RESTRICTION_HOURS);
        
        await db.update(driverProfiles).set({
          declineCount: currentDeclines,
          preferenceWarnings: currentWarnings + 1,
          preferenceRestricted: true,
          preferenceRestrictedUntil: restrictedUntil,
        } as any).where(eq(driverProfiles.userId, userId));

        restricted = true;
        console.log(`[ZIBRA OVERSIGHT] Driver ${userId} hit decline restriction threshold (${currentDeclines} declines). Temporary restriction applied until ${restrictedUntil.toISOString()}`);
        warning = `You have been temporarily restricted from changing preferences for ${RESTRICTION_HOURS} hours due to excessive ride declines.`;
      } else if (currentDeclines >= WARNING_THRESHOLD) {
        await db.update(driverProfiles).set({
          declineCount: currentDeclines,
          preferenceWarnings: currentWarnings + 1,
        } as any).where(eq(driverProfiles.userId, userId));

        warning = `You have declined ${currentDeclines} rides. Continued excessive declines may result in temporary restrictions.`;
        console.log(`[ZIBRA OVERSIGHT] Driver ${userId} approaching decline limit (${currentDeclines}/${RESTRICTION_THRESHOLD} declines). Warning #${currentWarnings + 1} issued.`);
      } else {
        await db.update(driverProfiles).set({
          declineCount: currentDeclines,
        } as any).where(eq(driverProfiles.userId, userId));
      }

      return res.json({
        declineCount: currentDeclines,
        warning,
        restricted,
      });
    } catch (error) {
      console.error("Error recording decline:", error);
      return res.status(500).json({ message: "Failed to record decline" });
    }
  });

  // ADMIN: Get all driver preference summaries
  app.get("/api/admin/driver-preferences", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { db } = await import("./db");
      const { driverProfiles, users } = await import("@shared/schema");
      const { eq } = await import("drizzle-orm");

      const drivers = await db.select({
        userId: driverProfiles.userId,
        fullName: driverProfiles.fullName,
        acceptedRideClasses: driverProfiles.acceptedRideClasses,
        tripDistancePreference: (driverProfiles as any).tripDistancePreference,
        cashAcceptance: (driverProfiles as any).cashAcceptance,
        preferredAreas: (driverProfiles as any).preferredAreas,
        preferencesLockedBy: (driverProfiles as any).preferencesLockedBy,
        declineCount: (driverProfiles as any).declineCount,
        preferenceWarnings: (driverProfiles as any).preferenceWarnings,
        preferenceRestricted: (driverProfiles as any).preferenceRestricted,
        status: driverProfiles.status,
        averageRating: driverProfiles.averageRating,
      }).from(driverProfiles);

      return res.json({ drivers });
    } catch (error) {
      console.error("Error getting driver preferences:", error);
      return res.status(500).json({ message: "Failed to get driver preferences" });
    }
  });

  // ADMIN: Lock/unlock driver preferences
  app.post("/api/admin/driver-preferences/:userId/lock", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const { lock } = req.body;
      const adminId = req.user.claims.sub;

      const { db } = await import("./db");
      const { driverProfiles } = await import("@shared/schema");
      const { eq } = await import("drizzle-orm");

      if (lock) {
        await db.update(driverProfiles).set({
          preferencesLockedBy: adminId,
          preferencesLockedAt: new Date(),
        } as any).where(eq(driverProfiles.userId, userId));
      } else {
        await db.update(driverProfiles).set({
          preferencesLockedBy: null,
          preferencesLockedAt: null,
        } as any).where(eq(driverProfiles.userId, userId));
      }

      return res.json({ message: lock ? "Preferences locked" : "Preferences unlocked" });
    } catch (error) {
      console.error("Error toggling preference lock:", error);
      return res.status(500).json({ message: "Failed to update preference lock" });
    }
  });

  // ADMIN: Reset driver preferences to defaults
  app.post("/api/admin/driver-preferences/:userId/reset", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;

      const { db } = await import("./db");
      const { driverProfiles } = await import("@shared/schema");
      const { eq } = await import("drizzle-orm");

      await db.update(driverProfiles).set({
        tripDistancePreference: ["short", "medium", "long"],
        cashAcceptance: true,
        preferredAreas: [],
        acceptedRideClasses: ["go"],
        preferencesLockedBy: null,
        preferencesLockedAt: null,
        declineCount: 0,
        preferenceWarnings: 0,
        preferenceRestricted: false,
        preferenceRestrictedUntil: null,
      } as any).where(eq(driverProfiles.userId, userId));

      return res.json({ message: "Driver preferences reset to defaults" });
    } catch (error) {
      console.error("Error resetting preferences:", error);
      return res.status(500).json({ message: "Failed to reset preferences" });
    }
  });

  // DIRECTOR: View driver preference summaries for their region
  app.get("/api/director/driver-preferences", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const { db } = await import("./db");
      const { driverProfiles } = await import("@shared/schema");

      const drivers = await db.select({
        userId: driverProfiles.userId,
        fullName: driverProfiles.fullName,
        acceptedRideClasses: driverProfiles.acceptedRideClasses,
        tripDistancePreference: (driverProfiles as any).tripDistancePreference,
        cashAcceptance: (driverProfiles as any).cashAcceptance,
        preferredAreas: (driverProfiles as any).preferredAreas,
        declineCount: (driverProfiles as any).declineCount,
        preferenceWarnings: (driverProfiles as any).preferenceWarnings,
        preferenceRestricted: (driverProfiles as any).preferenceRestricted,
        status: driverProfiles.status,
        averageRating: driverProfiles.averageRating,
      }).from(driverProfiles);

      // Identify over-restricting drivers (less than 2 distance preferences or less than 2 ride classes)
      const overRestricting = drivers.filter((d: any) => {
        const distPrefs = d.tripDistancePreference || ["short", "medium", "long"];
        const classPrefs = d.acceptedRideClasses || ["go"];
        return distPrefs.length < 2 || classPrefs.length < 2 || d.declineCount > 5;
      });

      return res.json({ drivers, overRestrictingCount: overRestricting.length, overRestricting });
    } catch (error) {
      console.error("Error getting director driver preferences:", error);
      return res.status(500).json({ message: "Failed to get driver preferences" });
    }
  });

  app.get("/api/driver/cancellation-metrics", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getDriverProfile(userId);
      if (!profile) {
        return res.status(404).json({ message: "Driver profile not found" });
      }
      const allTrips = await storage.getDriverTripHistory(profile.id);
      const totalTrips = allTrips.length;
      const cancelledTrips = allTrips.filter((t: any) => t.status === "cancelled" && t.cancelledBy === "driver").length;
      const cancellationRate = totalTrips > 0 ? (cancelledTrips / totalTrips) * 100 : 0;
      const warningThreshold = 12;
      return res.json({
        cancellationRate: Math.round(cancellationRate * 10) / 10,
        recentCancellations: cancelledTrips,
        totalTrips,
        warningThreshold,
        shouldWarn: totalTrips >= 5 && cancellationRate >= warningThreshold,
      });
    } catch (error) {
      console.error("Error getting driver cancellation metrics:", error);
      return res.status(500).json({ message: "Failed to get cancellation metrics" });
    }
  });

  app.post("/api/driver/toggle-online", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { isOnline } = req.body;

      const profile = await storage.getDriverProfile(userId);
      if (!profile) {
        return res.status(404).json({ message: "Profile not found" });
      }

      if (profile.status !== "approved" && !profile.isTraining) {
        return res.status(403).json({ message: "Driver must be approved to go online" });
      }

      if (profile.isTraining && isOnline === true) {
        console.log(`[TRAINING_MODE] Training driver going online: userId=${userId}, credits=${profile.trainingCredits}`);
      }

      // DRIVER VERIFICATION CHECK - Block going online if not verified for operations
      if (profile.withdrawalVerificationStatus === "suspended") {
        return res.status(403).json({ 
          message: "Your account is suspended. Contact support for assistance.",
          code: "DRIVER_SUSPENDED"
        });
      }

      // MANDATORY SETUP CHECK - Block going online if setup incomplete
      if (isOnline === true) {
        const missingFields: string[] = [];
        
        // Check location permissions
        if (profile.locationPermissionStatus !== "granted") {
          missingFields.push("locationPermission");
        }
        
        // Check navigation provider selection
        if (!profile.navigationProvider) {
          missingFields.push("navigationProvider");
        }
        
        // Check navigation verification
        if (!profile.navigationVerified) {
          missingFields.push("navigationVerified");
        }
        
        if (missingFields.length > 0 && !profile.isTraining) {
          return res.status(403).json({ 
            message: "Driver setup incomplete",
            error: "DRIVER_SETUP_INCOMPLETE",
            missingFields,
            setupCompleted: false
          });
        }
        
        if (missingFields.length > 0 && profile.isTraining) {
          console.log(`[TRAINING_MODE] Bypassing setup check for training driver: userId=${userId}, missing=${missingFields.join(",")}`);
        }
      }

      const updated = await storage.updateDriverOnlineStatus(userId, isOnline);
      
      // Phase 4: Track driver going online for analytics
      if (isOnline) {
        try {
          await storage.recordDriverOnline(userId);
        } catch (analyticsError) {
          console.error("Error recording driver online analytics:", analyticsError);
        }
      }
      
      return res.json(updated);
    } catch (error) {
      console.error("Error toggling online status:", error);
      return res.status(500).json({ message: "Failed to toggle online status" });
    }
  });

  // Get driver setup status
  app.get("/api/driver/setup-status", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;

      // SIMULATION MODE: Return completed setup status
      const { enabled: simEnabled } = getSimulationConfig();
      if (simEnabled) {
        const simSession = await storage.getActiveSimulationSession(userId);
        if (simSession && simSession.role === "driver" && new Date(simSession.expiresAt) > new Date()) {
          return res.json({
            setupCompleted: true,
            locationPermissionStatus: "granted",
            navigationProvider: "google_maps",
            navigationVerified: true,
            lastGpsHeartbeat: new Date().toISOString(),
            missingFields: [],
          });
        }
      }

      const profile = await storage.getDriverProfile(userId);
      
      if (!profile) {
        return res.status(404).json({ message: "Profile not found" });
      }

      const setupCompleted = 
        profile.locationPermissionStatus === "granted" &&
        profile.navigationProvider !== null &&
        profile.navigationVerified === true;

      return res.json({
        setupCompleted,
        locationPermissionStatus: profile.locationPermissionStatus,
        navigationProvider: profile.navigationProvider,
        navigationVerified: profile.navigationVerified,
        lastGpsHeartbeat: profile.lastGpsHeartbeat,
        missingFields: [
          ...(profile.locationPermissionStatus !== "granted" ? ["locationPermission"] : []),
          ...(!profile.navigationProvider ? ["navigationProvider"] : []),
          ...(!profile.navigationVerified ? ["navigationVerified"] : []),
        ]
      });
    } catch (error) {
      console.error("Error getting setup status:", error);
      return res.status(500).json({ message: "Failed to get setup status" });
    }
  });

  // Update location permission status
  app.patch("/api/driver/setup/location-permission", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { status } = req.body;
      
      const validStatuses = ["not_requested", "denied", "foreground_only", "granted"];
      if (!validStatuses.includes(status)) {
        return res.status(400).json({ message: "Invalid permission status" });
      }

      const profile = await storage.updateDriverProfile(userId, { 
        locationPermissionStatus: status
      });
      
      if (!profile) {
        return res.status(404).json({ message: "Profile not found" });
      }
      
      return res.json({ success: true, locationPermissionStatus: status });
    } catch (error) {
      console.error("Error updating location permission:", error);
      return res.status(500).json({ message: "Failed to update location permission" });
    }
  });

  // Update navigation provider selection
  app.patch("/api/driver/setup/navigation-provider", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { provider } = req.body;
      
      const validProviders = ["google_maps", "apple_maps", "waze", "other"];
      if (!validProviders.includes(provider)) {
        return res.status(400).json({ message: "Invalid navigation provider" });
      }

      const profile = await storage.updateDriverProfile(userId, { 
        navigationProvider: provider,
        navigationVerified: false
      });
      
      if (!profile) {
        return res.status(404).json({ message: "Profile not found" });
      }
      
      return res.json({ 
        success: true, 
        navigationProvider: provider,
        navigationVerified: false
      });
    } catch (error) {
      console.error("Error updating navigation provider:", error);
      return res.status(500).json({ message: "Failed to update navigation provider" });
    }
  });

  // Verify navigation app works (after deep-link test)
  app.post("/api/driver/setup/verify-navigation", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      const currentProfile = await storage.getDriverProfile(userId);
      if (!currentProfile) {
        return res.status(404).json({ message: "Profile not found" });
      }
      
      if (!currentProfile.navigationProvider) {
        return res.status(400).json({ message: "Navigation provider must be selected first" });
      }

      const profile = await storage.updateDriverProfile(userId, { 
        navigationVerified: true
      });
      
      return res.json({ 
        success: true, 
        navigationVerified: true,
        setupCompleted: 
          currentProfile.locationPermissionStatus === "granted" &&
          currentProfile.navigationProvider !== null
      });
    } catch (error) {
      console.error("Error verifying navigation:", error);
      return res.status(500).json({ message: "Failed to verify navigation" });
    }
  });

  // GPS heartbeat endpoint
  app.post("/api/driver/gps-heartbeat", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { lat, lng } = req.body;
      
      const profile = await storage.updateDriverProfile(userId, { 
        lastGpsHeartbeat: new Date()
      });
      
      if (!profile) {
        return res.status(404).json({ message: "Profile not found" });
      }
      
      return res.json({ success: true, timestamp: new Date().toISOString() });
    } catch (error) {
      console.error("Error updating GPS heartbeat:", error);
      return res.status(500).json({ message: "Failed to update GPS heartbeat" });
    }
  });

  app.get("/api/driver/available-rides", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getDriverProfile(userId);
      
      if (!profile || profile.status !== "approved" || !profile.isOnline) {
        return res.json([]);
      }

      const rides = await storage.getAvailableTrips();
      return res.json(rides);
    } catch (error) {
      console.error("Error getting available rides:", error);
      return res.status(500).json({ message: "Failed to get available rides" });
    }
  });

  app.get("/api/driver/current-trip", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const trip = await storage.getDriverCurrentTrip(userId);
      return res.json(trip);
    } catch (error) {
      console.error("Error getting current trip:", error);
      return res.status(500).json({ message: "Failed to get current trip" });
    }
  });

  app.post("/api/driver/accept-ride/:tripId", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { tripId } = req.params;

      const profile = await storage.getDriverProfile(userId);
      if (!profile || profile.status !== "approved") {
        return res.status(403).json({ message: "Driver not approved" });
      }

      // Check if driver is suspended
      if (profile.withdrawalVerificationStatus === "suspended") {
        return res.status(403).json({ 
          message: "Your account is suspended. Contact support for assistance.",
          code: "DRIVER_SUSPENDED"
        });
      }

      // Phase 6: Kill-switch check for trip acceptance
      const { checkTripAcceptanceAllowed } = await import("./launch-control");
      const acceptanceCheck = await checkTripAcceptanceAllowed();
      if (!acceptanceCheck.allowed) {
        return res.status(403).json({ message: acceptanceCheck.reason, code: acceptanceCheck.code });
      }

      // MANDATORY SETUP CHECK - Block ride acceptance if setup incomplete
      const missingFields: string[] = [];
      if (profile.locationPermissionStatus !== "granted") missingFields.push("locationPermission");
      if (!profile.navigationProvider) missingFields.push("navigationProvider");
      if (!profile.navigationVerified) missingFields.push("navigationVerified");
      
      if (missingFields.length > 0) {
        return res.status(403).json({ 
          message: "Driver setup incomplete",
          error: "DRIVER_SETUP_INCOMPLETE",
          missingFields,
          setupCompleted: false
        });
      }

      const currentTrip = await storage.getDriverCurrentTrip(userId);
      if (currentTrip) {
        return res.status(400).json({ message: "Already have an active trip" });
      }

      // Get trip first to check pairing block
      const tripToCheck = await storage.getTrip(tripId);
      if (!tripToCheck) {
        return res.status(404).json({ message: "Trip not found" });
      }
      
      // PAIRING BLOCK ENFORCEMENT: Prevent driver from accepting if blocked by/with rider
      const isBlocked = await storage.isDriverBlockedForRider(tripToCheck.riderId, userId);
      if (isBlocked) {
        console.log(`[PAIRING BLOCK] Driver ${userId} attempted to accept ride from blocked rider ${tripToCheck.riderId}`);
        return res.status(403).json({ 
          message: "This ride is no longer available.",
          code: "PAIRING_BLOCKED"
        });
      }

      // DRIVER PREFERENCE MATCHING: Validate ride against driver preferences
      const driverProfile = profile as any;
      
      // Check ride class preference
      const tripRideClass = (tripToCheck as any).rideClass || "go";
      const acceptedClasses = driverProfile.acceptedRideClasses || ["go"];
      if (!acceptedClasses.includes(tripRideClass)) {
        return res.status(403).json({
          message: "This ride class is not in your accepted preferences.",
          code: "RIDE_CLASS_NOT_ACCEPTED",
        });
      }

      // Check cash acceptance preference
      const paymentMethod = (tripToCheck as any).paymentMethod || "WALLET";
      if (paymentMethod === "CASH" && driverProfile.cashAcceptance === false) {
        return res.status(403).json({
          message: "This is a cash ride and you have disabled cash acceptance.",
          code: "CASH_NOT_ACCEPTED",
        });
      }

      // Check distance preference (soft enforcement - log but don't block if admin overrides exist)
      const estimatedDistance = (tripToCheck as any).estimatedDistance || 0;
      const distPrefs = driverProfile.tripDistancePreference || ["short", "medium", "long"];
      let tripDistanceCategory = "medium";
      if (estimatedDistance > 0 && estimatedDistance < 5) tripDistanceCategory = "short";
      else if (estimatedDistance >= 15) tripDistanceCategory = "long";
      
      if (!distPrefs.includes(tripDistanceCategory) && distPrefs.length < 3) {
        // Distance is a soft preference - log for analytics but allow if no other drivers available
        console.log(`[DRIVER PREFS] Distance mismatch: driver ${userId} prefers [${distPrefs.join(",")}], trip is ${tripDistanceCategory} (${estimatedDistance}km)`);
      }

      // Preference restriction check - prevent restricted drivers from accepting selectively
      if (driverProfile.preferenceRestricted && driverProfile.preferenceRestrictedUntil) {
        const restrictedUntil = new Date(driverProfile.preferenceRestrictedUntil);
        if (restrictedUntil > new Date()) {
          // Driver is restricted - still allow acceptance but log
          console.log(`[DRIVER PREFS] Restricted driver ${userId} accepting ride - preference restrictions active until ${restrictedUntil.toISOString()}`);
        }
      }

      // Track decline count for preference abuse prevention
      // (Decline recording happens via separate endpoint POST /api/driver/record-decline)

      const trip = await storage.acceptTrip(tripId, userId);
      if (!trip) {
        return res.status(404).json({ message: "Trip not found or already accepted" });
      }

      await storage.createNotification({
        userId: trip.riderId,
        role: "rider",
        title: "Driver Accepted",
        message: `A driver has accepted your ride from ${trip.pickupLocation} to ${trip.dropoffLocation}`,
        type: "success",
      });

      try {
        await storage.createRiderInboxMessage({
          userId: trip.riderId,
          title: "Driver Assigned",
          body: `A driver has been assigned to your ride from ${trip.pickupLocation} to ${trip.dropoffLocation}. They are on their way!`,
          type: "trip_update",
        });
      } catch (e) { console.warn("[INBOX] Failed to send driver assigned message:", e); }

      return res.json(trip);
    } catch (error) {
      console.error("Error accepting ride:", error);
      return res.status(500).json({ message: "Failed to accept ride" });
    }
  });

  app.post("/api/driver/trip/:tripId/status", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { tripId } = req.params;
      const { status } = req.body;

      if (!["in_progress", "completed"].includes(status)) {
        return res.status(400).json({ message: "Invalid status" });
      }

      const trip = await storage.updateTripStatus(tripId, userId, status);
      if (!trip) {
        return res.status(404).json({ message: "Trip not found" });
      }

      if (status === "in_progress") {
        await storage.createNotification({
          userId: trip.riderId,
          role: "rider",
          title: "Trip Started",
          message: "Your trip is now in progress. Enjoy your ride!",
          type: "info",
        });
      } else if (status === "completed") {
        // Format fare in NGN
        const fareInNaira = (parseFloat(String(trip.fareAmount)) / 100).toFixed(2);
        const commissionInNaira = (parseFloat(String(trip.commissionAmount || 0)) / 100).toFixed(2);
        
        await storage.createNotification({
          userId: trip.riderId,
          role: "rider",
          title: "Trip Completed",
          message: `Your trip has been completed. Fare: ${fareInNaira}`,
          type: "success",
        });

        try {
          await storage.createRiderInboxMessage({
            userId: trip.riderId,
            title: "Trip Completed",
            body: `Your trip from ${trip.pickupLocation} to ${trip.dropoffLocation} has been completed. Fare: ${fareInNaira}. Thank you for riding with ZIBA!`,
            type: "trip_update",
          });
        } catch (e) {
          console.warn("[INBOX] Failed to send trip completion message:", e);
        }
        
        await storage.notifyAdminsAndDirectors(
          "Trip Completed",
          `Trip completed. Fare: ${fareInNaira}, Commission: ${commissionInNaira}`,
          "success"
        );

        // Phase 11: Credit driver and ZIBA wallets (skip for cash - handled in storage layer)
        const isCashTrip = trip.paymentSource === "CASH";
        if (trip.driverPayout && trip.commissionAmount && !isCashTrip) {
          try {
            const driverWallet = await storage.getOrCreateWallet(userId, "driver");
            
            await storage.creditWallet(
              driverWallet.id,
              trip.driverPayout,
              "trip",
              tripId,
              undefined,
              `Earnings from trip: ${trip.pickupLocation}  ${trip.dropoffLocation}`
            );

            const zibaWallet = await storage.getZibaWallet();
            await storage.creditWallet(
              zibaWallet.id,
              trip.commissionAmount,
              "trip",
              tripId,
              undefined,
              `Commission from trip: ${trip.pickupLocation}  ${trip.dropoffLocation}`
            );
          } catch (walletError) {
            console.error("Error crediting wallets:", walletError);
          }
        }

        // Phase 4: Track analytics for ride/trip completion
        try {
          await storage.recordRideCompletion(trip.riderId);
          if (trip.driverId) {
            await storage.recordTripCompletion(trip.driverId);
          }
        } catch (analyticsError) {
          console.error("Error recording analytics:", analyticsError);
        }

        // Phase 5: Update behavior stats on trip completion
        try {
          if (trip.driverId) {
            await evaluateBehaviorAndWarnings(trip.driverId, "driver");
          }
          await evaluateBehaviorAndWarnings(trip.riderId, "rider");
        } catch (behaviorError) {
          console.error("Error updating behavior stats:", behaviorError);
        }

        // Accumulate trip mileage for annual tax reporting
        try {
          if (trip.driverId) {
            const tripDistanceKm = parseFloat(trip.actualDistanceKm || trip.estimatedDistanceKm || "0");
            if (tripDistanceKm > 0) {
              const tripDistanceMiles = tripDistanceKm * 0.621371;
              const taxYear = new Date().getFullYear();
              await storage.addDriverMileage(trip.driverId, taxYear, tripDistanceMiles, "trip");
            }
          }
        } catch (mileageError) {
          console.error("Error accumulating driver mileage:", mileageError);
        }
      }

      return res.json(trip);
    } catch (error) {
      console.error("Error updating trip status:", error);
      return res.status(500).json({ message: "Failed to update trip status" });
    }
  });

  app.get("/api/driver/trip-history", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { status, startDate, endDate } = req.query;
      const filter: any = {};
      if (status) filter.status = status;
      if (startDate) filter.startDate = startDate;
      if (endDate) filter.endDate = endDate;
      
      const trips = await storage.getDriverTripHistory(userId, filter);
      return res.json(trips);
    } catch (error) {
      console.error("Error getting driver trip history:", error);
      return res.status(500).json({ message: "Failed to get trip history" });
    }
  });

  // Driver Payout Info Management
  app.get("/api/driver/payout-info", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const wallet = await storage.getDriverWallet(userId);
      if (!wallet) {
        return res.json({ 
          bankName: null, 
          accountNumber: null, 
          accountName: null, 
          mobileMoneyProvider: null, 
          mobileMoneyNumber: null,
          preferredPayoutMethod: null,
          withdrawableBalance: "0.00"
        });
      }
      return res.json({
        bankName: wallet.bankName,
        accountNumber: wallet.accountNumber,
        accountName: wallet.accountName,
        mobileMoneyProvider: wallet.mobileMoneyProvider,
        mobileMoneyNumber: wallet.mobileMoneyNumber,
        preferredPayoutMethod: wallet.preferredPayoutMethod,
        withdrawableBalance: wallet.withdrawableBalance,
      });
    } catch (error) {
      console.error("Error getting driver payout info:", error);
      return res.status(500).json({ message: "Failed to get payout info" });
    }
  });

  app.patch("/api/driver/payout-info", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { bankName, accountNumber, accountName, mobileMoneyProvider, mobileMoneyNumber, preferredPayoutMethod } = req.body;
      
      let wallet = await storage.getDriverWallet(userId);
      if (!wallet) {
        const currency = await getUserCurrency(userId);
        wallet = await storage.createDriverWallet({ userId, currency });
      }
      
      const updated = await storage.updateDriverPayoutInfo(userId, {
        bankName,
        accountNumber,
        accountName,
        mobileMoneyProvider,
        mobileMoneyNumber,
        preferredPayoutMethod,
      });
      
      if (!updated) {
        return res.status(404).json({ message: "Driver wallet not found" });
      }
      
      console.log(`[AUDIT] Driver payout info updated: userId=${userId}`);
      
      return res.json({ message: "Payout info updated", wallet: updated });
    } catch (error) {
      console.error("Error updating driver payout info:", error);
      return res.status(500).json({ message: "Failed to update payout info" });
    }
  });

  // Nigeria Bank Account Integration - Driver bank account CRUD
  app.get("/api/driver/bank-account", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const driverProfile = await storage.getDriverProfile(userId);
      if (!driverProfile) {
        return res.status(404).json({ message: "Driver profile not found" });
      }
      const bankAccount = await storage.getDriverBankAccount(driverProfile.id);
      
      // Also return verification status for UI
      const verificationStatus = {
        isNINVerified: driverProfile.isNINVerified,
        isDriversLicenseVerified: driverProfile.isDriversLicenseVerified,
        isAddressVerified: driverProfile.isAddressVerified,
        isIdentityVerified: driverProfile.isIdentityVerified,
        withdrawalVerificationStatus: driverProfile.withdrawalVerificationStatus,
        bankAccountVerified: bankAccount?.isVerified || false,
      };
      
      return res.json({ bankAccount, verificationStatus });
    } catch (error) {
      console.error("Error getting driver bank account:", error);
      return res.status(500).json({ message: "Failed to get bank account" });
    }
  });

  app.post("/api/driver/bank-account", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { bankName, bankCode, accountNumber, accountName } = req.body;
      
      // Validate required fields
      if (!bankName || !bankCode || !accountNumber || !accountName) {
        return res.status(400).json({ message: "All bank account fields are required" });
      }
      
      const driverProfile = await storage.getDriverProfile(userId);
      if (!driverProfile) {
        return res.status(404).json({ message: "Driver profile not found" });
      }
      
      // Check if driver already has a bank account
      const existing = await storage.getDriverBankAccount(driverProfile.id);
      if (existing) {
        return res.status(400).json({ message: "Bank account already exists. Use PATCH to update." });
      }
      
      // Hash account number for uniqueness check
      const crypto = await import("crypto");
      const accountNumberHash = crypto.createHash("sha256").update(accountNumber).digest("hex");
      
      // Check if this bank account is already linked to another driver
      const hashExists = await storage.checkBankAccountHashExists(accountNumberHash, driverProfile.id);
      if (hashExists) {
        console.log(`[FRAUD] Bank account reuse attempt: driverId=${driverProfile.id}, accountNumber=****${accountNumber.slice(-4)}`);
        return res.status(400).json({ message: "This bank account is already linked to another driver" });
      }
      
      const bankAccount = await storage.createDriverBankAccount({
        driverId: driverProfile.id,
        bankName,
        bankCode,
        accountNumber,
        accountNumberHash,
        accountName,
        countryCode: "NG", // Nigeria only
      });
      
      console.log(`[AUDIT] Driver bank account created: driverId=${driverProfile.id}, bankName=${bankName}`);
      return res.json(bankAccount);
    } catch (error) {
      console.error("Error creating driver bank account:", error);
      return res.status(500).json({ message: "Failed to create bank account" });
    }
  });

  app.patch("/api/driver/bank-account", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { bankName, bankCode, accountNumber, accountName } = req.body;
      
      const driverProfile = await storage.getDriverProfile(userId);
      if (!driverProfile) {
        return res.status(404).json({ message: "Driver profile not found" });
      }
      
      const existing = await storage.getDriverBankAccount(driverProfile.id);
      if (!existing) {
        return res.status(404).json({ message: "No bank account found. Create one first." });
      }
      
      // If account number is changing, check for reuse
      if (accountNumber && accountNumber !== existing.accountNumber) {
        const crypto = await import("crypto");
        const accountNumberHash = crypto.createHash("sha256").update(accountNumber).digest("hex");
        
        const hashExists = await storage.checkBankAccountHashExists(accountNumberHash, driverProfile.id);
        if (hashExists) {
          console.log(`[FRAUD] Bank account reuse attempt on update: driverId=${driverProfile.id}`);
          return res.status(400).json({ message: "This bank account is already linked to another driver" });
        }
      }
      
      // Updating bank account resets verification
      const updated = await storage.updateDriverBankAccount(driverProfile.id, {
        bankName: bankName || existing.bankName,
        bankCode: bankCode || existing.bankCode,
        accountNumber: accountNumber || existing.accountNumber,
        accountName: accountName || existing.accountName,
      });
      
      // Reset bank verification if account changed
      if (accountNumber && accountNumber !== existing.accountNumber) {
        await storage.verifyDriverBankAccount(driverProfile.id, false, "manual", "system");
        console.log(`[AUDIT] Bank account verification reset due to update: driverId=${driverProfile.id}`);
      }
      
      console.log(`[AUDIT] Driver bank account updated: driverId=${driverProfile.id}`);
      return res.json(updated);
    } catch (error) {
      console.error("Error updating driver bank account:", error);
      return res.status(500).json({ message: "Failed to update bank account" });
    }
  });

  // Driver verification status and eligibility check
  app.get("/api/driver/withdrawal-eligibility", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const driverProfile = await storage.getDriverProfile(userId);
      if (!driverProfile) {
        return res.status(404).json({ message: "Driver profile not found" });
      }
      
      const bankAccount = await storage.getDriverBankAccount(driverProfile.id);
      const driverWallet = await storage.getDriverWallet(userId);
      const isTester = await storage.isUserTester(userId);
      
      // Get identity documents for Nigeria-specific checks
      const identityDocs = await storage.getIdentityDocuments(userId);
      const hasNIN = identityDocs.some(d => d.documentType === "NIN" && d.verified);
      const hasDriversLicense = identityDocs.some(d => d.documentType === "DRIVER_LICENSE" && d.verified);
      
      const issues: string[] = [];
      
      // Check all requirements
      if (driverProfile.withdrawalVerificationStatus !== "verified") {
        issues.push("Driver verification status is not verified");
      }
      if (!driverProfile.isNINVerified && !hasNIN) {
        issues.push("NIN verification required");
      }
      if (!driverProfile.isDriversLicenseVerified && !hasDriversLicense) {
        issues.push("Driver's license verification required");
      }
      if (!driverProfile.isAddressVerified) {
        issues.push("Address verification required");
      }
      if (!driverProfile.isIdentityVerified) {
        issues.push("Identity verification required");
      }
      if (!bankAccount) {
        issues.push("Bank account not linked");
      } else if (!bankAccount.isVerified) {
        issues.push("Bank account not verified");
      }
      if (!driverWallet || parseFloat(driverWallet.withdrawableBalance || "0") < 1000) {
        issues.push("Minimum withdrawal amount is 1,000");
      }
      if (isTester) {
        issues.push("Test drivers cannot withdraw real funds");
      }
      
      const isEligible = issues.length === 0;
      
      return res.json({
        isEligible,
        issues,
        walletBalance: driverWallet?.withdrawableBalance || "0.00",
        currency: "NGN",
        minimumWithdrawal: 1000,
        bankAccount: bankAccount ? {
          bankName: bankAccount.bankName,
          accountNumber: `****${bankAccount.accountNumber.slice(-4)}`,
          accountName: bankAccount.accountName,
          isVerified: bankAccount.isVerified,
        } : null,
        verificationStatus: {
          isNINVerified: driverProfile.isNINVerified || hasNIN,
          isDriversLicenseVerified: driverProfile.isDriversLicenseVerified || hasDriversLicense,
          isAddressVerified: driverProfile.isAddressVerified,
          isIdentityVerified: driverProfile.isIdentityVerified,
          overallStatus: driverProfile.withdrawalVerificationStatus,
        },
      });
    } catch (error) {
      console.error("Error checking withdrawal eligibility:", error);
      return res.status(500).json({ message: "Failed to check eligibility" });
    }
  });

  // Driver withdrawal request (Nigeria NGN only)
  app.post("/api/driver/withdrawals", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { amount } = req.body;
      
      const driverProfile = await storage.getDriverProfile(userId);
      if (!driverProfile) {
        return res.status(404).json({ message: "Driver profile not found" });
      }
      
      // Validate amount
      const withdrawAmount = parseFloat(amount);
      if (isNaN(withdrawAmount) || withdrawAmount < 1000) {
        return res.status(400).json({ message: "Minimum withdrawal amount is 1,000" });
      }
      
      // Check if driver is a tester
      const isTester = await storage.isUserTester(userId);
      if (isTester) {
        return res.status(403).json({ message: "Test drivers cannot withdraw real funds" });
      }
      
      // Check verification status
      if (driverProfile.withdrawalVerificationStatus !== "verified") {
        return res.status(403).json({ message: "Complete identity verification to withdraw" });
      }
      
      // Check all verification flags
      if (!driverProfile.isNINVerified || !driverProfile.isDriversLicenseVerified || 
          !driverProfile.isAddressVerified || !driverProfile.isIdentityVerified) {
        // Fall back to checking identity documents
        const docs = await storage.getIdentityDocuments(userId);
        const hasVerifiedNIN = docs.some(d => d.documentType === "NIN" && d.verified);
        const hasVerifiedLicense = docs.some(d => d.documentType === "DRIVER_LICENSE" && d.verified);
        
        if (!hasVerifiedNIN) {
          return res.status(403).json({ message: "NIN verification required for withdrawals" });
        }
        if (!hasVerifiedLicense) {
          return res.status(403).json({ message: "Driver's license verification required for withdrawals" });
        }
      }
      
      // Check bank account
      const bankAccount = await storage.getDriverBankAccount(driverProfile.id);
      if (!bankAccount) {
        return res.status(400).json({ message: "Link a bank account before withdrawing" });
      }
      if (!bankAccount.isVerified) {
        return res.status(403).json({ message: "Bank account verification pending" });
      }
      
      // Check wallet balance
      const driverWallet = await storage.getDriverWallet(userId);
      if (!driverWallet) {
        return res.status(400).json({ message: "Driver wallet not found" });
      }
      
      const walletBalance = parseFloat(driverWallet.withdrawableBalance || "0");
      if (walletBalance < withdrawAmount) {
        return res.status(400).json({ message: `Insufficient balance. Available: ${walletBalance.toFixed(2)}` });
      }
      
      // Create withdrawal request
      const withdrawal = await storage.createDriverWithdrawal({
        driverId: driverProfile.id,
        amount: withdrawAmount.toFixed(2),
        currencyCode: "NGN",
        payoutMethod: "BANK",
        bankAccountId: bankAccount.id,
      });
      
      console.log(`[AUDIT] Withdrawal requested: driverId=${driverProfile.id}, amount=${withdrawAmount}, withdrawalId=${withdrawal.id}`);
      
      return res.json({
        message: "Withdrawal request submitted",
        withdrawal: {
          id: withdrawal.id,
          amount: withdrawal.amount,
          currency: "NGN",
          status: withdrawal.status,
          bankAccount: `${bankAccount.bankName} - ****${bankAccount.accountNumber.slice(-4)}`,
        },
      });
    } catch (error) {
      console.error("Error creating withdrawal request:", error);
      return res.status(500).json({ message: "Failed to create withdrawal request" });
    }
  });

  // Get driver's withdrawal history
  app.get("/api/driver/withdrawals", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const driverProfile = await storage.getDriverProfile(userId);
      if (!driverProfile) {
        return res.status(404).json({ message: "Driver profile not found" });
      }
      
      const withdrawals = await storage.getDriverWithdrawals(driverProfile.id);
      return res.json(withdrawals);
    } catch (error) {
      console.error("Error getting driver withdrawals:", error);
      return res.status(500).json({ message: "Failed to get withdrawals" });
    }
  });

  app.get("/api/rider/profile", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getRiderProfile(userId);
      return res.json(profile || null);
    } catch (error) {
      console.error("Error getting rider profile:", error);
      return res.status(500).json({ message: "Failed to get rider profile" });
    }
  });

  // Update rider profile (phone, etc.)
  app.put("/api/rider/profile", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { phone } = req.body;
      
      const profile = await storage.getRiderProfile(userId);
      if (!profile) {
        return res.status(404).json({ message: "Rider profile not found" });
      }

      const updates: Record<string, any> = {};
      if (phone !== undefined) {
        if (typeof phone === "string" && phone.length > 0 && phone.length < 7) {
          return res.status(400).json({ message: "Phone number must be at least 7 characters" });
        }
        updates.phone = phone || null;
      }

      if (Object.keys(updates).length > 0) {
        await db
          .update(riderProfiles)
          .set(updates)
          .where(eq(riderProfiles.userId, userId));
      }

      const updated = await storage.getRiderProfile(userId);
      return res.json(updated);
    } catch (error) {
      console.error("Error updating rider profile:", error);
      return res.status(500).json({ message: "Failed to update profile" });
    }
  });

  app.patch("/api/rider/profile", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { fullName, email } = req.body;
      if (fullName && typeof fullName === "string" && fullName.trim().length > 0) {
        const nameParts = fullName.trim().split(" ");
        const firstName = nameParts[0];
        const lastName = nameParts.slice(1).join(" ") || "";
        await db.update(users).set({ firstName, lastName }).where(eq(users.id, userId));
      }
      if (email && typeof email === "string" && email.includes("@")) {
        await db.update(users).set({ email }).where(eq(users.id, userId));
      }
      const profile = await storage.getRiderProfile(userId);
      return res.json(profile || {});
    } catch (error) {
      console.error("Error updating rider profile:", error);
      return res.status(500).json({ message: "Failed to update profile" });
    }
  });

  // Get rider wallet
  app.get("/api/rider/wallet", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      let wallet = await storage.getRiderWallet(userId);
      
      // Auto-create wallet if doesn't exist
      if (!wallet) {
        const currency = await getUserCurrency(userId);
        wallet = await storage.createRiderWallet({ userId, currency });
      }
      
      // Check if user is a tester to include tester wallet info
      const isTester = await storage.isUserTester(userId);
      
      // Return wallet with currency forced to NGN and tester info
      return res.json({
        ...wallet,
        currency: "NGN", // Force NGN currency
        isTester,
        testerWalletBalance: wallet.testerWalletBalance || "0",
      });
    } catch (error) {
      console.error("Error getting rider wallet:", error);
      return res.status(500).json({ message: "Failed to get wallet" });
    }
  });

  app.get("/api/rider/wallet-info", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      let wallet = await storage.getRiderWallet(userId);
      if (!wallet) {
        const currency = await getUserCurrency(userId);
        wallet = await storage.createRiderWallet({ userId, currency });
      }
      const isTester = await storage.isUserTester(userId);
      const profile = await storage.getRiderProfile(userId);
      const backendMethod = profile?.paymentMethod || "WALLET";
      let defaultPaymentMethod = "MAIN_WALLET";
      if (backendMethod === "CASH") defaultPaymentMethod = "CASH";
      else if (backendMethod === "TEST_WALLET") defaultPaymentMethod = "TEST_WALLET";
      else defaultPaymentMethod = "MAIN_WALLET";

      return res.json({
        mainBalance: wallet.balance || "0",
        testBalance: wallet.testerWalletBalance || "0",
        currencyCode: "NGN",
        isTester,
        defaultPaymentMethod,
      });
    } catch (error) {
      console.error("Error getting rider wallet info:", error);
      return res.status(500).json({ message: "Failed to get wallet info" });
    }
  });

  // Get payment settings for rider (available methods based on mode)
  app.get("/api/rider/payment-settings", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getRiderProfile(userId);
      
      // Check if payments are in simulated mode
      const { isRealPaymentsEnabled } = await import("./payment-provider");
      const isNigeriaPaymentsEnabled = await isRealPaymentsEnabled("NG");
      const isSimulatedMode = !isNigeriaPaymentsEnabled;
      
      // Build available payment methods
      const availableMethods: { id: string; name: string; description: string; enabled: boolean }[] = [
        { id: "WALLET", name: "Wallet", description: "Pay from your ZIBA wallet balance", enabled: true },
      ];
      
      // Test Wallet only available in simulated mode
      if (isSimulatedMode) {
        availableMethods.push({
          id: "TEST_WALLET",
          name: "Test Wallet",
          description: "Testing only - No real charges (Simulated Mode)",
          enabled: true,
        });
      }
      
      // Cash always available
      availableMethods.push({
        id: "CASH",
        name: "Cash",
        description: "Pay driver directly with cash",
        enabled: true,
      });

      // Card only available for Nigeria with Paystack enabled
      if (isNigeriaPaymentsEnabled) {
        availableMethods.push({
          id: "CARD",
          name: "Card (Paystack)",
          description: "Pay with debit/credit card via Paystack",
          enabled: true,
        });
      }
      
      return res.json({
        currentMethod: profile?.paymentMethod || "WALLET",
        availableMethods,
        walletMode: isSimulatedMode ? "SIMULATED" : "REAL",
        isTestWalletAvailable: isSimulatedMode,
        isCardAvailable: isNigeriaPaymentsEnabled,
        isCashAvailable: true,
      });
    } catch (error) {
      console.error("Error getting payment settings:", error);
      return res.status(500).json({ message: "Failed to get payment settings" });
    }
  });

  // Update rider payment method
  app.patch("/api/rider/payment-method", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { paymentMethod } = req.body;
      
      if (!paymentMethod || !["WALLET", "TEST_WALLET", "CARD", "CASH"].includes(paymentMethod)) {
        return res.status(400).json({ message: "Invalid payment method" });
      }
      
      // Validate TEST_WALLET is only available in simulated mode
      if (paymentMethod === "TEST_WALLET") {
        const { isRealPaymentsEnabled } = await import("./payment-provider");
        const isSimulatedMode = !(await isRealPaymentsEnabled("NG"));
        if (!isSimulatedMode) {
          return res.status(400).json({ 
            message: "Test Wallet is only available in testing mode",
            code: "TEST_WALLET_NOT_AVAILABLE"
          });
        }
      }
      
      // Validate CARD is only available for Nigeria with Paystack enabled
      if (paymentMethod === "CARD") {
        const { isRealPaymentsEnabled } = await import("./payment-provider");
        const isCardAvailable = await isRealPaymentsEnabled("NG");
        if (!isCardAvailable) {
          return res.status(400).json({ 
            message: "Card payments are not yet available in your region",
            code: "CARD_NOT_AVAILABLE"
          });
        }
      }
      
      // Check if rider profile exists, create if not
      let profile = await storage.getRiderProfile(userId);
      if (!profile) {
        profile = await storage.createRiderProfile({ userId, paymentMethod });
      } else {
        profile = await storage.updateRiderPaymentMethod(userId, paymentMethod);
      }
      
      console.log(`[PAYMENT METHOD] User ${userId} changed to ${paymentMethod}`);
      
      return res.json({
        message: "Payment method updated",
        paymentMethod: profile?.paymentMethod,
      });
    } catch (error) {
      console.error("Error updating payment method:", error);
      return res.status(500).json({ message: "Failed to update payment method" });
    }
  });

  // Get rider's saved payment methods (cards, bank accounts)
  app.get("/api/rider/payment-methods", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const methods = await storage.getRiderPaymentMethods(userId);
      return res.json(methods);
    } catch (error) {
      console.error("Error getting payment methods:", error);
      return res.status(500).json({ message: "Failed to get payment methods" });
    }
  });

  // Add a new payment method (card via Paystack authorization)
  app.post("/api/rider/payment-methods", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { 
        type, 
        cardLast4, 
        cardBrand, 
        cardExpMonth, 
        cardExpYear,
        cardBin,
        bankName,
        bankAccountLast4,
        bankAccountName,
        mobileMoneyProvider,
        mobileMoneyNumberLast4,
        providerAuthCode,
        providerSignature,
        providerBank,
        providerChannel,
        providerReusable,
        nickname,
        isDefault 
      } = req.body;
      
      if (!type || !["CARD", "BANK", "MOBILE_MONEY"].includes(type)) {
        return res.status(400).json({ message: "Invalid payment method type" });
      }

      // Get user's country/currency
      const userRole = await storage.getUserRole(userId);
      const countryCode = userRole?.countryCode || "NG";
      const currency = countryCode === "NG" ? "NGN" : countryCode === "ZA" ? "ZAR" : "USD";

      // Check if this is the first method (make it default)
      const existingMethods = await storage.getRiderPaymentMethods(userId);
      const shouldBeDefault = isDefault || existingMethods.length === 0;

      const method = await storage.createRiderPaymentMethod({
        userId,
        type,
        cardLast4,
        cardBrand,
        cardExpMonth,
        cardExpYear,
        cardBin,
        bankName,
        bankAccountLast4,
        bankAccountName,
        mobileMoneyProvider,
        mobileMoneyNumberLast4,
        providerAuthCode,
        providerSignature,
        providerBank,
        providerChannel,
        providerReusable: providerReusable !== false,
        nickname,
        currency,
        countryCode,
        isDefault: shouldBeDefault,
        isActive: true,
      });

      console.log(`[PAYMENT METHODS] User ${userId} added ${type} ending in ${cardLast4 || bankAccountLast4 || mobileMoneyNumberLast4}`);
      
      return res.json(method);
    } catch (error) {
      console.error("Error adding payment method:", error);
      return res.status(500).json({ message: "Failed to add payment method" });
    }
  });

  // Set default payment method
  app.patch("/api/rider/payment-methods/:methodId/default", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { methodId } = req.params;
      
      const method = await storage.setDefaultPaymentMethod(userId, methodId);
      if (!method) {
        return res.status(404).json({ message: "Payment method not found" });
      }

      console.log(`[PAYMENT METHODS] User ${userId} set ${methodId} as default`);
      
      return res.json(method);
    } catch (error) {
      console.error("Error setting default payment method:", error);
      return res.status(500).json({ message: "Failed to set default payment method" });
    }
  });

  // Delete a payment method
  app.delete("/api/rider/payment-methods/:methodId", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { methodId } = req.params;
      
      const deleted = await storage.deleteRiderPaymentMethod(userId, methodId);
      if (!deleted) {
        return res.status(404).json({ message: "Payment method not found" });
      }

      console.log(`[PAYMENT METHODS] User ${userId} deleted ${methodId}`);
      
      return res.json({ message: "Payment method deleted" });
    } catch (error) {
      console.error("Error deleting payment method:", error);
      return res.status(500).json({ message: "Failed to delete payment method" });
    }
  });

  // Initialize card addition via Paystack (returns authorization URL)
  app.post("/api/rider/payment-methods/add-card/initialize", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userEmail = req.user.claims.email;
      
      if (!userEmail) {
        return res.status(400).json({ message: "User email not found" });
      }

      // Check if real payments are enabled for Nigeria
      const { isRealPaymentsEnabled, processPayment } = await import("./payment-provider");
      const isCardAvailable = await isRealPaymentsEnabled("NG");
      
      if (!isCardAvailable) {
        return res.status(400).json({ 
          message: "Card payments are not available in test mode. Cards can only be added when real payments are enabled.",
          code: "CARD_NOT_AVAILABLE"
        });
      }

      // Initialize a minimal payment to authorize the card (Paystack requires at least 50)
      const result = await processPayment("NG", {
        userId,
        email: userEmail,
        amount: 50, // Minimum for card authorization
        currency: "NGN",
        description: `Card authorization for user ${userId}`,
      });

      if (!result.success) {
        return res.status(400).json({ 
          message: result.error || "Failed to initialize card authorization",
          code: "INIT_FAILED"
        });
      }

      return res.json({
        authorizationUrl: result.authorizationUrl,
        accessCode: result.accessCode,
        reference: result.transactionRef,
      });
    } catch (error) {
      console.error("Error initializing card addition:", error);
      return res.status(500).json({ message: "Failed to initialize card addition" });
    }
  });

  // Verify card addition callback from Paystack
  app.post("/api/rider/payment-methods/add-card/verify", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { reference } = req.body;

      if (!reference) {
        return res.status(400).json({ message: "Reference is required" });
      }

      // Verify the transaction with Paystack
      const { verifyPayment } = await import("./payment-provider");
      const result = await verifyPayment("NG", reference);

      if (!result.success) {
        return res.status(400).json({ 
          message: "Card authorization failed. Please try again.",
          code: "VERIFICATION_FAILED"
        });
      }

      // Extract card details from Paystack response (these would be in the actual API response)
      // For now, return success - the actual card details would come from Paystack webhook
      return res.json({
        message: "Card added successfully",
        success: true,
      });
    } catch (error) {
      console.error("Error verifying card addition:", error);
      return res.status(500).json({ message: "Failed to verify card addition" });
    }
  });

  // Change rider's payment source (only allowed when not in an active ride)
  app.patch("/api/rider/payment-source", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { paymentSource, paymentMethodId } = req.body;

      // Validate paymentSource
      const validSources = ["MAIN_WALLET", "CARD"];
      if (!validSources.includes(paymentSource)) {
        return res.status(400).json({ 
          message: "Invalid payment source. Use MAIN_WALLET or CARD",
          code: "INVALID_PAYMENT_SOURCE"
        });
      }

      // Check if user is a tester - testers cannot change payment source
      const isTester = await storage.isUserTester(userId);
      if (isTester) {
        return res.status(403).json({ 
          message: "Testers can only use test wallet for payments",
          code: "TESTER_RESTRICTED"
        });
      }

      // Check if rider has an active ride
      const activeRide = await storage.getCurrentRiderRide(userId);
      if (activeRide) {
        return res.status(400).json({ 
          message: "Cannot change payment source during an active ride. Please complete or cancel your current ride first.",
          code: "ACTIVE_RIDE_EXISTS"
        });
      }

      // If switching to CARD, validate the payment method
      if (paymentSource === "CARD") {
        if (!paymentMethodId) {
          return res.status(400).json({ 
            message: "Payment method ID is required for card payments",
            code: "PAYMENT_METHOD_REQUIRED"
          });
        }

        const paymentMethod = await storage.getRiderPaymentMethod(paymentMethodId);
        if (!paymentMethod || paymentMethod.userId !== userId) {
          return res.status(400).json({ 
            message: "Invalid payment method",
            code: "INVALID_PAYMENT_METHOD"
          });
        }

        if (!paymentMethod.isActive || !paymentMethod.providerReusable) {
          return res.status(400).json({ 
            message: "This payment method cannot be used",
            code: "PAYMENT_METHOD_UNAVAILABLE"
          });
        }

        // Check if real payments are enabled for user's country
        const userRole = await storage.getUserRole(userId);
        const countryCode = userRole?.countryCode || "NG";
        const country = await storage.getCountryByCode(countryCode);
        
        if (!country?.paymentsEnabled) {
          return res.status(400).json({ 
            message: "Card payments are not available in your region yet",
            code: "CARD_PAYMENTS_NOT_ENABLED"
          });
        }
      }

      // Update wallet payment source
      await storage.updateRiderWalletPaymentSource(userId, paymentSource);

      console.log(`[PAYMENT SOURCE] User ${userId} switched to ${paymentSource}${paymentMethodId ? ` (method: ${paymentMethodId})` : ""}`);

      return res.json({ 
        message: "Payment source updated",
        paymentSource,
        paymentMethodId: paymentSource === "CARD" ? paymentMethodId : null
      });
    } catch (error) {
      console.error("Error updating payment source:", error);
      return res.status(500).json({ message: "Failed to update payment source" });
    }
  });

  app.post("/api/admin/ride-classes/:classId/toggle", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { classId } = req.params;
      const { isActive } = req.body;
      const userId = req.user.claims.sub;
      console.log(`[ADMIN] User ${userId} toggled ride class ${classId} to ${isActive ? 'active' : 'disabled'}`);
      return res.json({ success: true, classId, isActive, message: `Ride class ${classId} ${isActive ? 'activated' : 'disabled'}` });
    } catch (error) {
      return res.status(500).json({ message: "Failed to toggle ride class" });
    }
  });

  app.post("/api/admin/ride-classes/:classId/pricing", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { classId } = req.params;
      const { baseFare, perKmRate, perMinuteRate, minimumFare, surcharge } = req.body;
      const userId = req.user.claims.sub;
      console.log(`[ADMIN] User ${userId} updated pricing for ride class ${classId}:`, { baseFare, perKmRate, perMinuteRate, minimumFare, surcharge });
      return res.json({ success: true, classId, pricing: { baseFare, perKmRate, perMinuteRate, minimumFare, surcharge }, message: `Pricing updated for ${classId}` });
    } catch (error) {
      return res.status(500).json({ message: "Failed to update pricing" });
    }
  });

  app.get("/api/ride-classes", isAuthenticated, async (req: any, res) => {
    try {
      const { RIDE_CLASS_LIST } = await import("@shared/ride-classes");
      return res.json(RIDE_CLASS_LIST);
    } catch (error) {
      console.error("Error getting ride classes:", error);
      return res.status(500).json({ message: "Failed to get ride classes" });
    }
  });

  app.get("/api/ride-classes/availability", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const { RIDE_CLASS_LIST } = await import("@shared/ride-classes");
      
      const availability = RIDE_CLASS_LIST.map(rc => {
        const isAvailable = rc.isActive;
        const driverCount = isAvailable ? Math.floor(Math.random() * 8) + 1 : 0;
        return {
          rideClassId: rc.id,
          available: isAvailable && driverCount > 0,
          driverCount,
          estimatedWaitMinutes: isAvailable ? Math.floor(Math.random() * 8) + 2 : 0,
        };
      });

      return res.json(availability);
    } catch (error) {
      console.error("Error getting ride class availability:", error);
      return res.status(500).json({ message: "Failed to get availability" });
    }
  });

  app.post("/api/rider/fare-estimate", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const { rideClassId } = req.body;
      const { getRideClassMultiplier, isValidRideClass, calculateClassFareRange, getRideClassPricing } = await import("@shared/ride-classes");

      const classId = rideClassId && isValidRideClass(rideClassId) ? rideClassId : "go";
      const multiplier = getRideClassMultiplier(classId);
      const pricing = getRideClassPricing(classId as any);

      const estimatedDistanceKm = Math.random() * 15 + 3;
      const estimatedDurationMin = estimatedDistanceKm * 3 + Math.random() * 10;

      const range = calculateClassFareRange(classId as any, estimatedDistanceKm, estimatedDurationMin);

      const userId = req.user.claims.sub;
      const { getCountryConfig } = await import("@shared/countries");
      const userRole = await storage.getUserRole(userId);
      const countryCode = userRole?.countryCode || "NG";
      const countryConfig = getCountryConfig(countryCode);

      return res.json({
        rideClass: classId,
        fareMultiplier: multiplier,
        estimatedFare: range.estimate,
        fareRange: { min: range.min, max: range.max },
        fareBreakdown: range.breakdown,
        pricing: {
          baseFare: pricing.baseFare,
          perKmRate: pricing.perKmRate,
          perMinuteRate: pricing.perMinuteRate,
          minimumFare: pricing.minimumFare,
          surcharge: pricing.surcharge,
        },
        currencyCode: countryConfig.currencyCode,
        estimatedDistanceKm: parseFloat(estimatedDistanceKm.toFixed(1)),
        estimatedDurationMin: Math.round(estimatedDurationMin),
      });
    } catch (error) {
      console.error("Error calculating fare estimate:", error);
      return res.status(500).json({ message: "Failed to calculate fare estimate" });
    }
  });

  app.get("/api/rider/current-trip", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const trip = await storage.getRiderCurrentTrip(userId);
      if (trip) {
        const { driverPayout, commissionAmount, commissionPercentage, ...sanitized } = trip as any;
        return res.json(sanitized);
      }
      return res.json(trip);
    } catch (error) {
      console.error("Error getting current trip:", error);
      return res.status(500).json({ message: "Failed to get current trip" });
    }
  });

  app.get("/api/rider/trip-history", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { status, startDate, endDate } = req.query;
      const filter: any = {};
      if (status) filter.status = status;
      if (startDate) filter.startDate = startDate;
      if (endDate) filter.endDate = endDate;
      
      const hasFilters = Object.keys(filter).length > 0;
      const trips = hasFilters 
        ? await storage.getRiderTripHistoryFiltered(userId, filter)
        : await storage.getRiderTripHistory(userId);
      const sanitized = trips.map(({ driverPayout, commissionAmount, commissionPercentage, ...rest }: any) => rest);
      return res.json(sanitized);
    } catch (error) {
      console.error("Error getting trip history:", error);
      return res.status(500).json({ message: "Failed to get trip history" });
    }
  });

  app.post("/api/rider/request-ride", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      // ASSERT FINANCIAL ENGINE IS LOCKED
      assertFinancialEngineLocked();

      // Phase 6: Kill-switch and launch readiness check
      const { checkTripRequestAllowed } = await import("./launch-control");
      const userId = req.user.claims.sub;
      const userRoleForLaunch = await storage.getUserRole(userId);
      const launchCountry = userRoleForLaunch?.countryCode || "NG";
      const stateCode = req.body.stateCode;
      const launchCheck = await checkTripRequestAllowed(launchCountry, stateCode);
      if (!launchCheck.allowed) {
        return res.status(403).json({ message: launchCheck.reason, code: launchCheck.code });
      }
      
      const parsed = insertTripSchema.safeParse({ ...req.body, riderId: userId });
      
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid trip data", errors: parsed.error.flatten() });
      }

      const currentTrip = await storage.getRiderCurrentTrip(userId);
      if (currentTrip) {
        return res.status(400).json({ message: "Already have an active trip" });
      }

      // Get user's country for country-aware config
      const userRole = await storage.getUserRole(userId);
      const countryCode = userRole?.countryCode || "NG";
      const countryConfig = getCountryConfig(countryCode);

      // Get or create rider wallet with user's country currency
      let riderWallet = await storage.getRiderWallet(userId);
      if (!riderWallet) {
        riderWallet = await storage.createRiderWallet({ userId, currency: countryConfig.currencyCode });
      }

      // SERVER-SIDE WALLET RESOLUTION - Payment method from request body takes priority over saved profile
      const isTester = await storage.isUserTester(userId);
      const riderProfile = await storage.getRiderProfile(userId);
      const requestPaymentMethod = req.body.paymentMethod || req.body.paymentSource;
      const riderPaymentMethod = requestPaymentMethod || riderProfile?.paymentMethod || "WALLET";
      
      // Resolve payment source: Cash uses CASH, Testers always use TEST_WALLET, non-testers use MAIN_WALLET
      const resolvedPaymentSource = (riderPaymentMethod === "CASH") ? "CASH" 
        : isTester ? "TEST_WALLET" : "MAIN_WALLET";
      
      console.log(`[RIDE REQUEST] userId=${userId}, requestPaymentMethod=${requestPaymentMethod || "none"}, profilePaymentMethod=${riderProfile?.paymentMethod || "none"}, resolved=${resolvedPaymentSource}, isTester=${isTester}`);
      
      // Get the correct balance based on resolved payment source (cash trips skip balance check)
      let availableBalance: number;
      
      if (resolvedPaymentSource === "CASH") {
        availableBalance = Infinity;
        console.log(`[WALLET RESOLUTION] Cash user ${userId} - using CASH, no balance check`);
      } else if (resolvedPaymentSource === "TEST_WALLET") {
        availableBalance = parseFloat(String(riderWallet.testerWalletBalance || "0"));
        console.log(`[WALLET RESOLUTION] Tester user ${userId} - using TEST_WALLET, balance: ${availableBalance}`);
      } else {
        availableBalance = parseFloat(String(riderWallet.balance || "0")) - parseFloat(String(riderWallet.lockedBalance || "0"));
        console.log(`[WALLET RESOLUTION] Regular user ${userId} - using MAIN_WALLET, balance: ${availableBalance}`);
      }

      // CURRENCY CONSISTENCY - Trip currency MUST match country currency
      const walletCurrency = riderWallet.currency || countryConfig.currencyCode;
      const tripCurrency = countryConfig.currencyCode; // FORCED to country currency

      // ===========================================
      // GLOBAL FINANCIAL GUARDS (ALL COUNTRIES)
      // ===========================================
      const guardResult = validateRideRequest({
        userId,
        isTester,
        walletCurrency,
        tripCurrency,
        countryCode,
        availableBalance,
        walletFrozen: riderWallet.isFrozen || false,
        userSuspended: false, // TODO: Add user suspension check
        resolvedPaymentSource,
      });

      if (!guardResult.allowed) {
        return res.status(400).json({
          message: guardResult.message,
          code: guardResult.code,
          ...guardResult.details,
        });
      }

      // Update wallet's payment source if it doesn't match (auto-sync for testers)
      if (isTester && riderWallet.paymentSource !== "TEST_WALLET") {
        await storage.updateRiderWalletPaymentSource(userId, "TEST_WALLET");
      } else if (!isTester && riderWallet.paymentSource !== "MAIN_WALLET") {
        await storage.updateRiderWalletPaymentSource(userId, "MAIN_WALLET");
      }

      // Create the trip with FULL financial tracking
      const tripData = {
        ...parsed.data,
        paymentSource: resolvedPaymentSource as "TEST_WALLET" | "MAIN_WALLET" | "CARD" | "BANK" | "CASH",
        isTestTrip: isTester,
        currencyCode: tripCurrency,
        countryId: countryCode,
      };
      
      const trip = await storage.createTrip(tripData);
      
      console.log(`[RIDE CREATED] tripId=${trip.id}, userId=${userId}, countryCode=${countryCode}, ` +
        `paymentSource=${resolvedPaymentSource}, isTester=${isTester}, walletBalance=${availableBalance}, ` +
        `currency=${tripCurrency}`);
      
      await storage.notifyAllDrivers(
        "New Ride Request",
        `New ride from ${parsed.data.pickupLocation} to ${parsed.data.dropoffLocation}`,
        "info"
      );
      
      return res.json(trip);
    } catch (error) {
      console.error("Error requesting ride:", error);
      return res.status(500).json({ message: "Failed to request ride" });
    }
  });

  app.post("/api/trips/schedule", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { pickupLocation, dropoffLocation, scheduledPickupAt, paymentSource } = req.body;

      if (!pickupLocation || !dropoffLocation || !scheduledPickupAt) {
        return res.status(400).json({ message: "Pickup, drop-off, and scheduled time are required" });
      }

      const scheduledDate = new Date(scheduledPickupAt);
      if (isNaN(scheduledDate.getTime()) || scheduledDate <= new Date()) {
        return res.status(400).json({ message: "Scheduled time must be in the future" });
      }

      const resolvedPayment = paymentSource === "CASH" ? "CASH" : "MAIN_WALLET";

      const userRole = await storage.getUserRole(userId);
      const countryCode = userRole?.countryCode || "NG";
      const countryCurrencies: Record<string, string> = { NG: "NGN", US: "USD", ZA: "ZAR", GH: "GHS", CA: "CAD", KE: "KES" };
      const tripCurrency = countryCurrencies[countryCode] || "NGN";

      const trip = await storage.createTrip({
        riderId: userId,
        pickupLocation,
        dropoffLocation,
        passengerCount: 1,
        paymentSource: resolvedPayment as any,
        isTestTrip: false,
        currencyCode: tripCurrency,
        countryId: countryCode,
        isReserved: true,
        scheduledPickupAt: scheduledDate,
        reservationStatus: "scheduled",
      });

      console.log(`[SCHEDULED RIDE] tripId=${trip.id}, userId=${userId}, scheduledAt=${scheduledPickupAt}, payment=${resolvedPayment}`);

      return res.json(trip);
    } catch (error) {
      console.error("Error scheduling ride:", error);
      return res.status(500).json({ message: "Failed to schedule ride" });
    }
  });

  app.get("/api/admin/scheduled-trips", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const allTrips = await storage.getAllTrips();
      const scheduledTrips = allTrips.filter((t: any) => t.isReserved === true);
      return res.json(scheduledTrips);
    } catch (error) {
      console.error("Error fetching scheduled trips:", error);
      return res.status(500).json({ message: "Failed to fetch scheduled trips" });
    }
  });

  app.post("/api/admin/scheduled-trips/:tripId/assign-driver", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { tripId } = req.params;
      const { driverId } = req.body;
      if (!driverId) {
        return res.status(400).json({ message: "Driver ID is required" });
      }
      const trip = await storage.getTripById(tripId);
      if (!trip || !trip.isReserved) {
        return res.status(404).json({ message: "Scheduled trip not found" });
      }
      const updated = await storage.updateTrip(tripId, {
        driverId,
        reservationStatus: "driver_assigned",
        status: "accepted",
        acceptedAt: new Date(),
      });
      return res.json(updated);
    } catch (error) {
      console.error("Error assigning driver:", error);
      return res.status(500).json({ message: "Failed to assign driver" });
    }
  });

  app.post("/api/admin/scheduled-trips/:tripId/cancel", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { tripId } = req.params;
      const { reason } = req.body;
      const trip = await storage.getTripById(tripId);
      if (!trip || !trip.isReserved) {
        return res.status(404).json({ message: "Scheduled trip not found" });
      }
      const cancelled = await storage.adminCancelTrip(tripId, reason || "Cancelled by admin");
      return res.json(cancelled);
    } catch (error) {
      console.error("Error cancelling scheduled trip:", error);
      return res.status(500).json({ message: "Failed to cancel scheduled trip" });
    }
  });

  app.get("/api/driver/scheduled-trips", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const allTrips = await storage.getAllTrips();
      const driverScheduled = allTrips.filter((t: any) => {
        if (!t.isReserved) return false;
        if (t.status === "cancelled" || t.status === "completed") return false;
        const isAssignedToMe = t.driverId === userId;
        const isUnassigned = !t.driverId && t.reservationStatus === "scheduled";
        return isAssignedToMe || isUnassigned;
      });
      return res.json(driverScheduled);
    } catch (error) {
      console.error("Error fetching driver scheduled trips:", error);
      return res.status(500).json({ message: "Failed to fetch scheduled trips" });
    }
  });

  app.post("/api/driver/scheduled-trips/:tripId/accept", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { tripId } = req.params;
      const trip = await storage.getTripById(tripId);
      if (!trip || !trip.isReserved) {
        return res.status(404).json({ message: "Scheduled trip not found" });
      }
      if (trip.driverId && trip.driverId !== userId) {
        return res.status(400).json({ message: "This trip has already been assigned to another driver" });
      }
      const updated = await storage.updateTrip(tripId, {
        driverId: userId,
        reservationStatus: "driver_assigned",
        status: "accepted",
        acceptedAt: new Date(),
      });
      return res.json(updated);
    } catch (error) {
      console.error("Error accepting scheduled trip:", error);
      return res.status(500).json({ message: "Failed to accept trip" });
    }
  });

  app.post("/api/driver/scheduled-trips/:tripId/start", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { tripId } = req.params;
      const trip = await storage.getTripById(tripId);
      if (!trip || !trip.isReserved) {
        return res.status(404).json({ message: "Scheduled trip not found" });
      }
      if (trip.driverId !== userId) {
        return res.status(403).json({ message: "This trip is not assigned to you" });
      }
      if (trip.scheduledPickupAt) {
        const scheduledTime = new Date(trip.scheduledPickupAt).getTime();
        const now = Date.now();
        const fifteenMinMs = 15 * 60 * 1000;
        if (scheduledTime - now > fifteenMinMs) {
          const minutesUntil = Math.ceil((scheduledTime - now) / 60000);
          return res.status(400).json({ message: `Too early to start. Trip is scheduled in ${minutesUntil} minutes. You can start within 15 minutes of the scheduled time.` });
        }
      }
      const updated = await storage.updateTrip(tripId, {
        status: "in_progress",
        reservationStatus: "active",
      });
      return res.json(updated);
    } catch (error) {
      console.error("Error starting scheduled trip:", error);
      return res.status(500).json({ message: "Failed to start trip" });
    }
  });

  app.get("/api/rider/cancellation-metrics", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const allTrips = await storage.getRiderTripHistory(userId);
      const totalTrips = allTrips.length;
      const cancelledTrips = allTrips.filter((t: any) => t.status === "cancelled" && t.cancelledBy === "rider").length;
      const cancellationRate = totalTrips > 0 ? (cancelledTrips / totalTrips) * 100 : 0;
      const warningThreshold = 15;
      return res.json({
        cancellationRate: Math.round(cancellationRate * 10) / 10,
        recentCancellations: cancelledTrips,
        totalTrips,
        warningThreshold,
        shouldWarn: totalTrips >= 5 && cancellationRate >= warningThreshold,
      });
    } catch (error) {
      console.error("Error getting rider cancellation metrics:", error);
      return res.status(500).json({ message: "Failed to get cancellation metrics" });
    }
  });

  app.post("/api/rider/cancel-ride/:tripId", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { tripId } = req.params;
      const { reason } = req.body || {};

      const existingTrip = await storage.getTripById(tripId);
      if (!existingTrip) {
        return res.status(404).json({ message: "Trip not found" });
      }

      let cancellationFeeAmount: string | null = null;
      let feeDeducted = false;
      let feeMessage = "";

      try {
        const userRole = await storage.getUserRole(userId);
        const countryCode = userRole?.countryCode || "NG";
        const feeConfig = await storage.getCancellationFeeConfig(countryCode);

        if (feeConfig) {
          const gracePeriodMs = (feeConfig.gracePeriodMinutes || 3) * 60 * 1000;
          const tripCreatedAt = existingTrip.createdAt ? new Date(existingTrip.createdAt).getTime() : 0;
          const timeSinceRequest = Date.now() - tripCreatedAt;
          const isWithinGrace = timeSinceRequest < gracePeriodMs;

          if (existingTrip.isReserved && existingTrip.scheduledPickupAt) {
            const scheduledTime = new Date(existingTrip.scheduledPickupAt).getTime();
            const cancelWindowMs = (feeConfig.scheduledCancelWindowMinutes || 30) * 60 * 1000;
            const timeUntilPickup = scheduledTime - Date.now();

            if (timeUntilPickup <= cancelWindowMs) {
              cancellationFeeAmount = feeConfig.scheduledPenaltyAmount;
              feeMessage = `Scheduled ride cancellation fee of ${feeConfig.scheduledPenaltyAmount} applied (cancelled within ${feeConfig.scheduledCancelWindowMinutes} minutes of pickup).`;
            }
          } else if (!isWithinGrace && existingTrip.status !== "requested") {
            if (existingTrip.status === "accepted" && existingTrip.driverId) {
              cancellationFeeAmount = feeConfig.cancellationFeeAmount;
              feeMessage = `Cancellation fee of ${feeConfig.cancellationFeeAmount} applied (driver already assigned).`;
            }
          }

          if (cancellationFeeAmount) {
            const riderProfile = await storage.getRiderProfile(userId);
            if (riderProfile && (riderProfile.paymentMethod === "WALLET" || riderProfile.paymentMethod === "TEST_WALLET")) {
              const riderWallet = await storage.getRiderWallet(userId);
              if (riderWallet && parseFloat(riderWallet.balance) >= parseFloat(cancellationFeeAmount)) {
                await storage.updateRiderWalletBalance(userId, parseFloat(cancellationFeeAmount), "debit");
                feeDeducted = true;
                feeMessage += " Fee deducted from your wallet.";
              } else {
                feeMessage += " Insufficient wallet balance - fee recorded but not deducted.";
              }
            } else {
              feeMessage += " Fee recorded on your account.";
            }

            await storage.createRiderInboxMessage({
              userId,
              title: "Cancellation Fee Applied",
              body: feeMessage,
              type: "payment_alert",
              read: false,
              referenceId: tripId,
              referenceType: "trip_cancellation",
            });
          }
        }
      } catch (feeError) {
        console.error("Error processing cancellation fee:", feeError);
      }

      const trip = await storage.cancelTrip(tripId, userId, reason);
      if (!trip) {
        return res.status(404).json({ message: "Trip not found or cannot be cancelled" });
      }

      if (cancellationFeeAmount) {
        try {
          await storage.updateTrip(tripId, {
            cancellationFeeApplied: cancellationFeeAmount,
            cancellationFeeDeducted: feeDeducted,
          });
        } catch (updateError) {
          console.error("Error updating trip cancellation fee fields:", updateError);
        }
      }

      // Phase 5: Update behavior stats on cancellation and void promos
      try {
        await evaluateBehaviorAndWarnings(userId, "rider");
        if (trip.driverId) {
          await evaluateBehaviorAndWarnings(trip.driverId, "driver");
        }
        await voidPromosOnCancellation(tripId);
      } catch (behaviorError) {
        console.error("Error updating behavior on cancellation:", behaviorError);
      }

      return res.json({
        ...trip,
        cancellationFeeApplied: cancellationFeeAmount,
        cancellationFeeDeducted: feeDeducted,
        cancellationFeeMessage: feeMessage || undefined,
      });
    } catch (error) {
      console.error("Error cancelling ride:", error);
      return res.status(500).json({ message: "Failed to cancel ride" });
    }
  });

  app.get("/api/admin/drivers", isAuthenticated, requireRole(["admin", "director"]), async (req: any, res) => {
    try {
      const drivers = await storage.getAllDriversWithDetails();
      return res.json(drivers);
    } catch (error) {
      console.error("Error getting drivers:", error);
      return res.status(500).json({ message: "Failed to get drivers" });
    }
  });

  app.get("/api/admin/trips", isAuthenticated, requireRole(["admin", "director"]), async (req: any, res) => {
    try {
      const { status, startDate, endDate, driverId, riderId } = req.query;
      const filter: any = {};
      if (status) filter.status = status;
      if (startDate) filter.startDate = startDate;
      if (endDate) filter.endDate = endDate;
      if (driverId) filter.driverId = driverId;
      if (riderId) filter.riderId = riderId;
      
      const hasFilters = Object.keys(filter).length > 0;
      const trips = hasFilters 
        ? await storage.getFilteredTrips(filter)
        : await storage.getAllTripsWithDetails();
      return res.json(trips);
    } catch (error) {
      console.error("Error getting trips:", error);
      return res.status(500).json({ message: "Failed to get trips" });
    }
  });

  app.get("/api/trips/:tripId", isAuthenticated, async (req: any, res) => {
    try {
      const { tripId } = req.params;
      const userId = req.user.claims.sub;
      const userRole = await storage.getUserRole(userId);
      
      const trip = await storage.getTripById(tripId);
      if (!trip) {
        return res.status(404).json({ message: "Trip not found" });
      }

      if (userRole?.role === "admin" || userRole?.role === "director") {
        return res.json(trip);
      }
      if (userRole?.role === "driver" && trip.driverId === userId) {
        return res.json(trip);
      }
      if (userRole?.role === "rider" && trip.riderId === userId) {
        return res.json(trip);
      }

      return res.status(403).json({ message: "Access denied" });
    } catch (error) {
      console.error("Error getting trip:", error);
      return res.status(500).json({ message: "Failed to get trip" });
    }
  });

  app.get("/api/admin/stats", isAuthenticated, requireRole(["admin", "director", "super_admin"]), async (req: any, res) => {
    try {
      const stats = await storage.getAdminStats();
      return res.json(stats);
    } catch (error) {
      console.error("Error getting stats:", error);
      return res.status(500).json({ message: "Failed to get stats" });
    }
  });

  // ==========================================
  // SUPER_ADMIN ONLY: Admin Appointment System
  // ==========================================

  // Get all admins (SUPER_ADMIN only)
  app.get("/api/super-admin/admins", isAuthenticated, requireSuperAdmin, async (req: any, res) => {
    try {
      const admins = await storage.getAllAdmins();
      return res.json(admins);
    } catch (error) {
      console.error("Error getting admins:", error);
      return res.status(500).json({ message: "Failed to get admins" });
    }
  });

  // Appoint a new admin (SUPER_ADMIN only)
  app.post("/api/super-admin/appoint-admin", isAuthenticated, requireSuperAdmin, async (req: any, res) => {
    try {
      const { userId, adminStartAt, adminEndAt, adminPermissions } = req.body;
      const appointedBy = req.user.claims.sub;

      if (!userId || !adminStartAt || !adminEndAt || !adminPermissions) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      if (!Array.isArray(adminPermissions) || adminPermissions.length === 0) {
        return res.status(400).json({ message: "At least one permission scope is required" });
      }

      const startDate = new Date(adminStartAt);
      const endDate = new Date(adminEndAt);

      if (endDate <= startDate) {
        return res.status(400).json({ message: "End date must be after start date" });
      }

      const maxDuration = 365 * 24 * 60 * 60 * 1000; // 1 year max
      if (endDate.getTime() - startDate.getTime() > maxDuration) {
        return res.status(400).json({ message: "Admin appointment cannot exceed 1 year" });
      }

      const admin = await storage.appointAdmin(userId, startDate, endDate, adminPermissions, appointedBy);
      
      await storage.createAuditLog({
        action: "ADMIN_APPOINTED",
        entityType: "user_role",
        entityId: userId,
        performedByUserId: appointedBy,
        performedByRole: "super_admin",
        metadata: JSON.stringify({ adminStartAt, adminEndAt, adminPermissions })
      });

      return res.json(admin);
    } catch (error) {
      console.error("Error appointing admin:", error);
      return res.status(500).json({ message: "Failed to appoint admin" });
    }
  });

  // Revoke admin access (SUPER_ADMIN only)
  app.post("/api/super-admin/revoke-admin/:userId", isAuthenticated, requireSuperAdmin, async (req: any, res) => {
    try {
      const { userId } = req.params;
      const revokedBy = req.user.claims.sub;

      const admin = await storage.revokeAdmin(userId);
      if (!admin) {
        return res.status(404).json({ message: "User not found" });
      }

      await storage.createAuditLog({
        action: "ADMIN_REVOKED",
        entityType: "user_role",
        entityId: userId,
        performedByUserId: revokedBy,
        performedByRole: "super_admin",
        metadata: JSON.stringify({ oldRole: "admin", newRole: "rider" })
      });

      return res.json(admin);
    } catch (error) {
      console.error("Error revoking admin:", error);
      return res.status(500).json({ message: "Failed to revoke admin" });
    }
  });

  // Update admin permissions (SUPER_ADMIN only)
  app.patch("/api/super-admin/admin/:userId/permissions", isAuthenticated, requireSuperAdmin, async (req: any, res) => {
    try {
      const { userId } = req.params;
      const { adminPermissions, adminEndAt } = req.body;
      const updatedBy = req.user.claims.sub;

      if (!adminPermissions || !Array.isArray(adminPermissions) || adminPermissions.length === 0) {
        return res.status(400).json({ message: "At least one permission scope is required" });
      }

      const endDate = adminEndAt ? new Date(adminEndAt) : undefined;
      const admin = await storage.updateAdminPermissions(userId, adminPermissions, endDate);
      
      if (!admin) {
        return res.status(404).json({ message: "Admin not found" });
      }

      await storage.createAuditLog({
        action: "ADMIN_PERMISSIONS_UPDATED",
        entityType: "user_role",
        entityId: userId,
        performedByUserId: updatedBy,
        performedByRole: "super_admin",
        metadata: JSON.stringify({ adminPermissions, adminEndAt })
      });

      return res.json(admin);
    } catch (error) {
      console.error("Error updating admin permissions:", error);
      return res.status(500).json({ message: "Failed to update admin permissions" });
    }
  });

  // Check admin validity (SUPER_ADMIN only)
  app.get("/api/super-admin/admin/:userId/validity", isAuthenticated, requireSuperAdmin, async (req: any, res) => {
    try {
      const { userId } = req.params;
      const result = await storage.isAdminValid(userId);
      return res.json(result);
    } catch (error) {
      console.error("Error checking admin validity:", error);
      return res.status(500).json({ message: "Failed to check admin validity" });
    }
  });

  // Trigger expired admin cleanup (SUPER_ADMIN only - can also be scheduled)
  app.post("/api/super-admin/expire-admins", isAuthenticated, requireSuperAdmin, async (req: any, res) => {
    try {
      const count = await storage.checkAndExpireAdmins();
      
      await storage.createAuditLog({
        action: "ADMINS_EXPIRED",
        entityType: "system",
        entityId: "batch",
        performedByUserId: req.user.claims.sub,
        performedByRole: "super_admin",
        metadata: JSON.stringify({ expiredCount: count })
      });

      return res.json({ expiredCount: count });
    } catch (error) {
      console.error("Error expiring admins:", error);
      return res.status(500).json({ message: "Failed to expire admins" });
    }
  });

  // ==========================================
  // ROLE APPOINTMENTS (SUPER_ADMIN ONLY)
  // ==========================================

  // Get all users with their roles (SUPER_ADMIN only)
  app.get("/api/super-admin/users-with-roles", isAuthenticated, requireSuperAdmin, async (req: any, res) => {
    try {
      const usersWithRoles = await storage.getAllUsersWithRoles();
      return res.json(usersWithRoles);
    } catch (error) {
      console.error("Error getting users with roles:", error);
      return res.status(500).json({ message: "Failed to get users" });
    }
  });

  // MULTI-ROLE SYSTEM: Admin endpoint to assign a role to a user (SUPER_ADMIN only)
  app.post("/api/admin/assign-role", isAuthenticated, requireSuperAdmin, async (req: any, res) => {
    try {
      const { userId, role, countryCode = "NG" } = req.body;
      const assignedBy = req.user.claims.sub;

      if (!userId || !role) {
        return res.status(400).json({ message: "userId and role are required" });
      }

      // Prevent assigning super_admin role via this endpoint
      if (role === "super_admin") {
        return res.status(403).json({ message: "Cannot assign super_admin role via this endpoint" });
      }

      // Check if user already has this role
      const hasRole = await storage.hasRole(userId, role);
      if (hasRole) {
        return res.status(400).json({ message: "You already have this account type." });
      }

      // Add the role
      const result = await storage.addRoleToUser(userId, role, countryCode);
      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      // Create role-specific profiles if needed
      if (role === "rider") {
        const existingRiderProfile = await storage.getRiderProfile(userId);
        if (!existingRiderProfile) {
          await storage.createRiderProfile({ userId });
        }
      } else if (role === "driver") {
        const existingDriverProfile = await storage.getDriverProfile(userId);
        if (!existingDriverProfile) {
          await storage.createDriverProfile({ userId, status: "pending" });
        }
      }
      
      // DEFAULT RATING: Create trust profile with 5.0 stars on role assignment
      await storage.getOrCreateUserTrustProfile(userId);

      // Create audit log
      await storage.createAuditLog({
        action: "MULTI_ROLE_ASSIGN",
        entityType: "user_role",
        entityId: userId,
        performedByUserId: assignedBy,
        performedByRole: "super_admin",
        metadata: JSON.stringify({ assignedRole: role, countryCode })
      });

      // Return all roles for the user
      const allRoles = await storage.getAllUserRoles(userId);
      return res.json({
        success: true,
        role: result.role,
        roles: allRoles.map(r => r.role),
        roleCount: allRoles.length
      });
    } catch (error) {
      console.error("Error assigning role:", error);
      return res.status(500).json({ message: "Failed to assign role" });
    }
  });

  // MULTI-ROLE SYSTEM: Admin endpoint to remove a specific role from a user (SUPER_ADMIN only)
  app.post("/api/admin/remove-role", isAuthenticated, requireSuperAdmin, async (req: any, res) => {
    try {
      const { userId, role } = req.body;
      const removedBy = req.user.claims.sub;

      if (!userId || !role) {
        return res.status(400).json({ message: "userId and role are required" });
      }

      // Prevent removing super_admin role via this endpoint
      if (role === "super_admin") {
        return res.status(403).json({ message: "Cannot remove super_admin role via this endpoint" });
      }

      // Check if user has this role
      const hasRole = await storage.hasRole(userId, role);
      if (!hasRole) {
        return res.status(400).json({ message: "User does not have this role" });
      }

      // Remove the specific role
      await storage.deleteSpecificRole(userId, role);

      // Create audit log
      await storage.createAuditLog({
        action: "MULTI_ROLE_REMOVE",
        entityType: "user_role",
        entityId: userId,
        performedByUserId: removedBy,
        performedByRole: "super_admin",
        metadata: JSON.stringify({ removedRole: role })
      });

      // Return remaining roles for the user
      const allRoles = await storage.getAllUserRoles(userId);
      return res.json({
        success: true,
        roles: allRoles.map(r => r.role),
        roleCount: allRoles.length
      });
    } catch (error) {
      console.error("Error removing role:", error);
      return res.status(500).json({ message: "Failed to remove role" });
    }
  });

  // Promote user to admin (SUPER_ADMIN only)
  app.post("/api/super-admin/promote/:userId", isAuthenticated, requireSuperAdmin, async (req: any, res) => {
    try {
      const { userId } = req.params;
      const promotedBy = req.user.claims.sub;
      
      // Check if user exists
      const targetRole = await storage.getUserRole(userId);
      if (targetRole?.role === "super_admin") {
        return res.status(400).json({ message: "Cannot modify super_admin role" });
      }
      if (targetRole?.role === "admin") {
        return res.status(400).json({ message: "User is already an admin" });
      }
      
      const updatedRole = await storage.promoteToAdmin(userId, promotedBy);
      
      await storage.createAuditLog({
        action: "ROLE_PROMOTE_TO_ADMIN",
        entityType: "user_role",
        entityId: userId,
        performedByUserId: promotedBy,
        performedByRole: "super_admin",
        metadata: JSON.stringify({ oldRole: targetRole?.role || null, newRole: "admin" })
      });
      
      return res.json(updatedRole);
    } catch (error) {
      console.error("Error promoting user:", error);
      return res.status(500).json({ message: "Failed to promote user" });
    }
  });

  // Demote admin to rider (SUPER_ADMIN only)
  app.post("/api/super-admin/demote/:userId", isAuthenticated, requireSuperAdmin, async (req: any, res) => {
    try {
      const { userId } = req.params;
      const demotedBy = req.user.claims.sub;
      
      // Check if user is super_admin
      const targetRole = await storage.getUserRole(userId);
      if (targetRole?.role === "super_admin") {
        return res.status(400).json({ message: "Cannot demote super_admin" });
      }
      if (targetRole?.role !== "admin") {
        return res.status(400).json({ message: "User is not an admin" });
      }
      
      const updatedRole = await storage.demoteToRider(userId);
      
      await storage.createAuditLog({
        action: "ROLE_DEMOTE_TO_RIDER",
        entityType: "user_role",
        entityId: userId,
        performedByUserId: demotedBy,
        performedByRole: "super_admin",
        metadata: JSON.stringify({ oldRole: "admin", newRole: "rider" })
      });
      
      return res.json(updatedRole);
    } catch (error) {
      console.error("Error demoting user:", error);
      return res.status(500).json({ message: "Failed to demote user" });
    }
  });

  // ==========================================
  // END SUPER_ADMIN ONLY ROUTES
  // ==========================================

  app.post("/api/admin/driver/:driverId/status", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { driverId } = req.params;
      const { status } = req.body;

      if (!["pending", "approved", "suspended"].includes(status)) {
        return res.status(400).json({ message: "Invalid status" });
      }

      const driver = await storage.updateDriverStatus(driverId, status);
      if (!driver) {
        return res.status(404).json({ message: "Driver not found" });
      }

      if (status === "approved") {
        await storage.createNotification({
          userId: driverId,
          role: "driver",
          title: "Account Approved",
          message: "Congratulations! Your driver account has been approved. You can now go online and accept rides.",
          type: "success",
        });
        try {
          await storage.createDriverInboxMessage({
            userId: driverId,
            title: "Account Approved",
            body: "Your driver account has been approved. You can now go online and start accepting rides.",
            type: "approval_update",
          });
        } catch (e) { console.warn("[INBOX] Failed to send driver approval message:", e); }
      } else if (status === "suspended") {
        await storage.createNotification({
          userId: driverId,
          role: "driver",
          title: "Account Suspended",
          message: "Your driver account has been suspended. Please contact support for more information.",
          type: "warning",
        });
      }

      return res.json(driver);
    } catch (error) {
      console.error("Error updating driver status:", error);
      return res.status(500).json({ message: "Failed to update driver status" });
    }
  });

  // Approval Queue Endpoints
  app.get("/api/admin/approvals", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { type, status } = req.query;
      
      if (type === "driver") {
        const drivers = await storage.getAllDriversWithDetails();
        const filtered = (status && status !== "all") ? drivers.filter((d: any) => d.status === status) : drivers;
        return res.json(filtered);
      }
      
      return res.json([]);
    } catch (error) {
      console.error("Error fetching approvals:", error);
      return res.status(500).json({ message: "Failed to fetch approvals" });
    }
  });

  app.post("/api/admin/approvals/approve", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { type, id } = req.body;
      
      if (!type || !id) {
        return res.status(400).json({ message: "Type and ID are required" });
      }
      
      if (type === "driver") {
        const driver = await storage.updateDriverStatus(id, "approved");
        if (!driver) {
          return res.status(404).json({ message: "Driver not found" });
        }
        
        await storage.createNotification({
          userId: id,
          role: "driver",
          title: "Account Approved",
          message: "Congratulations! Your driver account has been approved. You can now go online and accept rides.",
          type: "success",
        });
        try {
          await storage.createDriverInboxMessage({
            userId: id,
            title: "Account Approved",
            body: "Your driver account has been approved. You can now go online and start accepting rides.",
            type: "approval_update",
          });
        } catch (e) { console.warn("[INBOX] Failed to send driver approval message:", e); }
        
        return res.json({ success: true, driver });
      }
      
      return res.status(400).json({ message: "Invalid type" });
    } catch (error) {
      console.error("Error approving:", error);
      return res.status(500).json({ message: "Failed to approve" });
    }
  });

  app.post("/api/admin/approvals/reject", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { type, id, reason } = req.body;
      
      if (!type || !id) {
        return res.status(400).json({ message: "Type and ID are required" });
      }
      
      if (type === "driver") {
        const driver = await storage.updateDriverStatus(id, "suspended");
        if (!driver) {
          return res.status(404).json({ message: "Driver not found" });
        }
        
        await storage.createNotification({
          userId: id,
          role: "driver",
          title: "Application Rejected",
          message: reason || "Your driver application has been rejected. Please contact support for more information.",
          type: "warning",
        });
        try {
          await storage.createDriverInboxMessage({
            userId: id,
            title: "Application Update",
            body: reason || "Your driver application was not approved at this time. Please contact support for details.",
            type: "approval_update",
          });
        } catch (e) { console.warn("[INBOX] Failed to send driver rejection message:", e); }
        
        return res.json({ success: true, driver });
      }
      
      return res.status(400).json({ message: "Invalid type" });
    } catch (error) {
      console.error("Error rejecting:", error);
      return res.status(500).json({ message: "Failed to reject" });
    }
  });

  // PHASE 1: Specific driver approval endpoints
  app.get("/api/admin/approvals/drivers", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const status = (req.query.status as string) || "pending";
      const drivers = await storage.getDriversByStatus(status);
      return res.json(drivers);
    } catch (error) {
      console.error("Error fetching drivers by status:", error);
      return res.status(500).json({ message: "Failed to fetch drivers" });
    }
  });

  app.post("/api/admin/approvals/drivers/:id/approve", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const driverId = req.params.id;
      const driver = await storage.updateDriverStatus(driverId, "approved");
      if (!driver) {
        return res.status(404).json({ message: "Driver not found" });
      }
      
      await storage.createNotification({
        userId: driverId,
        role: "driver",
        title: "Account Approved",
        message: "Congratulations! Your driver account has been approved. You can now go online and accept rides.",
        type: "success",
      });
      try {
        await storage.createDriverInboxMessage({
          userId: driverId,
          title: "Account Approved",
          body: "Your driver account has been approved. You can now go online and start accepting rides.",
          type: "approval_update",
        });
      } catch (e) { console.warn("[INBOX] Failed to send driver approval message:", e); }
      
      return res.json({ success: true, driver });
    } catch (error) {
      console.error("Error approving driver:", error);
      return res.status(500).json({ message: "Failed to approve driver" });
    }
  });

  app.post("/api/admin/approvals/drivers/:id/reject", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const driverId = req.params.id;
      const { reason } = req.body;
      const driver = await storage.updateDriverStatus(driverId, "rejected");
      if (!driver) {
        return res.status(404).json({ message: "Driver not found" });
      }
      
      await storage.createNotification({
        userId: driverId,
        role: "driver",
        title: "Application Update",
        message: reason || "Your driver application was not approved at this time. Please contact support for more details.",
        type: "warning",
      });
      try {
        await storage.createDriverInboxMessage({
          userId: driverId,
          title: "Application Update",
          body: reason || "Your driver application was not approved at this time. Please contact support for details.",
          type: "approval_update",
        });
      } catch (e) { console.warn("[INBOX] Failed to send driver rejection message:", e); }
      
      return res.json({ success: true, driver });
    } catch (error) {
      console.error("Error rejecting driver:", error);
      return res.status(500).json({ message: "Failed to reject driver" });
    }
  });

  app.get("/api/admin/riders", isAuthenticated, requireRole(["admin", "director"]), async (req: any, res) => {
    try {
      const riders = await storage.getAllRidersWithDetails();
      return res.json(riders);
    } catch (error) {
      console.error("Error getting riders:", error);
      return res.status(500).json({ message: "Failed to get riders" });
    }
  });

  app.post("/api/admin/trip/:tripId/cancel", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const { tripId } = req.params;
      const { reason } = req.body || {};

      const trip = await storage.adminCancelTrip(tripId, reason);
      if (!trip) {
        return res.status(404).json({ message: "Trip not found or already completed/cancelled" });
      }

      return res.json(trip);
    } catch (error) {
      console.error("Error cancelling trip:", error);
      return res.status(500).json({ message: "Failed to cancel trip" });
    }
  });

  app.get("/api/admin/payouts", isAuthenticated, requireRole(["admin", "director"]), async (req: any, res) => {
    try {
      const payouts = await storage.getAllPayoutTransactions();
      return res.json(payouts);
    } catch (error) {
      console.error("Error getting payouts:", error);
      return res.status(500).json({ message: "Failed to get payouts" });
    }
  });

  app.get("/api/admin/payouts/pending", isAuthenticated, requireRole(["admin", "director"]), async (req: any, res) => {
    try {
      const payouts = await storage.getPendingPayouts();
      return res.json(payouts);
    } catch (error) {
      console.error("Error getting pending payouts:", error);
      return res.status(500).json({ message: "Failed to get pending payouts" });
    }
  });

  app.post("/api/admin/payout/:transactionId/mark-paid", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const { transactionId } = req.params;
      const adminId = req.user?.id;

      const payout = await storage.markPayoutAsPaid(transactionId, adminId);
      if (!payout) {
        return res.status(404).json({ message: "Payout not found or already paid" });
      }

      await storage.createNotification({
        userId: payout.driverId,
        role: "driver",
        title: "Payout Processed",
        message: `Your payout of ${(parseFloat(String(payout.amount)) / 100).toFixed(2)} has been marked as paid.`,
        type: "success",
      });

      return res.json(payout);
    } catch (error) {
      console.error("Error marking payout as paid:", error);
      return res.status(500).json({ message: "Failed to mark payout as paid" });
    }
  });

  app.get("/api/admin/directors", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const allDirectorProfiles = await db.select().from(directorProfiles);
      const directorsWithDetails = await Promise.all(
        allDirectorProfiles.map(async (profile) => {
          const [user] = await db.select().from(users).where(eq(users.id, profile.userId));
          const [driverCountResult] = await db.select({ count: count() }).from(directorDriverAssignments).where(eq(directorDriverAssignments.directorUserId, profile.userId));
          let referralCode = null;
          if (profile.referralCodeId) {
            const [rc] = await db.select().from(referralCodes).where(eq(referralCodes.id, profile.referralCodeId));
            referralCode = rc?.code || null;
          }
          return {
            id: profile.userId,
            email: user?.email || profile.email,
            firstName: user?.firstName,
            lastName: user?.lastName,
            fullName: profile.fullName || (user?.firstName ? `${user.firstName} ${user.lastName || ''}`.trim() : user?.email),
            status: profile.status,
            directorType: profile.directorType,
            referralCodeId: profile.referralCodeId,
            referralCode,
            lifecycleStatus: profile.lifecycleStatus,
            lifespanStartDate: profile.lifespanStartDate,
            lifespanEndDate: profile.lifespanEndDate,
            maxCells: profile.maxCells,
            maxCellSize: profile.maxCellSize,
            commissionRatePercent: profile.commissionRatePercent,
            maxCommissionablePerDay: profile.maxCommissionablePerDay,
            approvedBy: profile.approvedBy,
            driverCount: driverCountResult?.count || 0,
            createdAt: profile.createdAt,
          };
        })
      );
      return res.json(directorsWithDetails);
    } catch (error) {
      console.error("Error getting directors:", error);
      return res.status(500).json({ message: "Failed to get directors" });
    }
  });

  app.get("/api/admin/directors/available-users", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const search = (req.query.search as string) || "";

      const existingDirectors = await db.select({ userId: directorProfiles.userId }).from(directorProfiles);
      const directorIds = new Set(existingDirectors.map(d => d.userId));

      let allUsers = await db.select({
        id: users.id,
        email: users.email,
        firstName: users.firstName,
        lastName: users.lastName,
      }).from(users).limit(50);

      let availableUsers = allUsers.filter(u => !directorIds.has(u.id));

      if (search) {
        const searchLower = search.toLowerCase();
        availableUsers = availableUsers.filter(u =>
          u.email?.toLowerCase().includes(searchLower) ||
          u.firstName?.toLowerCase().includes(searchLower) ||
          u.lastName?.toLowerCase().includes(searchLower)
        );
      }

      res.json(availableUsers.slice(0, 20));
    } catch (error) {
      console.error("Available users error:", error);
      res.status(500).json({ error: "Failed to load available users" });
    }
  });

  app.post("/api/admin/directors/appoint", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user?.claims?.sub;
      const {
        userId,
        directorType,
        startDate,
        endDate,
        maxCells,
        maxCellSize,
        commissionRatePercent,
        maxCommissionablePerDay,
      } = req.body;

      if (!userId || !directorType) {
        return res.status(400).json({ error: "userId and directorType are required" });
      }

      if (!["contract", "employed"].includes(directorType)) {
        return res.status(400).json({ error: "directorType must be 'contract' or 'employed'" });
      }

      const [targetUser] = await db.select().from(users).where(eq(users.id, userId));
      if (!targetUser) return res.status(404).json({ error: "User not found" });

      const [existing] = await db.select().from(directorProfiles)
        .where(eq(directorProfiles.userId, userId));
      if (existing) return res.status(409).json({ error: "User is already a director" });

      const hasDirectorRole = await storage.hasRole(userId, "director");
      if (!hasDirectorRole) {
        await storage.addRoleToUser(userId, "director");
      }

      let referralCodeId = null;
      if (directorType === "contract") {
        const code = "DIR-" + Math.random().toString(36).substring(2, 8).toUpperCase();
        const [refCode] = await db.insert(referralCodes).values({
          code,
          ownerUserId: userId,
          ownerRole: "director",
          active: true,
        }).returning();
        referralCodeId = refCode.id;
      }

      const [newDirector] = await db.insert(directorProfiles).values({
        userId,
        fullName: targetUser.firstName && targetUser.lastName
          ? `${targetUser.firstName} ${targetUser.lastName}`
          : targetUser.email || "Director",
        email: targetUser.email,
        directorType: directorType as "contract" | "employed",
        referralCodeId,
        lifecycleStatus: "pending",
        status: "active",
        lifespanStartDate: startDate ? new Date(startDate) : new Date(),
        lifespanEndDate: endDate ? new Date(endDate) : null,
        lifespanSetBy: adminUserId,
        maxCells: maxCells || 3,
        maxCellSize: maxCellSize || 1300,
        commissionRatePercent: commissionRatePercent || 12,
        maxCommissionablePerDay: maxCommissionablePerDay || 1000,
        createdBy: adminUserId,
        lastModifiedBy: adminUserId,
        lastModifiedAt: new Date(),
        onboardingCompleted: false,
      }).returning();

      await db.insert(directorActionLogs).values({
        actorId: adminUserId,
        actorRole: "super_admin",
        action: "appoint_director",
        targetType: "director",
        targetId: userId,
        beforeState: null,
        afterState: JSON.stringify({
          directorType,
          lifecycleStatus: "pending",
          maxCells: maxCells || 3,
          commissionRatePercent: commissionRatePercent || 12,
        }),
        metadata: JSON.stringify({ referralCodeId }),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });

      await storage.createNotification({
        userId,
        role: "director",
        type: "info",
        title: "Director Appointment",
        message: `You have been appointed as a ${directorType} director. ${directorType === "contract" ? "Recruit at least 10 drivers to activate your appointment." : "Your appointment is pending admin activation."}`,
      });

      res.json({ success: true, director: newDirector });
    } catch (error: any) {
      console.error("Appoint director error:", error);
      res.status(500).json({ error: "Failed to appoint director" });
    }
  });

  // =============================================
  // DIRECTOR COMMISSION & CELL MANAGEMENT
  // =============================================

  app.get("/api/director/dashboard", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getDirectorProfile(userId);
      if (!profile) {
        return res.status(404).json({ message: "Director profile not found" });
      }

      const metrics = await storage.getDirectorDailyMetrics(userId);
      const driverCount = await storage.getDriverCountUnderDirector(userId);
      const settings = await storage.getDirectorCommissionSettings();

      const isActivated = driverCount >= (profile.activationThreshold || 10);

      return res.json({
        directorType: profile.directorType,
        status: profile.status,
        commissionFrozen: profile.commissionFrozen,
        lifecycleStatus: profile.lifecycleStatus,
        onboardingCompleted: profile.onboardingCompleted,
        activationThreshold: profile.activationThreshold,
        isActivated,
        maxCellSize: profile.maxCellSize || settings?.maxCellSize || 1300,
        totalDrivers: metrics.totalDrivers,
        activeDriversToday: metrics.activeDriversToday,
        commissionableDrivers: metrics.commissionableDrivers,
        suspendedDrivers: metrics.suspendedDrivers,
      });
    } catch (error) {
      console.error("Error getting director dashboard:", error);
      return res.status(500).json({ message: "Failed to get director dashboard" });
    }
  });

  app.get("/api/director/ride-class-stats", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const { RIDE_CLASS_LIST } = await import("@shared/ride-classes");
      const stats = RIDE_CLASS_LIST.map(rc => {
        const driverCount = Math.floor(Math.random() * 13) + 2;
        const tripsToday = Math.floor(Math.random() * 45) + 5;
        const earningsToday = Math.floor(Math.random() * 14000) + 1000;
        return {
          classId: rc.id,
          className: rc.name,
          color: rc.color,
          driverCount,
          tripsToday,
          earningsToday,
        };
      });
      const totalEarnings = stats.reduce((sum, s) => sum + s.earningsToday, 0);
      const withPercentage = stats.map(s => ({
        ...s,
        percentage: totalEarnings > 0 ? Math.round((s.earningsToday / totalEarnings) * 100) : 0,
      }));
      return res.json({ stats: withPercentage, totalEarnings });
    } catch (error) {
      console.error("Error getting director ride class stats:", error);
      return res.status(500).json({ message: "Failed to get ride class stats" });
    }
  });

  app.get("/api/director/drivers", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const assignments = await storage.getDriversUnderDirector(userId);

      const driversWithDetails = await Promise.all(
        assignments.map(async (a) => {
          const driver = await storage.getDriverProfile(a.driverUserId);
          return {
            driverUserId: a.driverUserId,
            assignmentType: a.assignmentType,
            assignedAt: a.assignedAt,
            fullName: driver?.fullName || "Unknown",
            status: driver?.status || "unknown",
          };
        })
      );

      return res.json(driversWithDetails);
    } catch (error) {
      console.error("Error getting director drivers:", error);
      return res.status(500).json({ message: "Failed to get director drivers" });
    }
  });

  app.post("/api/director/drivers/:driverUserId/suspend", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const directorUserId = req.user.claims.sub;
      const { driverUserId } = req.params;
      const { reason } = req.body;

      const directorProfile = await storage.getDirectorProfile(directorUserId);
      if (!directorProfile || directorProfile.directorType !== "contract") {
        return res.status(403).json({ message: "Only contract directors can suspend drivers. Employed directors have read-only access." });
      }

      if (directorProfile.status !== "active") {
        return res.status(403).json({ message: "Your director account is not active" });
      }

      if (directorProfile.lifecycleStatus === "suspended" || directorProfile.lifecycleStatus === "terminated") {
        return res.status(403).json({ message: "Your director account is currently " + directorProfile.lifecycleStatus });
      }

      const assignment = await storage.getDirectorForDriver(driverUserId);
      if (!assignment || assignment.directorUserId !== directorUserId) {
        return res.status(403).json({ message: "This driver is not under your management" });
      }

      await storage.updateDriverStatus(driverUserId, "suspended");

      await storage.createAuditLog({
        action: "director_suspend_driver",
        entityType: "driver",
        entityId: driverUserId,
        performedByUserId: directorUserId,
        performedByRole: "director",
        metadata: JSON.stringify({ reason: reason || "Director action" }),
      });

      // Anti-retaliation detection: Check if this driver filed a dispute recently
      const recentDriverDisputes = await db.select().from(directorDisputes)
        .where(and(
          eq(directorDisputes.directorUserId, req.user.claims.sub),
          inArray(directorDisputes.status, ["submitted", "under_review", "clarification_requested", "resolved"]),
          gte(directorDisputes.createdAt, new Date(Date.now() - 14 * 24 * 60 * 60 * 1000))
        ));

      if (recentDriverDisputes.length > 0) {
        await db.insert(directorActionLogs).values({
          actorId: "system",
          actorRole: "system",
          action: "retaliation_flag",
          targetType: "director",
          targetId: req.user.claims.sub,
          afterState: JSON.stringify({
            suspendedDriverId: driverUserId,
            recentDisputeCount: recentDriverDisputes.length,
            warning: "Director suspended a driver while having active disputes. Possible retaliation."
          }),
        });

        const admins = await db.select().from(users);
        for (const admin of admins) {
          const roles = await storage.getUserRoles(admin.id);
          if (roles.includes("admin") || roles.includes("super_admin")) {
            await storage.createNotification({
              userId: admin.id,
              type: "warning",
              title: "Potential Retaliation Flag",
              message: `Director ${req.user.claims.sub} suspended a driver while having ${recentDriverDisputes.length} active dispute(s). Possible retaliation  review recommended.`,
            });
          }
        }
      }

      return res.json({ message: "Driver suspended" });
    } catch (error) {
      console.error("Error suspending driver:", error);
      return res.status(500).json({ message: "Failed to suspend driver" });
    }
  });

  app.post("/api/director/drivers/:driverUserId/activate", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const directorUserId = req.user.claims.sub;
      const { driverUserId } = req.params;

      const profile = await storage.getDirectorProfile(directorUserId);
      if (!profile || profile.directorType !== "contract") {
        return res.status(403).json({ message: "Only contract directors can activate drivers. Employed directors have read-only access." });
      }

      if (profile.status !== "active") {
        return res.status(403).json({ message: "Your director account is not active" });
      }

      if (profile.lifecycleStatus === "suspended" || profile.lifecycleStatus === "terminated") {
        return res.status(403).json({ message: "Your director account is currently " + profile.lifecycleStatus });
      }

      const assignment = await storage.getDirectorForDriver(driverUserId);
      if (!assignment || assignment.directorUserId !== directorUserId) {
        return res.status(403).json({ message: "This driver is not under your management" });
      }

      const maxCell = profile?.maxCellSize || 1300;
      const currentCount = await storage.getDriverCountUnderDirector(directorUserId);

      if (currentCount >= maxCell) {
        return res.status(400).json({ message: "Cell size limit reached" });
      }

      await storage.updateDriverStatus(driverUserId, "approved");

      await storage.createAuditLog({
        action: "director_activate_driver",
        entityType: "driver",
        entityId: driverUserId,
        performedByUserId: directorUserId,
        performedByRole: "director",
        metadata: JSON.stringify({}),
      });

      return res.json({ message: "Driver activated" });
    } catch (error) {
      console.error("Error activating driver:", error);
      return res.status(500).json({ message: "Failed to activate driver" });
    }
  });

  app.post("/api/director/drivers/:driverUserId/warn", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { driverUserId } = req.params;
      const { reason } = req.body;
      
      if (!reason || reason.trim().length < 5) {
        return res.status(400).json({ message: "Warning reason must be at least 5 characters" });
      }

      const profile = await storage.getDirectorProfile(userId);
      if (!profile) {
        return res.status(403).json({ message: "Director profile not found" });
      }

      const directorForDriver = await storage.getDirectorForDriver(driverUserId);
      if (!directorForDriver || directorForDriver.directorUserId !== userId) {
        return res.status(403).json({ message: "Driver not assigned to you" });
      }

      await storage.createNotification({
        userId: driverUserId,
        type: "warning",
        title: "Director Warning",
        message: reason.trim(),
        metadata: JSON.stringify({ issuedBy: userId, issuedByRole: "director" }),
      });

      await storage.createDirectorActionLog({
        actorId: userId,
        actorRole: "director",
        action: "issue_warning",
        targetType: "driver",
        targetId: driverUserId,
        beforeState: null,
        afterState: JSON.stringify({ reason: reason.trim() }),
        metadata: JSON.stringify({ ip: req.ip }),
      });

      return res.json({ message: "Warning issued to driver" });
    } catch (error) {
      console.error("Error issuing driver warning:", error);
      return res.status(500).json({ message: "Failed to issue warning" });
    }
  });

  app.get("/api/director/referral-code", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getDirectorProfile(userId);
      if (!profile) {
        return res.status(404).json({ message: "Director profile not found" });
      }
      const [referralCode] = await db.select().from(referralCodes).where(eq(referralCodes.ownerId, userId));
      if (!referralCode) {
        return res.json({ code: null });
      }
      return res.json({ code: referralCode.code, referralCodeId: referralCode.id });
    } catch (error) {
      console.error("Error fetching director referral code:", error);
      return res.status(500).json({ message: "Failed to fetch referral code" });
    }
  });

  app.post("/api/director/drivers/:driverUserId/recommend-termination", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { driverUserId } = req.params;
      const { reason } = req.body;

      if (!reason || reason.trim().length < 10) {
        return res.status(400).json({ message: "Reason must be at least 10 characters" });
      }

      const profile = await storage.getDirectorProfile(userId);
      if (!profile) {
        return res.status(403).json({ message: "Director profile not found" });
      }

      const directorForDriver = await storage.getDirectorForDriver(driverUserId);
      if (!directorForDriver || directorForDriver.directorUserId !== userId) {
        return res.status(403).json({ message: "Driver not assigned to you" });
      }

      await storage.createDirectorActionLog({
        actorId: userId,
        actorRole: "director",
        action: "recommend_termination",
        targetType: "driver",
        targetId: driverUserId,
        beforeState: null,
        afterState: JSON.stringify({ reason: reason.trim() }),
        metadata: JSON.stringify({ ip: req.ip }),
      });

      await storage.createNotification({
        userId: "admin",
        role: "admin",
        title: "Driver Termination Recommendation",
        message: `Director recommends termination of driver ${driverUserId}. Reason: ${reason.trim()}`,
        type: "warning",
      });

      return res.json({ success: true, message: "Termination recommendation submitted for admin review" });
    } catch (error) {
      console.error("Error recommending driver termination:", error);
      return res.status(500).json({ message: "Failed to submit termination recommendation" });
    }
  });

  app.get("/api/admin/director-settings", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      let settings = await storage.getDirectorCommissionSettings();
      if (!settings) {
        settings = await storage.upsertDirectorCommissionSettings({ updatedBy: "system" });
      }
      return res.json(settings);
    } catch (error) {
      console.error("Error getting director settings:", error);
      return res.status(500).json({ message: "Failed to get director settings" });
    }
  });

  app.post("/api/admin/director-settings", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { commissionRate, activeRatio, maxCommissionableDrivers, maxCellSize, reason } = req.body;

      if (!reason) {
        return res.status(400).json({ message: "Reason is required for settings changes" });
      }

      const oldSettings = await storage.getDirectorCommissionSettings();
      const updates: any = { updatedBy: adminUserId };

      if (commissionRate !== undefined) {
        await storage.logDirectorSettingsChange({
          settingKey: "commission_rate",
          oldValue: oldSettings?.commissionRate || "0.12",
          newValue: String(commissionRate),
          changedBy: adminUserId,
          reason,
        });
        updates.commissionRate = String(commissionRate);
      }
      if (activeRatio !== undefined) {
        await storage.logDirectorSettingsChange({
          settingKey: "active_ratio",
          oldValue: oldSettings?.activeRatio || "0.77",
          newValue: String(activeRatio),
          changedBy: adminUserId,
          reason,
        });
        updates.activeRatio = String(activeRatio);
      }
      if (maxCommissionableDrivers !== undefined) {
        await storage.logDirectorSettingsChange({
          settingKey: "max_commissionable_drivers",
          oldValue: String(oldSettings?.maxCommissionableDrivers || 1000),
          newValue: String(maxCommissionableDrivers),
          changedBy: adminUserId,
          reason,
        });
        updates.maxCommissionableDrivers = maxCommissionableDrivers;
      }
      if (maxCellSize !== undefined) {
        await storage.logDirectorSettingsChange({
          settingKey: "max_cell_size",
          oldValue: String(oldSettings?.maxCellSize || 1300),
          newValue: String(maxCellSize),
          changedBy: adminUserId,
          reason,
        });
        updates.maxCellSize = maxCellSize;
      }

      const updated = await storage.upsertDirectorCommissionSettings(updates);
      return res.json(updated);
    } catch (error) {
      console.error("Error updating director settings:", error);
      return res.status(500).json({ message: "Failed to update director settings" });
    }
  });

  app.get("/api/admin/director-settings/audit", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const logs = await storage.getDirectorSettingsAuditLogs();
      return res.json(logs);
    } catch (error) {
      console.error("Error getting audit logs:", error);
      return res.status(500).json({ message: "Failed to get audit logs" });
    }
  });

  app.post("/api/admin/directors/:directorUserId/activate", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user?.claims?.sub;
      const { directorUserId } = req.params;
      const { reason } = req.body;

      const [director] = await db.select().from(directorProfiles)
        .where(eq(directorProfiles.userId, directorUserId));
      if (!director) return res.status(404).json({ error: "Director not found" });

      if (director.lifecycleStatus === "active") {
        return res.status(400).json({ error: "Director is already active" });
      }

      if (director.directorType === "contract") {
        const assignments = await db.select().from(directorDriverAssignments)
          .where(eq(directorDriverAssignments.directorUserId, directorUserId));
        if (assignments.length < (director.activationThreshold || 10)) {
          return res.status(400).json({
            error: `Contract director needs at least ${director.activationThreshold || 10} recruited drivers to activate. Currently has ${assignments.length}.`,
          });
        }
      }

      const beforeState = { lifecycleStatus: director.lifecycleStatus, status: director.status };

      await db.update(directorProfiles).set({
        lifecycleStatus: "active",
        status: "active",
        approvedBy: adminUserId,
        lastModifiedBy: adminUserId,
        lastModifiedAt: new Date(),
      }).where(eq(directorProfiles.userId, directorUserId));

      await db.insert(directorActionLogs).values({
        actorId: adminUserId,
        actorRole: "super_admin",
        action: "activate_director",
        targetType: "director",
        targetId: directorUserId,
        beforeState: JSON.stringify(beforeState),
        afterState: JSON.stringify({ lifecycleStatus: "active", status: "active" }),
        metadata: JSON.stringify({ reason: reason || "Activation approved" }),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });

      await storage.createNotification({
        userId: directorUserId,
        role: "director",
        type: "info",
        title: "Director Activated",
        message: "Your director appointment has been activated.",
      });

      res.json({ success: true });
    } catch (error) {
      console.error("Activate director error:", error);
      res.status(500).json({ error: "Failed to activate director" });
    }
  });

  app.post("/api/admin/directors/:directorUserId/adjust-commission", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user?.claims?.sub;
      const { directorUserId } = req.params;
      const { commissionRatePercent, reason } = req.body;

      if (commissionRatePercent == null || !reason) {
        return res.status(400).json({ error: "commissionRatePercent and reason are required" });
      }

      if (commissionRatePercent < 0 || commissionRatePercent > 50) {
        return res.status(400).json({ error: "Commission rate must be between 0 and 50" });
      }

      const [director] = await db.select().from(directorProfiles)
        .where(eq(directorProfiles.userId, directorUserId));
      if (!director) return res.status(404).json({ error: "Director not found" });

      const beforeState = { commissionRatePercent: director.commissionRatePercent };

      await db.update(directorProfiles).set({
        commissionRatePercent,
        lastModifiedBy: adminUserId,
        lastModifiedAt: new Date(),
      }).where(eq(directorProfiles.userId, directorUserId));

      await db.insert(directorActionLogs).values({
        actorId: adminUserId,
        actorRole: "super_admin",
        action: "adjust_commission_rate",
        targetType: "director",
        targetId: directorUserId,
        beforeState: JSON.stringify(beforeState),
        afterState: JSON.stringify({ commissionRatePercent }),
        metadata: JSON.stringify({ reason }),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });

      res.json({ success: true });
    } catch (error) {
      console.error("Adjust commission error:", error);
      res.status(500).json({ error: "Failed to adjust commission rate" });
    }
  });

  app.post("/api/admin/directors/:directorUserId/adjust-cells", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user?.claims?.sub;
      const { directorUserId } = req.params;
      const { maxCells, maxCellSize, maxCommissionablePerDay, reason } = req.body;

      if (!reason) return res.status(400).json({ error: "Reason is required" });

      const [director] = await db.select().from(directorProfiles)
        .where(eq(directorProfiles.userId, directorUserId));
      if (!director) return res.status(404).json({ error: "Director not found" });

      const updates: any = {
        lastModifiedBy: adminUserId,
        lastModifiedAt: new Date(),
      };
      const beforeState: any = {};

      if (maxCells != null) {
        if (maxCells < 1 || maxCells > 3) return res.status(400).json({ error: "maxCells must be 1-3" });
        beforeState.maxCells = director.maxCells;
        updates.maxCells = maxCells;
      }
      if (maxCellSize != null) {
        if (maxCellSize < 100 || maxCellSize > 2000) return res.status(400).json({ error: "maxCellSize must be 100-2000" });
        beforeState.maxCellSize = director.maxCellSize;
        updates.maxCellSize = maxCellSize;
      }
      if (maxCommissionablePerDay != null) {
        if (maxCommissionablePerDay < 100 || maxCommissionablePerDay > 2000) return res.status(400).json({ error: "maxCommissionablePerDay must be 100-2000" });
        beforeState.maxCommissionablePerDay = director.maxCommissionablePerDay;
        updates.maxCommissionablePerDay = maxCommissionablePerDay;
      }

      await db.update(directorProfiles).set(updates)
        .where(eq(directorProfiles.userId, directorUserId));

      await db.insert(directorActionLogs).values({
        actorId: adminUserId,
        actorRole: "super_admin",
        action: "adjust_cell_limits",
        targetType: "director",
        targetId: directorUserId,
        beforeState: JSON.stringify(beforeState),
        afterState: JSON.stringify(updates),
        metadata: JSON.stringify({ reason }),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });

      res.json({ success: true });
    } catch (error) {
      console.error("Adjust cells error:", error);
      res.status(500).json({ error: "Failed to adjust cell limits" });
    }
  });

  app.post("/api/admin/directors/:directorUserId/freeze", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { directorUserId } = req.params;
      const { frozen, reason } = req.body;

      if (!reason) {
        return res.status(400).json({ message: "Reason required" });
      }

      await storage.updateDirectorProfile(directorUserId, { commissionFrozen: frozen });

      await storage.logDirectorSettingsChange({
        settingKey: `director_${directorUserId}_commission_frozen`,
        oldValue: String(!frozen),
        newValue: String(frozen),
        changedBy: adminUserId,
        reason,
      });

      await storage.createAuditLog({
        action: frozen ? "freeze_director_commission" : "resume_director_commission",
        entityType: "director",
        entityId: directorUserId,
        performedByUserId: adminUserId,
        performedByRole: "super_admin",
        metadata: JSON.stringify({ reason }),
      });

      return res.json({ message: frozen ? "Director commissions frozen" : "Director commissions resumed" });
    } catch (error) {
      console.error("Error freezing director:", error);
      return res.status(500).json({ message: "Failed to update director" });
    }
  });

  app.post("/api/admin/directors/:directorUserId/suspend", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { directorUserId } = req.params;
      const { reason } = req.body;

      if (!reason) {
        return res.status(400).json({ message: "Reason required" });
      }

      const profile = await storage.getDirectorProfile(directorUserId);
      const beforeState = { status: profile?.status, lifecycleStatus: profile?.lifecycleStatus };

      await storage.updateDirectorProfile(directorUserId, {
        status: "inactive",
        lifecycleStatus: "suspended",
        commissionFrozen: true,
        suspendedAt: new Date(),
        suspendedBy: adminUserId,
        lastModifiedBy: adminUserId,
        lastModifiedAt: new Date(),
      });

      await storage.logDirectorSettingsChange({
        settingKey: `director_${directorUserId}_status`,
        oldValue: "active",
        newValue: "inactive",
        changedBy: adminUserId,
        reason,
      });

      await storage.createAuditLog({
        action: "suspend_director",
        entityType: "director",
        entityId: directorUserId,
        performedByUserId: adminUserId,
        performedByRole: "admin",
        metadata: JSON.stringify({ reason }),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });

      await db.insert(directorActionLogs).values({
        actorId: adminUserId,
        actorRole: "admin",
        action: "suspend_director",
        targetType: "director",
        targetId: directorUserId,
        beforeState: JSON.stringify(beforeState),
        afterState: JSON.stringify({ status: "inactive", lifecycleStatus: "suspended", commissionFrozen: true }),
        metadata: JSON.stringify({ reason }),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });

      const driversUnderDirector = await storage.getDriversUnderDirector(directorUserId);
      for (const assignment of driversUnderDirector) {
        await storage.createNotification({
          userId: assignment.driverUserId,
          type: "info",
          title: "Director Assignment Updated",
          message: "Your Director assignment has been updated. Your driver status and earnings are unaffected.",
        });
      }

      return res.json({ message: "Director suspended", driversNotified: driversUnderDirector.length });
    } catch (error) {
      console.error("Error suspending director:", error);
      return res.status(500).json({ message: "Failed to suspend director" });
    }
  });

  app.post("/api/admin/directors/:directorUserId/reactivate", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { directorUserId } = req.params;

      const profile = await storage.getDirectorProfile(directorUserId);
      const beforeState = { status: profile?.status, lifecycleStatus: profile?.lifecycleStatus, suspendedAt: profile?.suspendedAt, suspendedBy: profile?.suspendedBy };

      await storage.updateDirectorProfile(directorUserId, {
        status: "active",
        suspendedAt: null,
        suspendedBy: null,
        lastModifiedBy: adminUserId,
        lastModifiedAt: new Date(),
      });

      await storage.createAuditLog({
        action: "reactivate_director",
        entityType: "director",
        entityId: directorUserId,
        performedByUserId: adminUserId,
        performedByRole: "admin",
        metadata: JSON.stringify({}),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });

      await db.insert(directorActionLogs).values({
        actorId: adminUserId,
        actorRole: "admin",
        action: "reactivate_director",
        targetType: "director",
        targetId: directorUserId,
        beforeState: JSON.stringify(beforeState),
        afterState: JSON.stringify({ status: "active", suspendedAt: null, suspendedBy: null }),
        metadata: JSON.stringify({}),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });

      return res.json({ message: "Director reactivated" });
    } catch (error) {
      console.error("Error reactivating director:", error);
      return res.status(500).json({ message: "Failed to reactivate director" });
    }
  });

  app.post("/api/admin/directors/:directorUserId/terminate", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user?.claims?.sub;
      const { directorUserId } = req.params;
      const { reason } = req.body;

      if (!reason) return res.status(400).json({ error: "Termination reason is required" });

      const [director] = await db.select().from(directorProfiles)
        .where(eq(directorProfiles.userId, directorUserId));
      if (!director) return res.status(404).json({ error: "Director not found" });

      if (director.lifecycleStatus === "terminated") {
        return res.status(400).json({ error: "Director is already terminated" });
      }

      const beforeState = { lifecycleStatus: director.lifecycleStatus, status: director.status };

      await db.update(directorProfiles).set({
        lifecycleStatus: "terminated",
        status: "inactive",
        terminatedAt: new Date(),
        terminatedBy: adminUserId,
        terminationReason: reason,
        commissionFrozen: true,
        lastModifiedBy: adminUserId,
        lastModifiedAt: new Date(),
      }).where(eq(directorProfiles.userId, directorUserId));

      await db.insert(directorActionLogs).values({
        actorId: adminUserId,
        actorRole: "super_admin",
        action: "terminate_director",
        targetType: "director",
        targetId: directorUserId,
        beforeState: JSON.stringify(beforeState),
        afterState: JSON.stringify({ lifecycleStatus: "terminated", status: "inactive" }),
        metadata: JSON.stringify({ reason }),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });

      await storage.createNotification({
        userId: directorUserId,
        role: "director",
        type: "warning",
        title: "Director Appointment Terminated",
        message: "Your director appointment has been terminated. Contact support for more information.",
      });

      const driversUnderDirector = await storage.getDriversUnderDirector(directorUserId);
      let driversUnassigned = 0;
      for (const assignment of driversUnderDirector) {
        try {
          await storage.createNotification({
            userId: assignment.driverUserId,
            type: "info",
            title: "Director Assignment Updated",
            message: "Your Director assignment has been updated. Your driver status and earnings are unaffected.",
          });

          await storage.removeDriverFromDirector(assignment.driverUserId);

          await db.insert(directorActionLogs).values({
            actorId: adminUserId,
            actorRole: "super_admin",
            action: "unassign_driver_on_termination",
            targetType: "driver",
            targetId: assignment.driverUserId,
            metadata: JSON.stringify({ directorUserId, reason: "Director terminated" }),
          });

          driversUnassigned++;
        } catch (driverErr) {
          console.error(`Error unassigning driver ${assignment.driverUserId}:`, driverErr);
        }
      }

      res.json({ success: true, driversUnassigned });
    } catch (error) {
      console.error("Error terminating director:", error);
      res.status(500).json({ error: "Failed to terminate director" });
    }
  });

  app.post("/api/admin/drivers/:driverUserId/reassign", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { driverUserId } = req.params;
      const { newDirectorUserId } = req.body;

      if (!newDirectorUserId) {
        return res.status(400).json({ message: "New director user ID required" });
      }

      const newDirectorProfile = await storage.getDirectorProfile(newDirectorUserId);
      const maxCell = newDirectorProfile?.maxCellSize || 1300;
      const currentCount = await storage.getDriverCountUnderDirector(newDirectorUserId);

      if (currentCount >= maxCell) {
        return res.status(400).json({ message: "Target director's cell is at capacity" });
      }

      await storage.removeDriverFromDirector(driverUserId);
      await storage.assignDriverToDirector(newDirectorUserId, driverUserId, "admin_assigned", adminUserId);

      await storage.createAuditLog({
        action: "reassign_driver",
        entityType: "driver",
        entityId: driverUserId,
        performedByUserId: adminUserId,
        performedByRole: "admin",
        metadata: JSON.stringify({ newDirectorUserId }),
      });

      return res.json({ message: "Driver reassigned" });
    } catch (error) {
      console.error("Error reassigning driver:", error);
      return res.status(500).json({ message: "Failed to reassign driver" });
    }
  });

  app.post("/api/admin/directors/:directorUserId/assign-driver", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { directorUserId } = req.params;
      const { driverUserId } = req.body;

      if (!driverUserId) {
        return res.status(400).json({ message: "Driver user ID required" });
      }

      const existing = await storage.getDirectorForDriver(driverUserId);
      if (existing) {
        return res.status(400).json({ message: "Driver already assigned to a director" });
      }

      const directorProfile = await storage.getDirectorProfile(directorUserId);
      const maxCell = directorProfile?.maxCellSize || 1300;
      const currentCount = await storage.getDriverCountUnderDirector(directorUserId);

      if (currentCount >= maxCell) {
        return res.status(400).json({ message: "Director's cell is at capacity" });
      }

      await storage.assignDriverToDirector(directorUserId, driverUserId, "admin_assigned", adminUserId);

      await storage.createAuditLog({
        action: "assign_driver_to_director",
        entityType: "driver",
        entityId: driverUserId,
        performedByUserId: adminUserId,
        performedByRole: "admin",
        metadata: JSON.stringify({ directorUserId }),
      });

      return res.json({ message: "Driver assigned to director" });
    } catch (error) {
      console.error("Error assigning driver:", error);
      return res.status(500).json({ message: "Failed to assign driver" });
    }
  });

  // =============================================
  // DIRECTOR LIFECYCLE & ONBOARDING (Phases 16-20)
  // =============================================

  app.post("/api/director/onboarding/complete", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getDirectorProfile(userId);
      if (!profile) {
        return res.status(404).json({ message: "Director profile not found" });
      }
      if (profile.onboardingCompleted) {
        return res.json({ message: "Onboarding already completed", profile });
      }
      const updated = await storage.completeDirectorOnboarding(userId);
      await storage.createAuditLog({
        action: "director_onboarding_completed",
        entityType: "director",
        entityId: userId,
        performedByUserId: userId,
        performedByRole: "director",
        metadata: JSON.stringify({ directorType: profile.directorType }),
      });
      return res.json({ message: "Onboarding completed", profile: updated });
    } catch (error) {
      console.error("Error completing director onboarding:", error);
      return res.status(500).json({ message: "Failed to complete onboarding" });
    }
  });

  app.get("/api/director/onboarding/status", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getDirectorProfile(userId);
      if (!profile) {
        return res.status(404).json({ message: "Director profile not found" });
      }
      return res.json({
        onboardingCompleted: profile.onboardingCompleted,
        trainingCompleted: profile.trainingCompleted,
        termsAccepted: profile.termsAccepted,
        lifecycleStatus: profile.lifecycleStatus,
        directorType: profile.directorType,
        referralCodeId: profile.referralCodeId,
      });
    } catch (error) {
      console.error("Error getting onboarding status:", error);
      return res.status(500).json({ message: "Failed to get onboarding status" });
    }
  });

  // ==========================================
  // DIRECTOR TRAINING MODULES
  // ==========================================

  const DIRECTOR_TRAINING_MODULES = [
    { key: "managing_drivers", title: "Managing Drivers Responsibly" },
    { key: "suspension_vs_escalation", title: "Suspension vs Escalation" },
    { key: "staff_management", title: "Staff Management Best Practices" },
    { key: "avoiding_abuse", title: "Avoiding Abuse & Retaliation" },
    { key: "understanding_trust", title: "Understanding Your Trust Score" },
    { key: "working_with_zibra", title: "Working with ZIBRA Insights" },
  ];

  app.get("/api/director/training", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const completedModules = await db.select().from(directorTrainingModules)
        .where(eq(directorTrainingModules.directorUserId, userId));
      const completedKeys = new Set(completedModules.filter(m => m.completedAt).map(m => m.moduleKey));
      const modules = DIRECTOR_TRAINING_MODULES.map(m => ({
        ...m,
        completed: completedKeys.has(m.key),
        completedAt: completedModules.find(cm => cm.moduleKey === m.key)?.completedAt || null,
      }));
      const allCompleted = modules.every(m => m.completed);
      return res.json({ modules, allCompleted, totalModules: modules.length, completedCount: modules.filter(m => m.completed).length });
    } catch (error) {
      console.error("Error getting training modules:", error);
      return res.status(500).json({ message: "Failed to get training modules" });
    }
  });

  app.post("/api/director/training/:moduleKey/complete", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { moduleKey } = req.params;

      const validModule = DIRECTOR_TRAINING_MODULES.find(m => m.key === moduleKey);
      if (!validModule) return res.status(400).json({ message: "Invalid module key" });

      const [existing] = await db.select().from(directorTrainingModules)
        .where(and(eq(directorTrainingModules.directorUserId, userId), eq(directorTrainingModules.moduleKey, moduleKey)));

      if (existing?.completedAt) return res.json({ message: "Already completed", module: existing });

      if (existing) {
        await db.update(directorTrainingModules).set({ completedAt: new Date() })
          .where(eq(directorTrainingModules.id, existing.id));
      } else {
        await db.insert(directorTrainingModules).values({
          directorUserId: userId,
          moduleKey,
          moduleTitle: validModule.title,
          completedAt: new Date(),
        });
      }

      await db.insert(directorActionLogs).values({
        actorId: userId,
        actorRole: "director",
        action: "training_module_completed",
        targetType: "training",
        targetId: moduleKey,
        afterState: JSON.stringify({ moduleKey, moduleTitle: validModule.title }),
      });

      const allCompleted = await db.select().from(directorTrainingModules)
        .where(and(eq(directorTrainingModules.directorUserId, userId), isNotNull(directorTrainingModules.completedAt)));

      if (allCompleted.length >= DIRECTOR_TRAINING_MODULES.length) {
        await db.update(directorProfiles).set({ trainingCompleted: true })
          .where(eq(directorProfiles.userId, userId));
        await db.insert(directorActionLogs).values({
          actorId: userId,
          actorRole: "director",
          action: "training_all_completed",
          targetType: "director",
          targetId: userId,
        });
      }

      return res.json({ message: "Module completed", moduleKey });
    } catch (error) {
      console.error("Error completing training module:", error);
      return res.status(500).json({ message: "Failed to complete training module" });
    }
  });

  // ==========================================
  // DIRECTOR TERMS ACCEPTANCE
  // ==========================================

  app.get("/api/director/terms", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const [acceptance] = await db.select().from(directorTermsAcceptance)
        .where(eq(directorTermsAcceptance.directorUserId, userId))
        .orderBy(desc(directorTermsAcceptance.acceptedAt))
        .limit(1);
      const profile = await storage.getDirectorProfile(userId);
      return res.json({
        accepted: profile?.termsAccepted || false,
        acceptedAt: acceptance?.acceptedAt || null,
        termsVersion: acceptance?.termsVersion || "1.0",
        currentVersion: "1.0",
      });
    } catch (error) {
      console.error("Error getting director terms:", error);
      return res.status(500).json({ message: "Failed to get terms status" });
    }
  });

  app.post("/api/director/terms/accept", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getDirectorProfile(userId);
      if (!profile) return res.status(404).json({ message: "Director profile not found" });
      if (profile.termsAccepted) return res.json({ message: "Terms already accepted" });

      await db.insert(directorTermsAcceptance).values({
        directorUserId: userId,
        termsVersion: "1.0",
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });

      await db.update(directorProfiles).set({
        termsAccepted: true,
        termsAcceptedAt: new Date(),
      }).where(eq(directorProfiles.userId, userId));

      await db.insert(directorActionLogs).values({
        actorId: userId,
        actorRole: "director",
        action: "terms_accepted",
        targetType: "director",
        targetId: userId,
        afterState: JSON.stringify({ termsVersion: "1.0" }),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });

      return res.json({ message: "Terms accepted successfully" });
    } catch (error) {
      console.error("Error accepting director terms:", error);
      return res.status(500).json({ message: "Failed to accept terms" });
    }
  });

  // ==========================================
  // DIRECTOR TRUST SCORE (ADMIN ONLY VIEW)
  // ==========================================

  app.get("/api/admin/directors/:directorUserId/trust-score", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { directorUserId } = req.params;
      const [score] = await db.select().from(directorTrustScores)
        .where(eq(directorTrustScores.directorUserId, directorUserId));

      if (!score) {
        return res.json({
          directorUserId,
          score: 100,
          riskLevel: "low",
          driverComplaints: 0,
          excessiveSuspensions: 0,
          staffAbuseFlags: 0,
          missedCompliance: 0,
          zibraAlerts: 0,
          adminWarnings: 0,
          lastCalculatedAt: null,
        });
      }
      return res.json(score);
    } catch (error) {
      console.error("Error getting trust score:", error);
      return res.status(500).json({ message: "Failed to get trust score" });
    }
  });

  app.post("/api/admin/directors/:directorUserId/trust-score/recalculate", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { directorUserId } = req.params;
      const adminUserId = req.user.claims.sub;

      const disputes = await db.select().from(directorDisputes)
        .where(eq(directorDisputes.directorUserId, directorUserId));
      const driverComplaints = disputes.filter(d => d.disputeType === "driver_complaint" || d.disputeType === "unfair_treatment").length;

      const actionLogs = await db.select().from(directorActionLogs)
        .where(eq(directorActionLogs.actorId, directorUserId));
      const suspensionActions = actionLogs.filter(l => l.action === "driver_suspended");
      const excessiveSuspensions = suspensionActions.length > 10 ? suspensionActions.length - 10 : 0;

      const retaliationFlags = actionLogs.filter(l => l.action === "retaliation_flag" && l.targetId === directorUserId);
      const staffAbuseFlags = retaliationFlags.length;

      const coachingLogs = await db.select().from(directorCoachingLogs)
        .where(eq(directorCoachingLogs.directorUserId, directorUserId));
      const zibraAlerts = coachingLogs.filter(l => l.severity === "critical" || l.severity === "warning").length;

      const adminWarningLogs = actionLogs.filter(l => l.action === "admin_warning" || l.action === "flag_for_review");
      const adminWarnings = adminWarningLogs.length;

      const missedCompliance = 0;

      let score = 100;
      score -= driverComplaints * 5;
      score -= excessiveSuspensions * 3;
      score -= staffAbuseFlags * 10;
      score -= missedCompliance * 4;
      score -= zibraAlerts * 2;
      score -= adminWarnings * 8;
      score = Math.max(0, Math.min(100, score));

      let riskLevel = "low";
      if (score < 40) riskLevel = "high";
      else if (score < 70) riskLevel = "medium";

      const [existing] = await db.select().from(directorTrustScores)
        .where(eq(directorTrustScores.directorUserId, directorUserId));

      if (existing) {
        await db.update(directorTrustScores).set({
          score, riskLevel, driverComplaints, excessiveSuspensions,
          staffAbuseFlags, missedCompliance, zibraAlerts, adminWarnings,
          lastCalculatedAt: new Date(),
        }).where(eq(directorTrustScores.directorUserId, directorUserId));
      } else {
        await db.insert(directorTrustScores).values({
          directorUserId, score, riskLevel, driverComplaints, excessiveSuspensions,
          staffAbuseFlags, missedCompliance, zibraAlerts, adminWarnings,
          lastCalculatedAt: new Date(),
        });
      }

      if (score < 40) {
        await db.insert(directorCoachingLogs).values({
          directorUserId,
          coachingType: "low_trust_warning",
          message: "Your operational patterns have been flagged for review. Focus on policy compliance and driver satisfaction to improve your standing.",
          severity: "critical",
        });
        await storage.createNotification({
          userId: directorUserId,
          type: "warning",
          title: "Operational Review Notice",
          message: "ZIBRA has flagged operational patterns for improvement. Check your coaching insights.",
        });
      }

      await db.insert(directorActionLogs).values({
        actorId: adminUserId,
        actorRole: "admin",
        action: "trust_score_recalculated",
        targetType: "director",
        targetId: directorUserId,
        afterState: JSON.stringify({ score, riskLevel, driverComplaints, excessiveSuspensions, staffAbuseFlags, missedCompliance, zibraAlerts, adminWarnings }),
      });

      return res.json({ score, riskLevel, driverComplaints, excessiveSuspensions, staffAbuseFlags, missedCompliance, zibraAlerts, adminWarnings });
    } catch (error) {
      console.error("Error recalculating trust score:", error);
      return res.status(500).json({ message: "Failed to recalculate trust score" });
    }
  });

  // Admin view training status
  app.get("/api/admin/directors/:directorUserId/training", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { directorUserId } = req.params;
      const completedModules = await db.select().from(directorTrainingModules)
        .where(eq(directorTrainingModules.directorUserId, directorUserId));
      const completedKeys = new Set(completedModules.filter(m => m.completedAt).map(m => m.moduleKey));
      const modules = DIRECTOR_TRAINING_MODULES.map(m => ({
        ...m,
        completed: completedKeys.has(m.key),
        completedAt: completedModules.find(cm => cm.moduleKey === m.key)?.completedAt || null,
      }));
      return res.json({ modules, allCompleted: modules.every(m => m.completed), completedCount: modules.filter(m => m.completed).length, totalModules: modules.length });
    } catch (error) {
      console.error("Error getting admin training:", error);
      return res.status(500).json({ message: "Failed to get training status" });
    }
  });

  app.post("/api/director/appeals", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { appealType, reason, explanation } = req.body;
      
      if (!appealType || !reason) {
        return res.status(400).json({ message: "Appeal type and reason are required" });
      }
      
      if (!["suspension", "termination"].includes(appealType)) {
        return res.status(400).json({ message: "Appeal type must be 'suspension' or 'termination'" });
      }

      const profile = await storage.getDirectorProfile(userId);
      if (!profile) {
        return res.status(404).json({ message: "Director profile not found" });
      }

      const validStatuses = appealType === "suspension" ? ["suspended"] : ["terminated"];
      if (!validStatuses.includes(profile.lifecycleStatus)) {
        return res.status(400).json({ message: `You can only submit a ${appealType} appeal when your status is ${validStatuses.join(" or ")}` });
      }

      const existingAppeals = await storage.getDirectorAppeals(userId);
      const pendingAppeal = existingAppeals.find(a => a.status === "pending" && a.appealType === appealType);
      if (pendingAppeal) {
        return res.status(400).json({ message: "You already have a pending appeal of this type" });
      }

      const appeal = await storage.createDirectorAppeal({
        directorUserId: userId,
        appealType,
        reason,
        explanation: explanation || null,
        status: "pending",
      });

      await storage.createAuditLog({
        action: "director_appeal_submitted",
        entityType: "director",
        entityId: userId,
        performedByUserId: userId,
        performedByRole: "director",
        metadata: JSON.stringify({ appealType, appealId: appeal.id }),
      });

      return res.json({ message: "Appeal submitted successfully", appeal });
    } catch (error) {
      console.error("Error submitting director appeal:", error);
      return res.status(500).json({ message: "Failed to submit appeal" });
    }
  });

  app.get("/api/director/appeals", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const appeals = await storage.getDirectorAppeals(userId);
      return res.json(appeals);
    } catch (error) {
      console.error("Error getting director appeals:", error);
      return res.status(500).json({ message: "Failed to get appeals" });
    }
  });

  app.get("/api/admin/director-appeals", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const appeals = await storage.getDirectorAppeals();
      return res.json(appeals);
    } catch (error) {
      console.error("Error getting all director appeals:", error);
      return res.status(500).json({ message: "Failed to get appeals" });
    }
  });

  app.post("/api/admin/director-appeals/:appealId/review", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { appealId } = req.params;
      const { status, reviewNotes } = req.body;

      if (!status || !["approved", "denied"].includes(status)) {
        return res.status(400).json({ message: "Status must be 'approved' or 'denied'" });
      }

      const appeal = await storage.getDirectorAppealById(appealId);
      if (!appeal) {
        return res.status(404).json({ message: "Appeal not found" });
      }

      if (appeal.status !== "pending") {
        return res.status(400).json({ message: "This appeal has already been reviewed" });
      }

      const updated = await storage.updateDirectorAppeal(appealId, {
        status,
        reviewedBy: adminUserId,
        reviewNotes: reviewNotes || undefined,
      });

      if (status === "approved") {
        await storage.updateDirectorLifecycleStatus(appeal.directorUserId, "active");
        await storage.updateDirectorProfile(appeal.directorUserId, {
          commissionFrozen: false,
          suspendedAt: null,
          suspendedBy: null,
        });
      }

      await storage.createAuditLog({
        action: `director_appeal_${status}`,
        entityType: "director",
        entityId: appeal.directorUserId,
        performedByUserId: adminUserId,
        performedByRole: "admin",
        metadata: JSON.stringify({ appealId, appealType: appeal.appealType, reviewNotes }),
      });

      await storage.createNotification({
        userId: appeal.directorUserId,
        type: "system",
        title: status === "approved" ? "Appeal Approved" : "Appeal Denied",
        message: status === "approved"
          ? "Your appeal has been reviewed and approved. Your director status has been restored."
          : "Your appeal has been reviewed. The decision has been upheld based on policy review.",
      });

      return res.json({ message: `Appeal ${status}`, appeal: updated });
    } catch (error) {
      console.error("Error reviewing director appeal:", error);
      return res.status(500).json({ message: "Failed to review appeal" });
    }
  });

  app.get("/api/admin/directors/:directorUserId/lifecycle", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { directorUserId } = req.params;

      const [director] = await db.select().from(directorProfiles)
        .where(eq(directorProfiles.userId, directorUserId));
      if (!director) return res.status(404).json({ error: "Director not found" });

      const [user] = await db.select().from(users).where(eq(users.id, directorUserId));

      const assignments = await db.select().from(directorDriverAssignments)
        .where(eq(directorDriverAssignments.directorUserId, directorUserId));

      const cells = await db.select().from(directorCells)
        .where(eq(directorCells.directorUserId, directorUserId));

      const logs = await db.select().from(directorActionLogs)
        .where(or(
          eq(directorActionLogs.targetId, directorUserId),
          eq(directorActionLogs.actorId, directorUserId)
        ))
        .orderBy(desc(directorActionLogs.createdAt))
        .limit(50);

      res.json({
        director: {
          ...director,
          email: user?.email,
          displayName: user?.firstName && user?.lastName ? `${user.firstName} ${user.lastName}` : director.fullName,
        },
        driverCount: assignments.length,
        cells,
        recentLogs: logs,
      });
    } catch (error) {
      console.error("Error loading director lifecycle:", error);
      res.status(500).json({ error: "Failed to load director lifecycle" });
    }
  });

  app.post("/api/admin/directors/:directorUserId/lifecycle", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { directorUserId } = req.params;
      const { status, reason } = req.body;

      if (!status || !["active", "suspended", "terminated"].includes(status)) {
        return res.status(400).json({ message: "Status must be 'active', 'suspended', or 'terminated'" });
      }
      if (!reason) {
        return res.status(400).json({ message: "Reason is required for lifecycle changes" });
      }

      const profile = await storage.getDirectorProfile(directorUserId);
      if (!profile) {
        return res.status(404).json({ message: "Director profile not found" });
      }

      const oldStatus = profile.lifecycleStatus;

      if (status === "terminated") {
        const reassignedCount = await storage.reassignAllDriversFromDirector(directorUserId);
        
        await storage.updateDirectorLifecycleStatus(directorUserId, "terminated", {
          terminatedBy: adminUserId,
          terminationReason: reason,
        });

        await storage.createNotification({
          userId: directorUserId,
          type: "system",
          title: "Director Role Update",
          message: "Your Director role has been ended based on review. Driver assignments have been updated.",
        });

        await storage.createAuditLog({
          action: "terminate_director",
          entityType: "director",
          entityId: directorUserId,
          performedByUserId: adminUserId,
          performedByRole: "admin",
          metadata: JSON.stringify({ reason, driversReassigned: reassignedCount, previousStatus: oldStatus }),
        });

        return res.json({ message: "Director terminated", driversReassigned: reassignedCount });
      }

      if (status === "suspended") {
        await storage.updateDirectorLifecycleStatus(directorUserId, "suspended", {
          suspendedBy: adminUserId,
        });

        await storage.createNotification({
          userId: directorUserId,
          type: "system",
          title: "Director Account Suspended",
          message: "Your director account has been suspended pending review. Commission calculations are paused. You may submit an appeal through your dashboard.",
        });
      } else if (status === "active") {
        await storage.updateDirectorLifecycleStatus(directorUserId, "active");
        await storage.updateDirectorProfile(directorUserId, {
          commissionFrozen: false,
          suspendedAt: null,
          suspendedBy: null,
        });
      }

      await storage.createAuditLog({
        action: `director_lifecycle_${status}`,
        entityType: "director",
        entityId: directorUserId,
        performedByUserId: adminUserId,
        performedByRole: "admin",
        metadata: JSON.stringify({ reason, previousStatus: oldStatus }),
      });

      return res.json({ message: `Director status updated to ${status}` });
    } catch (error) {
      console.error("Error updating director lifecycle:", error);
      return res.status(500).json({ message: "Failed to update director lifecycle" });
    }
  });

  // Admin Bank Account Management
  app.get("/api/admin/bank-accounts", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const bankAccounts = await storage.getAllDriverBankAccounts();
      
      // Enhance with driver info
      const enhanced = await Promise.all(bankAccounts.map(async (account) => {
        const drivers = await storage.getAllDrivers();
        const driver = drivers.find(d => d.id === account.driverId);
        return {
          ...account,
          driverName: driver?.fullName || "Unknown",
          driverUserId: driver?.userId,
          accountNumberMasked: `****${account.accountNumber.slice(-4)}`,
        };
      }));
      
      return res.json(enhanced);
    } catch (error) {
      console.error("Error getting bank accounts:", error);
      return res.status(500).json({ message: "Failed to get bank accounts" });
    }
  });

  app.post("/api/admin/bank-accounts/:driverId/verify", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { driverId } = req.params;
      const { verified } = req.body;
      
      const updated = await storage.verifyDriverBankAccount(
        driverId, 
        verified === true, 
        "manual", 
        adminUserId
      );
      
      if (!updated) {
        return res.status(404).json({ message: "Bank account not found" });
      }
      
      console.log(`[AUDIT] Bank account ${verified ? "verified" : "unverified"}: driverId=${driverId}, by=${adminUserId}`);
      return res.json(updated);
    } catch (error) {
      console.error("Error verifying bank account:", error);
      return res.status(500).json({ message: "Failed to verify bank account" });
    }
  });

  // Admin Withdrawal Management
  app.get("/api/admin/withdrawals", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const withdrawals = await storage.getPendingDriverWithdrawals();
      
      // Enhance with driver and bank account info
      const enhanced = await Promise.all(withdrawals.map(async (withdrawal) => {
        const drivers = await storage.getAllDrivers();
        const driver = drivers.find(d => d.id === withdrawal.driverId);
        const bankAccount = await storage.getDriverBankAccount(withdrawal.driverId);
        return {
          ...withdrawal,
          driverName: driver?.fullName || "Unknown",
          driverUserId: driver?.userId,
          bankDetails: bankAccount ? {
            bankName: bankAccount.bankName,
            accountNumber: `****${bankAccount.accountNumber.slice(-4)}`,
            accountName: bankAccount.accountName,
          } : null,
        };
      }));
      
      return res.json(enhanced);
    } catch (error) {
      console.error("Error getting withdrawals:", error);
      return res.status(500).json({ message: "Failed to get withdrawals" });
    }
  });

  app.post("/api/admin/withdrawals/:withdrawalId/approve", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { withdrawalId } = req.params;
      const { initiateTransfer } = req.body; // Optional: if true, initiate real transfer
      
      // Get withdrawal details
      const withdrawal = await storage.getDriverWithdrawalById(withdrawalId);
      if (!withdrawal) {
        return res.status(404).json({ message: "Withdrawal not found" });
      }
      
      if (withdrawal.status !== "pending") {
        return res.status(400).json({ message: "Withdrawal already processed" });
      }
      
      // Get driver profile to check if test driver
      const driverProfile = await storage.getDriverProfile(withdrawal.driverId);
      if (!driverProfile) {
        return res.status(404).json({ message: "Driver profile not found" });
      }
      
      // Get bank account for transfer
      const bankAccount = await storage.getDriverBankAccount(withdrawal.driverId);
      if (!bankAccount || !bankAccount.isVerified) {
        return res.status(400).json({ message: "Driver bank account not verified" });
      }
      
      // If initiateTransfer is true, use payout provider
      if (initiateTransfer && withdrawal.currencyCode === "NGN") {
        const provider = getPayoutProviderForCountry("NG");
        const reference = generatePayoutReference();
        
        console.log(`[PAYOUT] Initiating transfer via ${provider.name}: ${withdrawal.amount} NGN to ${bankAccount.accountNumber}`);
        
        const result = await provider.initiateTransfer({
          amountNGN: parseFloat(withdrawal.amount),
          bankCode: bankAccount.bankCode,
          accountNumber: bankAccount.accountNumber,
          accountName: bankAccount.accountName,
          reference: reference,
          narration: `ZIBA Driver Payout - ${withdrawal.id}`,
        });
        
        if (result.success) {
          const updated = await storage.updateDriverWithdrawal(withdrawalId, {
            status: "approved",
            payoutProvider: provider.name,
            payoutReference: reference,
            providerReference: result.providerReference,
            providerStatus: result.status,
            processedBy: adminUserId,
            processedAt: new Date(),
          });
          
          console.log(`[AUDIT] Withdrawal approved with transfer: id=${withdrawalId}, provider=${provider.name}, ref=${reference}, by=${adminUserId}`);
          return res.json({ message: "Withdrawal approved and transfer initiated", withdrawal: updated, transferResult: result });
        } else {
          // Transfer failed - update with error
          await storage.updateDriverWithdrawal(withdrawalId, {
            providerError: result.error,
            payoutProvider: provider.name,
          });
          
          console.error(`[PAYOUT] Transfer failed: ${result.error}`);
          return res.status(400).json({ message: "Transfer failed", error: result.error });
        }
      }
      
      // Standard approval without transfer initiation
      const updated = await storage.updateDriverWithdrawalStatus(
        withdrawalId,
        "approved",
        adminUserId
      );
      
      console.log(`[AUDIT] Withdrawal approved: id=${withdrawalId}, by=${adminUserId}`);
      return res.json({ message: "Withdrawal approved", withdrawal: updated });
    } catch (error) {
      console.error("Error approving withdrawal:", error);
      return res.status(500).json({ message: "Failed to approve withdrawal" });
    }
  });

  app.post("/api/admin/withdrawals/:withdrawalId/reject", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { withdrawalId } = req.params;
      const { reason } = req.body;
      
      const updated = await storage.updateDriverWithdrawalStatus(
        withdrawalId,
        "rejected",
        adminUserId,
        reason || "Rejected by admin"
      );
      
      if (!updated) {
        return res.status(404).json({ message: "Withdrawal not found" });
      }
      
      console.log(`[AUDIT] Withdrawal rejected: id=${withdrawalId}, by=${adminUserId}, reason=${reason}`);
      return res.json({ message: "Withdrawal rejected", withdrawal: updated });
    } catch (error) {
      console.error("Error rejecting withdrawal:", error);
      return res.status(500).json({ message: "Failed to reject withdrawal" });
    }
  });

  app.post("/api/admin/withdrawals/:withdrawalId/mark-paid", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { withdrawalId } = req.params;
      const { payoutReference } = req.body;
      
      // First approve if pending
      let withdrawal = await storage.updateDriverWithdrawalStatus(
        withdrawalId,
        "paid",
        adminUserId
      );
      
      if (!withdrawal) {
        return res.status(404).json({ message: "Withdrawal not found" });
      }
      
      console.log(`[AUDIT] Withdrawal marked as paid: id=${withdrawalId}, by=${adminUserId}, ref=${payoutReference || "N/A"}`);
      
      // TODO: Deduct from driver wallet when payment is confirmed
      // This would integrate with actual payment provider
      
      return res.json({ message: "Withdrawal marked as paid", withdrawal });
    } catch (error) {
      console.error("Error marking withdrawal as paid:", error);
      return res.status(500).json({ message: "Failed to mark withdrawal as paid" });
    }
  });

  // Paystack Webhook for transfer status updates
  app.post("/api/webhooks/paystack", async (req, res) => {
    try {
      const signature = req.headers["x-paystack-signature"] as string;
      const body = JSON.stringify(req.body);
      
      // Validate webhook signature
      if (!validatePaystackWebhook(body, signature)) {
        console.log("[WEBHOOK] Invalid Paystack signature");
        return res.status(401).json({ message: "Invalid signature" });
      }
      
      const event = req.body;
      console.log(`[WEBHOOK] Paystack event received: ${event.event}`);
      
      // Handle transfer events
      if (event.event === "transfer.success" || event.event === "transfer.failed" || event.event === "transfer.reversed") {
        const transferData = event.data;
        const reference = transferData.reference;
        
        // Find withdrawal by reference
        const withdrawal = await storage.getDriverWithdrawalByReference(reference);
        if (!withdrawal) {
          console.log(`[WEBHOOK] Withdrawal not found for reference: ${reference}`);
          return res.status(200).json({ message: "Webhook received" });
        }
        
        let newStatus: "paid" | "failed" | "processing" = "processing";
        let providerStatus = transferData.status;
        let providerError = transferData.reason || null;
        
        if (event.event === "transfer.success") {
          newStatus = "paid";
          console.log(`[WEBHOOK] Transfer successful: reference=${reference}, withdrawalId=${withdrawal.id}`);
        } else if (event.event === "transfer.failed" || event.event === "transfer.reversed") {
          newStatus = "failed";
          console.log(`[WEBHOOK] Transfer failed: reference=${reference}, reason=${providerError}`);
        }
        
        // Update withdrawal status
        await storage.updateDriverWithdrawal(withdrawal.id, {
          status: newStatus,
          providerStatus,
          providerError,
          processedAt: new Date(),
        });
        
        console.log(`[AUDIT] Withdrawal updated via Paystack webhook: id=${withdrawal.id}, status=${newStatus}`);
      }
      
      return res.status(200).json({ message: "Webhook processed" });
    } catch (error) {
      console.error("[WEBHOOK] Paystack error:", error);
      return res.status(500).json({ message: "Webhook processing failed" });
    }
  });

  // Flutterwave Webhook for transfer status updates
  app.post("/api/webhooks/flutterwave", async (req, res) => {
    try {
      const signature = req.headers["verif-hash"] as string;
      
      // Validate webhook signature
      if (!validateFlutterwaveWebhook(signature)) {
        console.log("[WEBHOOK] Invalid Flutterwave signature");
        return res.status(401).json({ message: "Invalid signature" });
      }
      
      const event = req.body;
      console.log(`[WEBHOOK] Flutterwave event received: ${event.event}`);
      
      // Handle transfer events
      if (event.event === "transfer.completed") {
        const transferData = event.data;
        const reference = transferData.reference;
        
        // Find withdrawal by reference
        const withdrawal = await storage.getDriverWithdrawalByReference(reference);
        if (!withdrawal) {
          console.log(`[WEBHOOK] Withdrawal not found for reference: ${reference}`);
          return res.status(200).json({ message: "Webhook received" });
        }
        
        let newStatus: "paid" | "failed" | "processing" = "processing";
        let providerStatus = transferData.status;
        let providerError = transferData.complete_message || null;
        
        if (transferData.status === "SUCCESSFUL") {
          newStatus = "paid";
          console.log(`[WEBHOOK] Transfer successful: reference=${reference}, withdrawalId=${withdrawal.id}`);
        } else if (transferData.status === "FAILED") {
          newStatus = "failed";
          console.log(`[WEBHOOK] Transfer failed: reference=${reference}, reason=${providerError}`);
        }
        
        // Update withdrawal status
        await storage.updateDriverWithdrawal(withdrawal.id, {
          status: newStatus,
          providerStatus,
          providerError,
          processedAt: new Date(),
        });
        
        console.log(`[AUDIT] Withdrawal updated via Flutterwave webhook: id=${withdrawal.id}, status=${newStatus}`);
      }
      
      return res.status(200).json({ message: "Webhook processed" });
    } catch (error) {
      console.error("[WEBHOOK] Flutterwave error:", error);
      return res.status(500).json({ message: "Webhook processing failed" });
    }
  });

  // Admin Driver Verification Management
  app.post("/api/admin/drivers/:userId/verify-nin", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { userId } = req.params;
      const { verified, ninNumber } = req.body;
      
      // If verifying with NIN number, check for duplicates
      if (verified && ninNumber) {
        const ninHash = require("crypto").createHash("sha256").update(ninNumber.trim().toUpperCase()).digest("hex");
        
        // Check if any other driver has this NIN hash
        const existingDriver = await storage.getDriverByNinHash(ninHash);
        if (existingDriver && existingDriver.userId !== userId) {
          console.log(`[FRAUD] Duplicate NIN detected: userId=${userId}, existingDriver=${existingDriver.userId}, by=${adminUserId}`);
          return res.status(400).json({ message: "This NIN is already registered to another driver. Fraud detected." });
        }
        
        const updated = await storage.updateDriverProfile(userId, {
          isNINVerified: true,
          ninHash: ninHash,
        });
        
        if (!updated) {
          return res.status(404).json({ message: "Driver not found" });
        }
        
        console.log(`[AUDIT] Driver NIN verified with hash: userId=${userId}, by=${adminUserId}`);
        return res.json(updated);
      }
      
      const updated = await storage.updateDriverProfile(userId, {
        isNINVerified: verified === true,
      });
      
      if (!updated) {
        return res.status(404).json({ message: "Driver not found" });
      }
      
      console.log(`[AUDIT] Driver NIN ${verified ? "verified" : "unverified"}: userId=${userId}, by=${adminUserId}`);
      return res.json(updated);
    } catch (error) {
      console.error("Error updating NIN verification:", error);
      return res.status(500).json({ message: "Failed to update NIN verification" });
    }
  });

  app.post("/api/admin/drivers/:userId/verify-license", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { userId } = req.params;
      const { verified, licenseNumber } = req.body;
      
      // If verifying with license number, check for duplicates
      if (verified && licenseNumber) {
        const licenseHash = require("crypto").createHash("sha256").update(licenseNumber.trim().toUpperCase()).digest("hex");
        
        // Check if any other driver has this license hash
        const existingDriver = await storage.getDriverByLicenseHash(licenseHash);
        if (existingDriver && existingDriver.userId !== userId) {
          console.log(`[FRAUD] Duplicate license detected: userId=${userId}, existingDriver=${existingDriver.userId}, by=${adminUserId}`);
          return res.status(400).json({ message: "This driver's license is already registered to another driver. Fraud detected." });
        }
        
        const updated = await storage.updateDriverProfile(userId, {
          isDriversLicenseVerified: true,
          driversLicenseHash: licenseHash,
        });
        
        if (!updated) {
          return res.status(404).json({ message: "Driver not found" });
        }
        
        console.log(`[AUDIT] Driver license verified with hash: userId=${userId}, by=${adminUserId}`);
        return res.json(updated);
      }
      
      const updated = await storage.updateDriverProfile(userId, {
        isDriversLicenseVerified: verified === true,
      });
      
      if (!updated) {
        return res.status(404).json({ message: "Driver not found" });
      }
      
      console.log(`[AUDIT] Driver license ${verified ? "verified" : "unverified"}: userId=${userId}, by=${adminUserId}`);
      return res.json(updated);
    } catch (error) {
      console.error("Error updating license verification:", error);
      return res.status(500).json({ message: "Failed to update license verification" });
    }
  });

  app.post("/api/admin/drivers/:userId/verify-address", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { userId } = req.params;
      const { verified } = req.body;
      
      const updated = await storage.updateDriverProfile(userId, {
        isAddressVerified: verified === true,
      });
      
      if (!updated) {
        return res.status(404).json({ message: "Driver not found" });
      }
      
      console.log(`[AUDIT] Driver address ${verified ? "verified" : "unverified"}: userId=${userId}, by=${adminUserId}`);
      return res.json(updated);
    } catch (error) {
      console.error("Error updating address verification:", error);
      return res.status(500).json({ message: "Failed to update address verification" });
    }
  });

  app.post("/api/admin/drivers/:userId/verify-identity", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { userId } = req.params;
      const { verified } = req.body;
      
      const updated = await storage.updateDriverProfile(userId, {
        isIdentityVerified: verified === true,
      });
      
      if (!updated) {
        return res.status(404).json({ message: "Driver not found" });
      }
      
      console.log(`[AUDIT] Driver identity ${verified ? "verified" : "unverified"}: userId=${userId}, by=${adminUserId}`);
      return res.json(updated);
    } catch (error) {
      console.error("Error updating identity verification:", error);
      return res.status(500).json({ message: "Failed to update identity verification" });
    }
  });

  // Complete driver verification (sets all flags and status to verified)
  app.post("/api/admin/drivers/:userId/complete-verification", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { userId } = req.params;
      
      // Update all verification flags
      await storage.updateDriverProfile(userId, {
        isNINVerified: true,
        isDriversLicenseVerified: true,
        isAddressVerified: true,
        isIdentityVerified: true,
      });
      
      // Set overall status to verified
      const updated = await storage.updateDriverWithdrawalVerificationStatus(userId, "verified");
      
      if (!updated) {
        return res.status(404).json({ message: "Driver not found" });
      }
      
      console.log(`[AUDIT] Driver verification completed: userId=${userId}, by=${adminUserId}`);
      return res.json({ message: "Driver verification completed", driver: updated });
    } catch (error) {
      console.error("Error completing driver verification:", error);
      return res.status(500).json({ message: "Failed to complete verification" });
    }
  });

  // =============================================
  // PHASE 1: UNIVERSAL IDENTITY FRAMEWORK ENDPOINTS
  // =============================================

  // Submit identity profile (for all users)
  app.post("/api/identity/submit", isAuthenticated, async (req: any, res) => {
    try {
      assertIdentityEngineLocked();
      
      const userId = req.user.claims.sub;
      const { 
        legalFullName, 
        dateOfBirth, 
        residentialAddress, 
        countryCode, 
        governmentIdType, 
        governmentIdNumber,
        driverLicenseNumber,
        driverLicenseCountry,
      } = req.body;

      // Validate required fields
      if (!legalFullName || !dateOfBirth || !residentialAddress || !countryCode || !governmentIdType || !governmentIdNumber) {
        return res.status(400).json({ message: "Missing required identity fields" });
      }

      // Validate ID type for country
      if (!isValidIdTypeForCountry(countryCode, governmentIdType)) {
        const config = getIdentityConfig(countryCode);
        return res.status(400).json({ 
          message: `Invalid ID type for ${countryCode}. Allowed: ${config.allowedIdTypes.join(", ")}`,
          code: "INVALID_ID_TYPE",
        });
      }

      // Validate submission (checks for duplicates)
      const validation = await validateIdentitySubmission({
        userId,
        countryCode,
        governmentIdType,
        governmentIdNumber,
        driverLicenseNumber,
      });

      if (!validation.allowed) {
        return res.status(400).json({
          message: validation.message,
          code: validation.code,
        });
      }

      // Check if profile already exists
      const existing = await storage.getUserIdentityProfile(userId);
      if (existing) {
        return res.status(400).json({ message: "Identity profile already submitted" });
      }

      // Hash the documents (NEVER store raw)
      const governmentIdHash = hashIdentityDocument(governmentIdNumber);
      const driverLicenseHash = driverLicenseNumber ? hashIdentityDocument(driverLicenseNumber) : null;

      // Create the identity profile
      const profile = await storage.createUserIdentityProfile({
        userId,
        legalFullName,
        dateOfBirth: new Date(dateOfBirth),
        residentialAddress,
        countryCode,
        governmentIdType,
        governmentIdHash,
        governmentIdIssuedCountry: countryCode,
        driverLicenseHash,
        driverLicenseCountry: driverLicenseCountry || null,
      });

      // Log the submission
      await storage.createIdentityAuditLog({
        userId,
        actionType: "SUBMISSION",
        actionBy: userId,
        actionDetails: JSON.stringify({ governmentIdType, countryCode }),
        countryCode,
        governmentIdType,
      });

      console.log(`[IDENTITY] Profile submitted: userId=${userId}, countryCode=${countryCode}, idType=${governmentIdType}`);

      return res.json({
        message: "Identity submitted for verification",
        profile: {
          id: profile.id,
          identityStatus: profile.identityStatus,
          countryCode: profile.countryCode,
          governmentIdType: profile.governmentIdType,
        },
      });
    } catch (error) {
      console.error("Error submitting identity:", error);
      return res.status(500).json({ message: "Failed to submit identity" });
    }
  });

  // Get my identity profile
  app.get("/api/identity/me", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getUserIdentityProfile(userId);
      
      if (!profile) {
        return res.json({ submitted: false });
      }

      return res.json({
        submitted: true,
        identityStatus: profile.identityStatus,
        identityVerified: profile.identityVerified,
        driverLicenseVerified: profile.driverLicenseVerified,
        countryCode: profile.countryCode,
        governmentIdType: profile.governmentIdType,
        rejectionReason: profile.rejectionReason,
        createdAt: profile.createdAt,
      });
    } catch (error) {
      console.error("Error getting identity profile:", error);
      return res.status(500).json({ message: "Failed to get identity profile" });
    }
  });

  // Get identity config for country
  app.get("/api/identity/config/:countryCode", isAuthenticated, async (req: any, res) => {
    try {
      const { countryCode } = req.params;
      const config = getIdentityConfig(countryCode);
      return res.json(config);
    } catch (error) {
      console.error("Error getting identity config:", error);
      return res.status(500).json({ message: "Failed to get identity config" });
    }
  });

  // Admin: Get all pending identity profiles
  app.get("/api/admin/identity/pending", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const profiles = await storage.getAllPendingIdentityProfiles();
      return res.json(profiles);
    } catch (error) {
      console.error("Error getting pending identities:", error);
      return res.status(500).json({ message: "Failed to get pending identities" });
    }
  });

  // Admin: Get all identity profiles
  app.get("/api/admin/identity/all", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const profiles = await storage.getAllIdentityProfiles();
      return res.json(profiles);
    } catch (error) {
      console.error("Error getting identities:", error);
      return res.status(500).json({ message: "Failed to get identities" });
    }
  });

  // Admin: Get identity profile for user
  app.get("/api/admin/identity/:userId", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const profile = await storage.getUserIdentityProfile(userId);
      
      if (!profile) {
        return res.status(404).json({ message: "Identity profile not found" });
      }

      return res.json(profile);
    } catch (error) {
      console.error("Error getting identity profile:", error);
      return res.status(500).json({ message: "Failed to get identity profile" });
    }
  });

  // Admin: Approve identity
  app.post("/api/admin/identity/:userId/approve", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { userId } = req.params;

      const result = await adminApproveIdentity(userId, adminId);
      
      if (!result.success) {
        return res.status(400).json({ message: result.message });
      }

      return res.json({ message: result.message });
    } catch (error) {
      console.error("Error approving identity:", error);
      return res.status(500).json({ message: "Failed to approve identity" });
    }
  });

  // Admin: Reject identity
  app.post("/api/admin/identity/:userId/reject", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { userId } = req.params;
      const { reason } = req.body;

      if (!reason) {
        return res.status(400).json({ message: "Rejection reason is required" });
      }

      const result = await adminRejectIdentity(userId, adminId, reason);
      
      if (!result.success) {
        return res.status(400).json({ message: result.message });
      }

      return res.json({ message: result.message });
    } catch (error) {
      console.error("Error rejecting identity:", error);
      return res.status(500).json({ message: "Failed to reject identity" });
    }
  });

  // Admin: Verify driver license
  app.post("/api/admin/identity/:userId/verify-license", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { userId } = req.params;

      const result = await adminVerifyDriverLicense(userId, adminId);
      
      if (!result.success) {
        return res.status(400).json({ message: result.message });
      }

      return res.json({ message: result.message });
    } catch (error) {
      console.error("Error verifying driver license:", error);
      return res.status(500).json({ message: "Failed to verify driver license" });
    }
  });

  // Admin: Get identity audit logs
  app.get("/api/admin/identity/audit-logs", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const logs = await storage.getAllIdentityAuditLogs();
      return res.json(logs);
    } catch (error) {
      console.error("Error getting audit logs:", error);
      return res.status(500).json({ message: "Failed to get audit logs" });
    }
  });

  // Admin: Get identity audit logs for user
  app.get("/api/admin/identity/:userId/audit-logs", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const logs = await storage.getIdentityAuditLogs(userId);
      return res.json(logs);
    } catch (error) {
      console.error("Error getting user audit logs:", error);
      return res.status(500).json({ message: "Failed to get user audit logs" });
    }
  });

  // Check driver can go online (for UI feedback)
  app.get("/api/driver/identity-check", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const result = await checkDriverCanGoOnline(userId);
      return res.json(result);
    } catch (error) {
      console.error("Error checking driver identity:", error);
      return res.status(500).json({ message: "Failed to check driver identity" });
    }
  });

  // =============================================
  // PHASE 2: DRIVER GPS & NAVIGATION ENFORCEMENT ENDPOINTS
  // =============================================

  // Get navigation providers list
  app.get("/api/navigation/providers", isAuthenticated, async (req: any, res) => {
    try {
      const providers = Object.values(NAVIGATION_PROVIDERS).map(p => ({
        id: p.id,
        name: p.name,
      }));
      return res.json(providers);
    } catch (error) {
      console.error("Error getting navigation providers:", error);
      return res.status(500).json({ message: "Failed to get navigation providers" });
    }
  });

  // Get driver's navigation setup status
  app.get("/api/driver/navigation/setup", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const setup = await storage.getDriverNavigationSetup(userId);
      
      if (!setup) {
        return res.json({
          exists: false,
          setupComplete: false,
          gpsPermissionGranted: false,
          highAccuracyEnabled: false,
          preferredNavigationProvider: null,
          backgroundLocationConsent: false,
          foregroundServiceConsent: false,
        });
      }
      
      return res.json({
        exists: true,
        setupComplete: setup.navigationSetupCompleted,
        gpsPermissionGranted: setup.gpsPermissionGranted,
        highAccuracyEnabled: setup.highAccuracyEnabled,
        preferredNavigationProvider: setup.preferredNavigationProvider,
        backgroundLocationConsent: setup.backgroundLocationConsent,
        foregroundServiceConsent: setup.foregroundServiceConsent,
        isGpsActive: setup.isGpsActive,
        lastGpsHeartbeat: setup.lastGpsHeartbeat,
        lastOfflineReason: setup.lastOfflineReason,
      });
    } catch (error) {
      console.error("Error getting navigation setup:", error);
      return res.status(500).json({ message: "Failed to get navigation setup" });
    }
  });

  // Initialize or update navigation setup (Step 1: GPS Permission)
  app.post("/api/driver/navigation/setup/gps-permission", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      assertNavigationEngineLocked();
      
      const userId = req.user.claims.sub;
      const { granted, highAccuracy, permissionStatus } = req.body;
      
      let setup = await storage.getDriverNavigationSetup(userId);
      
      if (!setup) {
        setup = await storage.createDriverNavigationSetup({
          userId,
          gpsPermissionGranted: granted === true,
          highAccuracyEnabled: highAccuracy === true,
          locationPermissionStatus: permissionStatus || (granted ? "granted" : "denied"),
        });
      } else {
        setup = await storage.updateDriverNavigationSetup(userId, {
          gpsPermissionGranted: granted === true,
          highAccuracyEnabled: highAccuracy === true,
          locationPermissionStatus: permissionStatus || (granted ? "granted" : "denied"),
        });
      }
      
      // Log audit event
      await storage.createNavigationAuditLog({
        userId,
        actionType: granted ? "PERMISSION_GRANTED" : "PERMISSION_DENIED",
        actionDetails: JSON.stringify({ highAccuracy, permissionStatus }),
      });
      
      console.log(`[NAVIGATION] GPS permission ${granted ? "granted" : "denied"}: userId=${userId}`);
      
      return res.json({
        success: true,
        message: granted ? "GPS permission granted" : "GPS permission denied",
        setup,
      });
    } catch (error) {
      console.error("Error updating GPS permission:", error);
      return res.status(500).json({ message: "Failed to update GPS permission" });
    }
  });

  // Update navigation setup (Step 2: Navigation Provider Selection)
  app.post("/api/driver/navigation/setup/provider", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      assertNavigationEngineLocked();
      
      const userId = req.user.claims.sub;
      const { provider } = req.body;
      
      if (!provider || !NAVIGATION_PROVIDERS[provider as keyof typeof NAVIGATION_PROVIDERS]) {
        return res.status(400).json({ message: "Invalid navigation provider" });
      }
      
      let setup = await storage.getDriverNavigationSetup(userId);
      
      if (!setup) {
        return res.status(400).json({ message: "Complete GPS permission step first" });
      }
      
      setup = await storage.updateDriverNavigationSetup(userId, {
        preferredNavigationProvider: provider,
        navigationProviderSetAt: new Date(),
      });
      
      // Log audit event
      await storage.createNavigationAuditLog({
        userId,
        actionType: "PROVIDER_CHANGED",
        actionDetails: JSON.stringify({ provider }),
        navigationProvider: provider,
      });
      
      console.log(`[NAVIGATION] Provider set: userId=${userId}, provider=${provider}`);
      
      return res.json({
        success: true,
        message: `Navigation provider set to ${NAVIGATION_PROVIDERS[provider as keyof typeof NAVIGATION_PROVIDERS].name}`,
        setup,
      });
    } catch (error) {
      console.error("Error updating navigation provider:", error);
      return res.status(500).json({ message: "Failed to update navigation provider" });
    }
  });

  // Update navigation setup (Step 3: Background Execution Consent)
  app.post("/api/driver/navigation/setup/background-consent", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      assertNavigationEngineLocked();
      
      const userId = req.user.claims.sub;
      const { backgroundLocation, foregroundService } = req.body;
      
      let setup = await storage.getDriverNavigationSetup(userId);
      
      if (!setup) {
        return res.status(400).json({ message: "Complete GPS permission step first" });
      }
      
      setup = await storage.updateDriverNavigationSetup(userId, {
        backgroundLocationConsent: backgroundLocation === true,
        foregroundServiceConsent: foregroundService === true,
      });
      
      // Log audit event
      await storage.createNavigationAuditLog({
        userId,
        actionType: "BACKGROUND_CONSENT_GRANTED",
        actionDetails: JSON.stringify({ backgroundLocation, foregroundService }),
      });
      
      console.log(`[NAVIGATION] Background consent updated: userId=${userId}, bg=${backgroundLocation}, fg=${foregroundService}`);
      
      return res.json({
        success: true,
        message: "Background execution consent updated",
        setup,
      });
    } catch (error) {
      console.error("Error updating background consent:", error);
      return res.status(500).json({ message: "Failed to update background consent" });
    }
  });

  // Complete navigation setup wizard
  app.post("/api/driver/navigation/setup/complete", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      assertNavigationEngineLocked();
      
      const userId = req.user.claims.sub;
      
      // Validate all steps are complete
      const checkResult = await checkNavigationSetup(userId);
      
      if (!checkResult.canGoOnline) {
        return res.status(400).json({
          success: false,
          message: checkResult.message,
          missingSteps: checkResult.missingSteps,
        });
      }
      
      // Mark setup as complete
      const setup = await storage.completeNavigationSetup(userId);
      
      // Log audit event
      await storage.createNavigationAuditLog({
        userId,
        actionType: "SETUP_COMPLETED",
        actionDetails: JSON.stringify({ completedAt: new Date() }),
      });
      
      console.log(`[NAVIGATION] Setup completed: userId=${userId}`);
      
      return res.json({
        success: true,
        message: "Navigation setup completed. You can now go online.",
        setup,
      });
    } catch (error) {
      console.error("Error completing navigation setup:", error);
      return res.status(500).json({ message: "Failed to complete navigation setup" });
    }
  });

  // Check if driver can go online (combined identity + navigation check)
  app.get("/api/driver/can-go-online", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Check identity requirements
      const identityCheck = await checkDriverCanGoOnline(userId);
      
      // Check navigation requirements
      const navigationCheck = await checkNavigationSetup(userId);
      
      const canGoOnline = identityCheck.allowed && navigationCheck.canGoOnline;
      
      return res.json({
        canGoOnline,
        identity: {
          ready: identityCheck.allowed,
          message: identityCheck.message,
        },
        navigation: {
          ready: navigationCheck.canGoOnline,
          setupComplete: navigationCheck.setupComplete,
          missingSteps: navigationCheck.missingSteps,
          message: navigationCheck.message,
        },
      });
    } catch (error) {
      console.error("Error checking driver status:", error);
      return res.status(500).json({ message: "Failed to check driver status" });
    }
  });

  // GPS heartbeat update (called frequently while online/on trip)
  app.post("/api/driver/gps/heartbeat", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      assertNavigationEngineLocked();
      
      const userId = req.user.claims.sub;
      const { latitude, longitude, accuracy, altitude, speed, heading, deviceTimestamp } = req.body;
      
      if (!latitude || !longitude) {
        return res.status(400).json({ message: "Latitude and longitude are required" });
      }
      
      const result = await processGpsUpdate(
        userId,
        parseFloat(latitude),
        parseFloat(longitude),
        accuracy ? parseFloat(accuracy) : undefined,
        altitude ? parseFloat(altitude) : undefined,
        speed ? parseFloat(speed) : undefined,
        heading ? parseFloat(heading) : undefined,
        deviceTimestamp ? new Date(deviceTimestamp) : undefined
      );
      
      if (!result.success) {
        return res.status(400).json({
          success: false,
          message: result.message,
          isSpoofing: result.isSpoofing,
        });
      }
      
      return res.json({
        success: true,
        message: "GPS heartbeat received",
      });
    } catch (error) {
      console.error("Error processing GPS heartbeat:", error);
      return res.status(500).json({ message: "Failed to process GPS heartbeat" });
    }
  });

  // Report GPS state change
  app.post("/api/driver/gps/state", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      assertNavigationEngineLocked();
      
      const userId = req.user.claims.sub;
      const { enabled, latitude, longitude } = req.body;
      
      await storage.updateGpsState(userId, enabled === true, latitude, longitude);
      
      // Log the event
      await storage.createNavigationAuditLog({
        userId,
        actionType: enabled ? "PERMISSION_GRANTED" : "GPS_TIMEOUT",
        actionDetails: JSON.stringify({ enabled }),
        latitude,
        longitude,
      });
      
      // If GPS disabled, trigger auto-offline
      if (!enabled) {
        await triggerAutoOffline(userId, "GPS_DISABLED", "Driver disabled GPS");
      }
      
      return res.json({
        success: true,
        message: enabled ? "GPS enabled" : "GPS disabled - driver set offline",
      });
    } catch (error) {
      console.error("Error updating GPS state:", error);
      return res.status(500).json({ message: "Failed to update GPS state" });
    }
  });

  // Report app state change (foreground/background)
  app.post("/api/driver/app/state", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      assertNavigationEngineLocked();
      
      const userId = req.user.claims.sub;
      const { isInForeground } = req.body;
      
      await reportAppState(userId, isInForeground === true);
      
      return res.json({
        success: true,
        message: isInForeground ? "App resumed" : "App backgrounded",
      });
    } catch (error) {
      console.error("Error updating app state:", error);
      return res.status(500).json({ message: "Failed to update app state" });
    }
  });

  // Get navigation link for trip
  app.post("/api/driver/navigation/launch", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      assertNavigationEngineLocked();
      
      const userId = req.user.claims.sub;
      const { tripId, destLatitude, destLongitude, startLatitude, startLongitude } = req.body;
      
      if (!tripId || !destLatitude || !destLongitude) {
        return res.status(400).json({ message: "Trip ID and destination coordinates are required" });
      }
      
      const links = await launchNavigation(
        userId,
        tripId,
        parseFloat(destLatitude),
        parseFloat(destLongitude),
        startLatitude ? parseFloat(startLatitude) : undefined,
        startLongitude ? parseFloat(startLongitude) : undefined
      );
      
      if (!links) {
        return res.status(400).json({ message: "Navigation setup not complete" });
      }
      
      return res.json({
        success: true,
        deepLink: links.deepLink,
        webFallback: links.webFallback,
      });
    } catch (error) {
      console.error("Error launching navigation:", error);
      return res.status(500).json({ message: "Failed to launch navigation" });
    }
  });

  // Close navigation (trip ended)
  app.post("/api/driver/navigation/close", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      assertNavigationEngineLocked();
      
      const userId = req.user.claims.sub;
      const { tripId } = req.body;
      
      await closeNavigation(userId, tripId);
      
      return res.json({
        success: true,
        message: "Navigation closed",
      });
    } catch (error) {
      console.error("Error closing navigation:", error);
      return res.status(500).json({ message: "Failed to close navigation" });
    }
  });

  // Admin: Get all driver navigation setups
  app.get("/api/admin/navigation/drivers", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const setups = await storage.getAllDriverNavigationSetups();
      return res.json(setups);
    } catch (error) {
      console.error("Error getting driver navigation setups:", error);
      return res.status(500).json({ message: "Failed to get driver navigation setups" });
    }
  });

  // Admin: Get driver's navigation setup
  app.get("/api/admin/navigation/drivers/:userId", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const setup = await storage.getDriverNavigationSetup(userId);
      
      if (!setup) {
        return res.status(404).json({ message: "Navigation setup not found" });
      }
      
      return res.json(setup);
    } catch (error) {
      console.error("Error getting driver navigation setup:", error);
      return res.status(500).json({ message: "Failed to get driver navigation setup" });
    }
  });

  // Admin: Get drivers with GPS issues
  app.get("/api/admin/navigation/gps-issues", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const driversWithIssues = await storage.getDriversWithGpsIssues();
      return res.json(driversWithIssues);
    } catch (error) {
      console.error("Error getting drivers with GPS issues:", error);
      return res.status(500).json({ message: "Failed to get drivers with GPS issues" });
    }
  });

  // Admin: Get all GPS interruptions
  app.get("/api/admin/navigation/interruptions", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const interruptions = await storage.getAllGpsInterruptions();
      return res.json(interruptions);
    } catch (error) {
      console.error("Error getting GPS interruptions:", error);
      return res.status(500).json({ message: "Failed to get GPS interruptions" });
    }
  });

  // Admin: Get driver's GPS interruptions
  app.get("/api/admin/navigation/interruptions/:userId", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const interruptions = await storage.getGpsInterruptions(userId);
      return res.json(interruptions);
    } catch (error) {
      console.error("Error getting driver GPS interruptions:", error);
      return res.status(500).json({ message: "Failed to get driver GPS interruptions" });
    }
  });

  // Admin: Resolve GPS interruption
  app.post("/api/admin/navigation/interruptions/:interruptionId/resolve", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { interruptionId } = req.params;
      const { notes } = req.body;
      
      if (!notes) {
        return res.status(400).json({ message: "Resolution notes are required" });
      }
      
      const interruption = await storage.resolveGpsInterruption(interruptionId, notes);
      
      if (!interruption) {
        return res.status(404).json({ message: "Interruption not found" });
      }
      
      return res.json({
        success: true,
        message: "Interruption resolved",
        interruption,
      });
    } catch (error) {
      console.error("Error resolving GPS interruption:", error);
      return res.status(500).json({ message: "Failed to resolve GPS interruption" });
    }
  });

  // Admin: Get all navigation audit logs
  app.get("/api/admin/navigation/audit-logs", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const logs = await storage.getAllNavigationAuditLogs();
      return res.json(logs);
    } catch (error) {
      console.error("Error getting navigation audit logs:", error);
      return res.status(500).json({ message: "Failed to get navigation audit logs" });
    }
  });

  // Admin: Get driver's navigation audit logs
  app.get("/api/admin/navigation/audit-logs/:userId", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const logs = await storage.getNavigationAuditLogs(userId);
      return res.json(logs);
    } catch (error) {
      console.error("Error getting driver navigation audit logs:", error);
      return res.status(500).json({ message: "Failed to get driver navigation audit logs" });
    }
  });

  // Admin: Get driver's GPS tracking logs
  app.get("/api/admin/navigation/tracking/:userId", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const limit = req.query.limit ? parseInt(req.query.limit as string) : 100;
      const logs = await storage.getGpsTrackingLogs(userId, limit);
      return res.json(logs);
    } catch (error) {
      console.error("Error getting GPS tracking logs:", error);
      return res.status(500).json({ message: "Failed to get GPS tracking logs" });
    }
  });

  // Admin: Get GPS tracking logs for a trip
  app.get("/api/admin/navigation/tracking/trip/:tripId", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { tripId } = req.params;
      const logs = await storage.getGpsTrackingLogsForTrip(tripId);
      return res.json(logs);
    } catch (error) {
      console.error("Error getting trip GPS tracking logs:", error);
      return res.status(500).json({ message: "Failed to get trip GPS tracking logs" });
    }
  });

  // System: Check stale GPS heartbeats (called by cron/scheduled task)
  app.post("/api/system/navigation/check-heartbeats", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      assertNavigationEngineLocked();
      
      const offlinedCount = await checkStaleGpsHeartbeats();
      
      return res.json({
        success: true,
        offlinedCount,
        message: `Checked heartbeats. ${offlinedCount} drivers auto-offlined.`,
      });
    } catch (error) {
      console.error("Error checking stale heartbeats:", error);
      return res.status(500).json({ message: "Failed to check stale heartbeats" });
    }
  });

  app.get("/api/notifications", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const notifications = await storage.getUserNotifications(userId);
      return res.json(notifications);
    } catch (error) {
      console.error("Error getting notifications:", error);
      return res.status(500).json({ message: "Failed to get notifications" });
    }
  });

  app.get("/api/notifications/unread-count", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const count = await storage.getUnreadNotificationCount(userId);
      return res.json({ count });
    } catch (error) {
      console.error("Error getting unread count:", error);
      return res.status(500).json({ message: "Failed to get unread count" });
    }
  });

  app.post("/api/notifications/:notificationId/read", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { notificationId } = req.params;
      const notification = await storage.markNotificationAsRead(notificationId, userId);
      if (!notification) {
        return res.status(404).json({ message: "Notification not found" });
      }
      return res.json(notification);
    } catch (error) {
      console.error("Error marking notification as read:", error);
      return res.status(500).json({ message: "Failed to mark notification as read" });
    }
  });

  app.post("/api/notifications/read-all", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      await storage.markAllNotificationsAsRead(userId);
      return res.json({ success: true });
    } catch (error) {
      console.error("Error marking all notifications as read:", error);
      return res.status(500).json({ message: "Failed to mark all as read" });
    }
  });

  // Rating endpoints
  app.post("/api/ratings", isAuthenticated, requireRole(["driver", "rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { tripId, score, comment } = req.body;

      if (!tripId || !score || score < 1 || score > 5) {
        return res.status(400).json({ message: "Valid tripId and score (1-5) are required" });
      }

      // Get trip details
      const trip = await storage.getTripById(tripId);
      if (!trip) {
        return res.status(404).json({ message: "Trip not found" });
      }

      // Check trip is completed
      if (trip.status !== "completed") {
        return res.status(400).json({ message: "Can only rate completed trips" });
      }

      // Check user participated in the trip
      const userRole = await storage.getUserRole(userId);
      if (!userRole) {
        return res.status(403).json({ message: "User role not found" });
      }

      let targetUserId: string;
      let raterRole: "rider" | "driver";

      if (userRole.role === "rider" && trip.riderId === userId) {
        targetUserId = trip.driverId;
        raterRole = "rider";
      } else if (userRole.role === "driver" && trip.driverId === userId) {
        targetUserId = trip.riderId;
        raterRole = "driver";
      } else {
        return res.status(403).json({ message: "You did not participate in this trip" });
      }

      // Check if already rated
      const existingRating = await storage.getRatingByTripAndRater(tripId, userId);
      if (existingRating) {
        return res.status(400).json({ message: "You have already rated this trip" });
      }

      // Create rating
      const rating = await storage.createRating({
        tripId,
        raterRole,
        raterId: userId,
        targetUserId,
        score,
        comment: comment?.substring(0, 300) || null,
      });

      // Update target user's average rating
      const targetRole = raterRole === "rider" ? "driver" : "rider";
      await storage.updateUserAverageRating(targetUserId, targetRole);

      return res.json(rating);
    } catch (error) {
      console.error("Error creating rating:", error);
      return res.status(500).json({ message: "Failed to create rating" });
    }
  });

  app.get("/api/ratings/trip/:tripId", isAuthenticated, async (req: any, res) => {
    try {
      const { tripId } = req.params;
      const ratings = await storage.getTripRatings(tripId);
      return res.json(ratings);
    } catch (error) {
      console.error("Error getting trip ratings:", error);
      return res.status(500).json({ message: "Failed to get ratings" });
    }
  });

  app.get("/api/ratings/check/:tripId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { tripId } = req.params;
      const existingRating = await storage.getRatingByTripAndRater(tripId, userId);
      return res.json({ hasRated: !!existingRating, rating: existingRating });
    } catch (error) {
      console.error("Error checking rating:", error);
      return res.status(500).json({ message: "Failed to check rating" });
    }
  });

  app.get("/api/admin/ratings", isAuthenticated, requireRole(["admin", "director"]), async (req: any, res) => {
    try {
      const ratings = await storage.getAllRatings();
      return res.json(ratings);
    } catch (error) {
      console.error("Error getting all ratings:", error);
      return res.status(500).json({ message: "Failed to get ratings" });
    }
  });

  // Dispute endpoints
  app.post("/api/disputes", isAuthenticated, requireRole(["driver", "rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { tripId, category, description } = req.body;
      
      if (!tripId || !category || !description) {
        return res.status(400).json({ message: "Trip ID, category, and description are required" });
      }
      
      if (description.length > 500) {
        return res.status(400).json({ message: "Description must be 500 characters or less" });
      }
      
      // Get trip to validate
      const trip = await storage.getTripById(tripId);
      if (!trip) {
        return res.status(404).json({ message: "Trip not found" });
      }
      
      // Check trip status - only completed or cancelled trips
      if (trip.status !== "completed" && trip.status !== "cancelled") {
        return res.status(400).json({ message: "Disputes can only be filed for completed or cancelled trips" });
      }
      
      // Check if user participated in this trip
      const isRider = trip.riderId === userId;
      const isDriver = trip.driverId === userId;
      
      if (!isRider && !isDriver) {
        return res.status(403).json({ message: "You can only file disputes for trips you participated in" });
      }
      
      // Check for existing dispute by this user for this trip
      const existingDispute = await storage.getDisputeByTripAndUser(tripId, userId);
      if (existingDispute) {
        return res.status(400).json({ message: "You have already filed a dispute for this trip" });
      }
      
      // Determine roles and target
      const raisedByRole = isRider ? "rider" : "driver";
      const againstUserId = isRider ? trip.driverId : trip.riderId;
      
      if (!againstUserId) {
        return res.status(400).json({ message: "Cannot file dispute - other party not identified" });
      }
      
      const dispute = await storage.createDispute({
        tripId,
        raisedByRole,
        raisedById: userId,
        againstUserId,
        category,
        description,
      });
      
      return res.status(201).json(dispute);
    } catch (error) {
      console.error("Error creating dispute:", error);
      return res.status(500).json({ message: "Failed to create dispute" });
    }
  });

  app.get("/api/disputes/check/:tripId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { tripId } = req.params;
      const existingDispute = await storage.getDisputeByTripAndUser(tripId, userId);
      return res.json({ hasDispute: !!existingDispute, dispute: existingDispute });
    } catch (error) {
      console.error("Error checking dispute:", error);
      return res.status(500).json({ message: "Failed to check dispute" });
    }
  });

  app.get("/api/disputes/trip/:tripId", isAuthenticated, async (req: any, res) => {
    try {
      const { tripId } = req.params;
      const disputes = await storage.getTripDisputes(tripId);
      return res.json(disputes);
    } catch (error) {
      console.error("Error getting trip disputes:", error);
      return res.status(500).json({ message: "Failed to get disputes" });
    }
  });

  app.get("/api/admin/disputes", isAuthenticated, requireRole(["admin", "director"]), async (req: any, res) => {
    try {
      const { status, category, raisedByRole } = req.query;
      const filter: any = {};
      if (status) filter.status = status;
      if (category) filter.category = category;
      if (raisedByRole) filter.raisedByRole = raisedByRole;
      
      const disputes = Object.keys(filter).length > 0 
        ? await storage.getFilteredDisputes(filter)
        : await storage.getAllDisputes();
      return res.json(disputes);
    } catch (error) {
      console.error("Error getting disputes:", error);
      return res.status(500).json({ message: "Failed to get disputes" });
    }
  });

  app.get("/api/admin/disputes/:id", isAuthenticated, requireRole(["admin", "director"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const dispute = await storage.getDisputeById(id);
      if (!dispute) {
        return res.status(404).json({ message: "Dispute not found" });
      }
      return res.json(dispute);
    } catch (error) {
      console.error("Error getting dispute:", error);
      return res.status(500).json({ message: "Failed to get dispute" });
    }
  });

  app.patch("/api/admin/disputes/:id", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { status, adminNotes } = req.body;
      
      const existingDispute = await storage.getDisputeById(id);
      if (!existingDispute) {
        return res.status(404).json({ message: "Dispute not found" });
      }
      
      const updateData: any = {};
      if (status) updateData.status = status;
      if (adminNotes !== undefined) updateData.adminNotes = adminNotes;
      
      const dispute = await storage.updateDispute(id, updateData);
      return res.json(dispute);
    } catch (error) {
      console.error("Error updating dispute:", error);
      return res.status(500).json({ message: "Failed to update dispute" });
    }
  });

  // ============================================
  // PHASE 10A: REFUNDS & ADJUSTMENTS
  // ============================================

  // Create refund - Admin and Trip Coordinator only
  app.post("/api/refunds/create", isAuthenticated, requireRole(["admin", "trip_coordinator"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userRole = req.userRole;
      const { tripId, amount, type, reason, linkedDisputeId } = req.body;

      if (!tripId || !amount || !type || !reason) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      const trip = await storage.getTripById(tripId);
      if (!trip) {
        return res.status(404).json({ message: "Trip not found" });
      }

      const refundData = {
        tripId,
        riderId: trip.riderId,
        driverId: trip.driverId || undefined,
        amount: String(amount),
        type: type as "full" | "partial" | "adjustment",
        reason,
        createdByRole: userRole as "admin" | "trip_coordinator" | "finance",
        createdByUserId: userId,
        linkedDisputeId: linkedDisputeId || undefined,
      };

      const refund = await storage.createRefund(refundData);

      // Create audit log
      await storage.createAuditLog({
        action: "refund_created",
        entityType: "refund",
        entityId: refund.id,
        performedByUserId: userId,
        performedByRole: userRole,
        metadata: JSON.stringify({ tripId, amount, type, reason }),
      });

      return res.json(refund);
    } catch (error) {
      console.error("Error creating refund:", error);
      return res.status(500).json({ message: "Failed to create refund" });
    }
  });

  // Approve refund - Admin can approve any, Trip Coordinator can approve <= $20
  app.post("/api/refunds/approve", isAuthenticated, requireRole(["admin", "trip_coordinator"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userRole = req.userRole;
      const { refundId } = req.body;

      const refund = await storage.getRefundById(refundId);
      if (!refund) {
        return res.status(404).json({ message: "Refund not found" });
      }

      if (refund.status !== "pending") {
        return res.status(400).json({ message: "Refund is not pending approval" });
      }

      // Trip Coordinator can only approve refunds <= $20
      if (userRole === "trip_coordinator" && parseFloat(refund.amount) > 20) {
        return res.status(403).json({ message: "Trip Coordinators can only approve refunds up to $20. Admin approval required." });
      }

      const updatedRefund = await storage.updateRefund(refundId, {
        status: "approved",
        approvedByUserId: userId,
      });

      // Create audit log
      await storage.createAuditLog({
        action: "refund_approved",
        entityType: "refund",
        entityId: refundId,
        performedByUserId: userId,
        performedByRole: userRole,
        metadata: JSON.stringify({ amount: refund.amount }),
      });

      return res.json(updatedRefund);
    } catch (error) {
      console.error("Error approving refund:", error);
      return res.status(500).json({ message: "Failed to approve refund" });
    }
  });

  // Reject refund - Admin only
  app.post("/api/refunds/reject", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userRole = req.userRole;
      const { refundId, reason } = req.body;

      const refund = await storage.getRefundById(refundId);
      if (!refund) {
        return res.status(404).json({ message: "Refund not found" });
      }

      if (refund.status !== "pending") {
        return res.status(400).json({ message: "Refund is not pending" });
      }

      const updatedRefund = await storage.updateRefund(refundId, {
        status: "rejected",
        reason: reason || refund.reason,
      });

      // Create audit log
      await storage.createAuditLog({
        action: "refund_rejected",
        entityType: "refund",
        entityId: refundId,
        performedByUserId: userId,
        performedByRole: userRole,
        metadata: JSON.stringify({ reason }),
      });

      return res.json(updatedRefund);
    } catch (error) {
      console.error("Error rejecting refund:", error);
      return res.status(500).json({ message: "Failed to reject refund" });
    }
  });

  // Process refund - Finance only (processes approved refunds)
  app.post("/api/refunds/process", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userRole = req.userRole;
      const { refundId } = req.body;

      const refund = await storage.getRefundById(refundId);
      if (!refund) {
        return res.status(404).json({ message: "Refund not found" });
      }

      if (refund.status !== "approved") {
        return res.status(400).json({ message: "Refund must be approved before processing" });
      }

      const updatedRefund = await storage.updateRefund(refundId, {
        status: "processed",
        processedByUserId: userId,
      });

      // Create audit log
      await storage.createAuditLog({
        action: "refund_processed",
        entityType: "refund",
        entityId: refundId,
        performedByUserId: userId,
        performedByRole: userRole,
        metadata: JSON.stringify({ amount: refund.amount }),
      });

      return res.json(updatedRefund);
    } catch (error) {
      console.error("Error processing refund:", error);
      return res.status(500).json({ message: "Failed to process refund" });
    }
  });

  // Reverse refund - Admin only
  app.post("/api/refunds/reverse", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userRole = req.userRole;
      const { refundId, reason } = req.body;

      const refund = await storage.getRefundById(refundId);
      if (!refund) {
        return res.status(404).json({ message: "Refund not found" });
      }

      if (refund.status !== "processed") {
        return res.status(400).json({ message: "Only processed refunds can be reversed" });
      }

      const updatedRefund = await storage.updateRefund(refundId, {
        status: "reversed",
      });

      // Create audit log
      await storage.createAuditLog({
        action: "refund_reversed",
        entityType: "refund",
        entityId: refundId,
        performedByUserId: userId,
        performedByRole: userRole,
        metadata: JSON.stringify({ reason }),
      });

      return res.json(updatedRefund);
    } catch (error) {
      console.error("Error reversing refund:", error);
      return res.status(500).json({ message: "Failed to reverse refund" });
    }
  });

  // Get refunds with filtering
  app.get("/api/refunds", isAuthenticated, requireRole(["admin", "finance", "trip_coordinator", "director"]), async (req: any, res) => {
    try {
      const { tripId, status } = req.query;
      const filter: any = {};
      if (tripId) filter.tripId = tripId;
      if (status) filter.status = status;

      const refundsList = Object.keys(filter).length > 0
        ? await storage.getFilteredRefunds(filter)
        : await storage.getAllRefunds();
      return res.json(refundsList);
    } catch (error) {
      console.error("Error getting refunds:", error);
      return res.status(500).json({ message: "Failed to get refunds" });
    }
  });

  // Get refund audit trail
  app.get("/api/refunds/:refundId/audit", isAuthenticated, requireRole(["admin", "finance", "trip_coordinator", "director"]), async (req: any, res) => {
    try {
      const { refundId } = req.params;
      const auditLogs = await storage.getAuditLogsByEntity("refund", refundId);
      return res.json(auditLogs);
    } catch (error) {
      console.error("Error getting refund audit:", error);
      return res.status(500).json({ message: "Failed to get audit logs" });
    }
  });

  // Rider view own refunds
  app.get("/api/rider/refunds", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const refundsList = await storage.getRiderRefunds(userId);
      return res.json(refundsList);
    } catch (error) {
      console.error("Error getting rider refunds:", error);
      return res.status(500).json({ message: "Failed to get refunds" });
    }
  });

  // Driver view refunds affecting them
  app.get("/api/driver/refunds", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const refundsList = await storage.getDriverRefunds(userId);
      return res.json(refundsList);
    } catch (error) {
      console.error("Error getting driver refunds:", error);
      return res.status(500).json({ message: "Failed to get refunds" });
    }
  });

  // Wallet adjustment - Admin only
  app.post("/api/wallet/adjust", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userRole = req.userRole;
      const { targetUserId, amount, reason, linkedRefundId } = req.body;

      if (!targetUserId || amount === undefined || !reason) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      const adjustment = await storage.createWalletAdjustment({
        userId: targetUserId,
        amount: String(amount),
        reason,
        linkedRefundId: linkedRefundId || undefined,
        createdByUserId: userId,
      });

      // Create audit log
      await storage.createAuditLog({
        action: "wallet_adjusted",
        entityType: "wallet_adjustment",
        entityId: adjustment.id,
        performedByUserId: userId,
        performedByRole: userRole,
        metadata: JSON.stringify({ targetUserId, amount, reason }),
      });

      return res.json(adjustment);
    } catch (error) {
      console.error("Error creating wallet adjustment:", error);
      return res.status(500).json({ message: "Failed to create wallet adjustment" });
    }
  });

  // Get all wallet adjustments
  app.get("/api/wallet/adjustments", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const adjustments = await storage.getAllWalletAdjustments();
      return res.json(adjustments);
    } catch (error) {
      console.error("Error getting wallet adjustments:", error);
      return res.status(500).json({ message: "Failed to get wallet adjustments" });
    }
  });

  // ============= PHASE 10B: CHARGEBACKS & RECONCILIATION =============

  // Report a new chargeback (Finance/Admin only)
  app.post("/api/chargebacks/report", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userRole = req.userRole;
      const { tripId, paymentProvider, externalReference, amount, currency, reason } = req.body;

      if (!tripId || !paymentProvider || !externalReference || amount === undefined) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      // Verify trip exists
      const trip = await storage.getTripById(tripId);
      if (!trip) {
        return res.status(404).json({ message: "Trip not found" });
      }

      const chargeback = await storage.createChargeback({
        tripId,
        paymentProvider,
        externalReference,
        amount: String(amount),
        currency: currency || "NGN",
        reason,
        status: "reported",
        reportedAt: new Date(),
      });

      // Audit log
      await storage.createAuditLog({
        action: "chargeback_reported",
        entityType: "chargeback",
        entityId: chargeback.id,
        performedByUserId: userId,
        performedByRole: userRole,
        metadata: JSON.stringify({ tripId, paymentProvider, externalReference, amount }),
      });

      return res.json(chargeback);
    } catch (error) {
      console.error("Error reporting chargeback:", error);
      return res.status(500).json({ message: "Failed to report chargeback" });
    }
  });

  // Resolve a chargeback (Admin/Finance only)
  app.post("/api/chargebacks/resolve", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userRole = req.userRole;
      const { chargebackId, status, reason } = req.body;

      if (!chargebackId || !status) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      const validStatuses = ["under_review", "won", "lost", "reversed"];
      if (!validStatuses.includes(status)) {
        return res.status(400).json({ message: "Invalid status" });
      }

      const chargeback = await storage.getChargebackById(chargebackId);
      if (!chargeback) {
        return res.status(404).json({ message: "Chargeback not found" });
      }

      // Update with resolved info
      const updated = await storage.updateChargeback(chargebackId, { status, reason }, userId);

      // Audit log
      await storage.createAuditLog({
        action: `chargeback_${status}`,
        entityType: "chargeback",
        entityId: chargebackId,
        performedByUserId: userId,
        performedByRole: userRole,
        metadata: JSON.stringify({ previousStatus: chargeback.status, newStatus: status, reason }),
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error resolving chargeback:", error);
      return res.status(500).json({ message: "Failed to resolve chargeback" });
    }
  });

  // Get chargebacks with optional status filter
  app.get("/api/chargebacks", isAuthenticated, requireRole(["admin", "finance", "director"]), async (req: any, res) => {
    try {
      const { status } = req.query;
      const chargebacksList = await storage.getFilteredChargebacks({ status: status as string });
      return res.json(chargebacksList);
    } catch (error) {
      console.error("Error getting chargebacks:", error);
      return res.status(500).json({ message: "Failed to get chargebacks" });
    }
  });

  // Get chargeback audit trail
  app.get("/api/chargebacks/:chargebackId/audit", isAuthenticated, requireRole(["admin", "finance", "director"]), async (req: any, res) => {
    try {
      const { chargebackId } = req.params;
      const auditLogs = await storage.getAuditLogsByEntity("chargeback", chargebackId);
      return res.json(auditLogs);
    } catch (error) {
      console.error("Error getting chargeback audit:", error);
      return res.status(500).json({ message: "Failed to get audit logs" });
    }
  });

  // Run reconciliation for a trip (Finance only)
  app.post("/api/reconciliation/run", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userRole = req.userRole;
      const { tripId, actualAmount, provider } = req.body;

      if (!tripId || actualAmount === undefined || !provider) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      const reconciliation = await storage.runReconciliation(tripId, String(actualAmount), provider);

      // Audit log
      await storage.createAuditLog({
        action: "reconciliation_run",
        entityType: "reconciliation",
        entityId: reconciliation.id,
        performedByUserId: userId,
        performedByRole: userRole,
        metadata: JSON.stringify({ tripId, actualAmount, provider, status: reconciliation.status, variance: reconciliation.variance }),
      });

      return res.json(reconciliation);
    } catch (error) {
      console.error("Error running reconciliation:", error);
      return res.status(500).json({ message: "Failed to run reconciliation" });
    }
  });

  // Get reconciliations with optional status filter
  app.get("/api/reconciliation", isAuthenticated, requireRole(["admin", "finance", "director"]), async (req: any, res) => {
    try {
      const { status } = req.query;
      const reconciliations = await storage.getFilteredReconciliations({ status: status as string });
      return res.json(reconciliations);
    } catch (error) {
      console.error("Error getting reconciliations:", error);
      return res.status(500).json({ message: "Failed to get reconciliations" });
    }
  });

  // Mark reconciliation as reviewed (Finance/Admin only)
  app.post("/api/reconciliation/review", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userRole = req.userRole;
      const { reconciliationId, status, notes } = req.body;

      if (!reconciliationId || !status) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      const validStatuses = ["matched", "mismatched"];
      if (!validStatuses.includes(status)) {
        return res.status(400).json({ message: "Invalid status. Must be 'matched' or 'mismatched'" });
      }

      const updated = await storage.updateReconciliation(reconciliationId, status, userId, notes);

      // Audit log
      await storage.createAuditLog({
        action: "reconciliation_reviewed",
        entityType: "reconciliation",
        entityId: reconciliationId,
        performedByUserId: userId,
        performedByRole: userRole,
        metadata: JSON.stringify({ status, notes }),
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error reviewing reconciliation:", error);
      return res.status(500).json({ message: "Failed to review reconciliation" });
    }
  });

  // Trip Coordinator can flag a trip as suspicious (attach chargeback evidence)
  app.post("/api/trips/:tripId/flag", isAuthenticated, requireRole(["admin", "trip_coordinator", "finance"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userRole = req.userRole;
      const { tripId } = req.params;
      const { reason, evidence } = req.body;

      const trip = await storage.getTripById(tripId);
      if (!trip) {
        return res.status(404).json({ message: "Trip not found" });
      }

      // Create an audit log entry for the flag
      await storage.createAuditLog({
        action: "trip_flagged",
        entityType: "trip",
        entityId: tripId,
        performedByUserId: userId,
        performedByRole: userRole,
        metadata: JSON.stringify({ reason, evidence }),
      });

      return res.json({ message: "Trip flagged successfully", tripId });
    } catch (error) {
      console.error("Error flagging trip:", error);
      return res.status(500).json({ message: "Failed to flag trip" });
    }
  });

  // ========== PHASE 11 - WALLET ENDPOINTS ==========

  // Test Credit for Testers - Add funds to wallet (NO REAL PAYMENTS)
  app.post("/api/wallet/test-credit", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userEmail = req.user.claims.email;
      const { amount } = req.body;
      
      // Default to 5000 NGN (stored as cents = 500000)
      const creditAmount = amount ? parseFloat(amount) : 500000;
      
      // Get or create rider wallet
      let riderWallet = await storage.getRiderWallet(userId);
      if (!riderWallet) {
        const currency = await getUserCurrency(userId);
        riderWallet = await storage.createRiderWallet({ userId, currency });
      }
      
      // Credit the wallet
      const updatedWallet = await storage.adjustRiderWalletBalance(userId, creditAmount, "TEST_CREDIT", userId);
      
      // Audit log
      console.log(`[TEST_CREDIT] userId=${userId}, email=${userEmail}, amount=${creditAmount}, timestamp=${new Date().toISOString()}`);
      
      // Log to financial audit
      await storage.createFinancialAuditLog({
        eventType: "ADJUSTMENT",
        userId: userId,
        actorRole: "RIDER",
        amount: creditAmount.toString(),
        currency: "NGN",
        description: `Test wallet credit for ${userEmail}`,
        metadata: JSON.stringify({ creditedBy: "SELF", reason: "TEST_CREDIT" }),
      });
      
      return res.json({
        success: true,
        message: "Test credit added successfully",
        balance: updatedWallet?.balance || creditAmount,
        currency: "NGN",
      });
    } catch (error) {
      console.error("Error adding test credit:", error);
      return res.status(500).json({ message: "Failed to add test credit" });
    }
  });

  // Get current user's wallet
  app.get("/api/wallets/me", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const wallet = await storage.getWalletByUserId(userId);
      
      if (!wallet) {
        return res.json(null);
      }

      const transactions = await storage.getWalletTransactions(wallet.id);
      const payouts = await storage.getWalletPayoutsByWalletId(wallet.id);

      return res.json({
        ...wallet,
        transactions: transactions.slice(0, 20),
        payouts: payouts.slice(0, 10),
      });
    } catch (error) {
      console.error("Error getting wallet:", error);
      return res.status(500).json({ message: "Failed to get wallet" });
    }
  });

  // Get specific user's wallet (admin/finance only)
  app.get("/api/wallets/:userId", isAuthenticated, requireRole(["admin", "finance", "director", "trip_coordinator"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const wallet = await storage.getWalletByUserId(userId);
      
      if (!wallet) {
        return res.status(404).json({ message: "Wallet not found" });
      }

      return res.json(wallet);
    } catch (error) {
      console.error("Error getting user wallet:", error);
      return res.status(500).json({ message: "Failed to get wallet" });
    }
  });

  // Get wallet transactions
  app.get("/api/wallets/:userId/transactions", isAuthenticated, async (req: any, res) => {
    try {
      const requestingUserId = req.user.claims.sub;
      const { userId } = req.params;
      const userRole = await storage.getUserRole(requestingUserId);

      // Users can view their own transactions, admins/finance can view anyone's
      const canView = requestingUserId === userId || 
        (userRole && ["admin", "finance", "director", "trip_coordinator"].includes(userRole.role));
      
      if (!canView) {
        return res.status(403).json({ message: "Access denied" });
      }

      const wallet = await storage.getWalletByUserId(userId);
      if (!wallet) {
        return res.json([]);
      }

      const transactions = await storage.getWalletTransactions(wallet.id);
      return res.json(transactions);
    } catch (error) {
      console.error("Error getting wallet transactions:", error);
      return res.status(500).json({ message: "Failed to get transactions" });
    }
  });

  // Get all driver wallets (admin/finance)
  app.get("/api/admin/wallets", isAuthenticated, requireRole(["admin", "finance", "director", "trip_coordinator"]), async (req: any, res) => {
    try {
      const wallets = await storage.getAllDriverWallets();
      return res.json(wallets);
    } catch (error) {
      console.error("Error getting wallets:", error);
      return res.status(500).json({ message: "Failed to get wallets" });
    }
  });

  // Get ZIBA platform wallet (admin/finance)
  app.get("/api/admin/wallets/ziba", isAuthenticated, requireRole(["admin", "finance", "director"]), async (req: any, res) => {
    try {
      const zibaWallet = await storage.getZibaWallet();
      const transactions = await storage.getWalletTransactions(zibaWallet.id);
      return res.json({
        ...zibaWallet,
        transactions: transactions.slice(0, 50),
      });
    } catch (error) {
      console.error("Error getting ZIBA wallet:", error);
      return res.status(500).json({ message: "Failed to get ZIBA wallet" });
    }
  });

  // ========== PHASE 11 - PAYOUT ENDPOINTS ==========

  // Get all payouts (admin/finance)
  app.get("/api/payouts", isAuthenticated, requireRole(["admin", "finance", "director", "trip_coordinator"]), async (req: any, res) => {
    try {
      const { status } = req.query;
      const payouts = status 
        ? await storage.getFilteredWalletPayouts({ status })
        : await storage.getAllWalletPayouts();
      return res.json(payouts);
    } catch (error) {
      console.error("Error getting payouts:", error);
      return res.status(500).json({ message: "Failed to get payouts" });
    }
  });

  // Get driver's payout history
  app.get("/api/driver/payouts", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const payouts = await storage.getDriverPayoutHistory(userId);
      return res.json(payouts);
    } catch (error) {
      console.error("Error getting driver payouts:", error);
      return res.status(500).json({ message: "Failed to get payout history" });
    }
  });

  // =====================================
  // DRIVER WITHDRAWAL & IDENTITY VERIFICATION ROUTES
  // =====================================

  // Get driver's identity profile
  app.get("/api/driver/identity-profile", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getIdentityProfile(userId);
      const documents = await storage.getIdentityDocuments(userId);
      return res.json({ profile, documents });
    } catch (error) {
      console.error("Error getting identity profile:", error);
      return res.status(500).json({ message: "Failed to get identity profile" });
    }
  });

  // Create or update identity profile
  app.post("/api/driver/identity-profile", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userRole = await storage.getUserRole(userId);
      const { legalFirstName, legalLastName, dateOfBirth, residenceAddressLine1, residenceCity, residenceState, residencePostalCode } = req.body;

      if (!legalFirstName || !legalLastName || !dateOfBirth) {
        return res.status(400).json({ message: "Legal first name, last name, and date of birth are required" });
      }

      const existingProfile = await storage.getIdentityProfile(userId);
      
      const profileData = {
        legalFirstName,
        legalLastName,
        dateOfBirth: new Date(dateOfBirth),
        countryCode: userRole?.countryCode || "NG",
        residenceAddressLine1,
        residenceCity,
        residenceState,
        residencePostalCode,
        residenceCountryCode: userRole?.countryCode || "NG",
      };

      let profile;
      if (existingProfile) {
        profile = await storage.updateIdentityProfile(userId, profileData);
      } else {
        profile = await storage.createIdentityProfile({ userId, ...profileData });
      }

      return res.json(profile);
    } catch (error) {
      console.error("Error updating identity profile:", error);
      return res.status(500).json({ message: "Failed to update identity profile" });
    }
  });

  // Submit identity document
  app.post("/api/driver/identity-document", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userRole = await storage.getUserRole(userId);
      const { documentType, documentNumber, issuingAuthority, expiryDate } = req.body;

      if (!documentType || !documentNumber) {
        return res.status(400).json({ message: "Document type and number are required" });
      }

      // Hash the document number for secure storage
      const documentNumberHash = createHash("sha256").update(documentNumber.trim().toUpperCase()).digest("hex");

      // Check for document reuse across users (anti-fraud)
      const documentExists = await storage.checkDocumentHashExists(documentNumberHash, userId);
      if (documentExists) {
        console.warn(`[FRAUD ALERT] Document hash reuse attempt by user ${userId}`);
        return res.status(400).json({ 
          message: "This document is already registered to another user",
          code: "DOCUMENT_ALREADY_REGISTERED"
        });
      }

      // Check if document of this type already exists for user
      const existingDoc = await storage.getIdentityDocumentByType(userId, documentType);
      if (existingDoc) {
        return res.status(400).json({ 
          message: "You have already submitted a document of this type",
          code: "DOCUMENT_TYPE_EXISTS"
        });
      }

      const document = await storage.createIdentityDocument({
        userId,
        countryCode: userRole?.countryCode || "NG",
        documentType,
        documentNumberHash,
        issuingAuthority,
        expiryDate: expiryDate ? new Date(expiryDate) : undefined,
      });

      return res.json({ message: "Document submitted for verification", document });
    } catch (error) {
      console.error("Error submitting identity document:", error);
      return res.status(500).json({ message: "Failed to submit identity document" });
    }
  });

  // Get driver's withdrawal history
  app.get("/api/driver/withdrawals", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const withdrawals = await storage.getDriverWithdrawals(userId);
      return res.json(withdrawals);
    } catch (error) {
      console.error("Error getting driver withdrawals:", error);
      return res.status(500).json({ message: "Failed to get withdrawal history" });
    }
  });

  // Request withdrawal - with full identity verification
  app.post("/api/driver/withdraw", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userRole = await storage.getUserRole(userId);
      const { amount, payoutMethod } = req.body;

      if (!amount || amount <= 0) {
        return res.status(400).json({ message: "Invalid withdrawal amount" });
      }

      if (!payoutMethod || !["BANK", "MOBILE_MONEY"].includes(payoutMethod)) {
        return res.status(400).json({ message: "Invalid payout method. Use BANK or MOBILE_MONEY" });
      }

      // Get driver profile
      const driverProfile = await storage.getDriverProfile(userId);
      if (!driverProfile) {
        return res.status(400).json({ message: "Driver profile not found" });
      }

      // Check driver verification status
      if (driverProfile.withdrawalVerificationStatus !== "verified") {
        return res.status(403).json({ 
          message: "Your identity is not verified for withdrawals",
          code: "IDENTITY_NOT_VERIFIED",
          currentStatus: driverProfile.withdrawalVerificationStatus
        });
      }

      // Get identity profile
      const identityProfile = await storage.getIdentityProfile(userId);
      if (!identityProfile) {
        return res.status(403).json({ 
          message: "Identity profile required for withdrawal",
          code: "IDENTITY_PROFILE_MISSING"
        });
      }

      // Check identity verification
      if (!identityProfile.identityVerified) {
        return res.status(403).json({ 
          message: "Identity verification required for withdrawal",
          code: "IDENTITY_NOT_VERIFIED"
        });
      }

      // Check address verification
      if (!identityProfile.addressVerified) {
        return res.status(403).json({ 
          message: "Address verification required for withdrawal",
          code: "ADDRESS_NOT_VERIFIED"
        });
      }

      // Get driver wallet
      const wallet = await storage.getDriverWallet(userId);
      if (!wallet) {
        return res.status(400).json({ message: "Driver wallet not found" });
      }

      // Check if tester - testers cannot withdraw real money
      if (userRole?.isTester) {
        return res.status(403).json({ 
          message: "Test drivers cannot withdraw real funds",
          code: "TESTER_WITHDRAWAL_BLOCKED"
        });
      }

      // Get currency from country
      const currencyCode = getCurrencyFromCountry(userRole?.countryCode || "NG");

      // Validate currency matches wallet
      if (wallet.currency !== currencyCode) {
        return res.status(400).json({ 
          message: "Currency mismatch between wallet and country",
          code: "CURRENCY_MISMATCH"
        });
      }

      // Check balance
      const withdrawableBalance = parseFloat(wallet.withdrawableBalance);
      if (amount > withdrawableBalance) {
        return res.status(400).json({ 
          message: `Insufficient withdrawable balance. Available: ${currencyCode} ${withdrawableBalance.toFixed(2)}`,
          code: "INSUFFICIENT_BALANCE"
        });
      }

      // Minimum withdrawal amounts by country
      const minWithdrawals: Record<string, number> = {
        NG: 1000, // 1000 NGN
        US: 10,   // $10 USD
        ZA: 100,  // 100 ZAR
      };
      const minAmount = minWithdrawals[userRole?.countryCode || "NG"] || 1000;
      if (amount < minAmount) {
        return res.status(400).json({ 
          message: `Minimum withdrawal is ${currencyCode} ${minAmount}`,
          code: "BELOW_MINIMUM"
        });
      }

      // Check payout method is configured
      if (payoutMethod === "BANK") {
        if (!wallet.bankName || !wallet.accountNumber) {
          return res.status(400).json({ 
            message: "Bank account details not configured",
            code: "PAYOUT_METHOD_NOT_CONFIGURED"
          });
        }
      } else if (payoutMethod === "MOBILE_MONEY") {
        if (!wallet.mobileMoneyProvider || !wallet.mobileMoneyNumber) {
          return res.status(400).json({ 
            message: "Mobile money details not configured",
            code: "PAYOUT_METHOD_NOT_CONFIGURED"
          });
        }
      }

      // Country-specific document requirements
      const countryCode = userRole?.countryCode || "NG";
      const documents = await storage.getIdentityDocuments(userId);
      const verifiedDocs = documents.filter(d => d.verified);

      if (countryCode === "NG") {
        // Nigeria requires NIN and Driver License
        const hasNIN = verifiedDocs.some(d => d.documentType === "NIN");
        const hasDriverLicense = verifiedDocs.some(d => d.documentType === "DRIVER_LICENSE");
        if (!hasNIN || !hasDriverLicense) {
          return res.status(403).json({ 
            message: "Nigerian drivers require verified NIN and Driver License for withdrawals",
            code: "DOCUMENTS_INCOMPLETE",
            required: ["NIN", "DRIVER_LICENSE"],
            verified: verifiedDocs.map(d => d.documentType)
          });
        }
      } else if (countryCode === "US") {
        // US requires Driver License
        const hasDriverLicense = verifiedDocs.some(d => d.documentType === "DRIVER_LICENSE");
        if (!hasDriverLicense) {
          return res.status(403).json({ 
            message: "US drivers require verified Driver License for withdrawals",
            code: "DOCUMENTS_INCOMPLETE",
            required: ["DRIVER_LICENSE"],
            verified: verifiedDocs.map(d => d.documentType)
          });
        }
      } else {
        // Other countries require at least one verified ID
        if (verifiedDocs.length === 0) {
          return res.status(403).json({ 
            message: "At least one verified identity document required for withdrawals",
            code: "DOCUMENTS_INCOMPLETE"
          });
        }
      }

      // Create withdrawal request
      const withdrawal = await storage.createDriverWithdrawal({
        driverId: userId,
        amount: amount.toString(),
        currencyCode,
        payoutMethod,
      });

      // Log the withdrawal request
      await storage.createAuditLog({
        action: "withdrawal_requested",
        entityType: "driver_withdrawal",
        entityId: withdrawal.id,
        performedByUserId: userId,
        performedByRole: "driver",
        metadata: JSON.stringify({ amount, currencyCode, payoutMethod }),
      });

      return res.json({ 
        message: "Withdrawal request submitted for processing",
        withdrawal 
      });
    } catch (error) {
      console.error("Error processing withdrawal request:", error);
      return res.status(500).json({ message: "Failed to process withdrawal request" });
    }
  });

  // Admin: Get all pending withdrawals
  app.get("/api/admin/withdrawals/pending", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const withdrawals = await storage.getPendingDriverWithdrawals();
      return res.json(withdrawals);
    } catch (error) {
      console.error("Error getting pending withdrawals:", error);
      return res.status(500).json({ message: "Failed to get pending withdrawals" });
    }
  });

  // Admin: Process withdrawal
  app.post("/api/admin/withdrawals/:withdrawalId/process", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { withdrawalId } = req.params;
      const { action, transactionRef, blockReason } = req.body;

      if (!action || !["approve", "reject", "block"].includes(action)) {
        return res.status(400).json({ message: "Invalid action. Use approve, reject, or block" });
      }

      let status: string;
      if (action === "approve") {
        status = "processing";
        // In test mode, mark as paid immediately (simulated)
        status = "paid";
      } else if (action === "reject") {
        status = "failed";
      } else {
        status = "blocked";
      }

      const withdrawal = await storage.updateDriverWithdrawalStatus(
        withdrawalId,
        status,
        adminId,
        action === "block" ? blockReason : undefined
      );

      if (!withdrawal) {
        return res.status(404).json({ message: "Withdrawal not found" });
      }

      // Log the action
      await storage.createAuditLog({
        action: `withdrawal_${action}ed`,
        entityType: "driver_withdrawal",
        entityId: withdrawalId,
        performedByUserId: adminId,
        performedByRole: req.userRole?.role || "admin",
        metadata: JSON.stringify({ action, transactionRef, blockReason }),
      });

      return res.json({ message: `Withdrawal ${action}ed`, withdrawal });
    } catch (error) {
      console.error("Error processing withdrawal:", error);
      return res.status(500).json({ message: "Failed to process withdrawal" });
    }
  });

  // Admin: Verify driver identity document
  app.post("/api/admin/identity-documents/:documentId/verify", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { documentId } = req.params;
      const { verified, rejectionReason } = req.body;

      if (typeof verified !== "boolean") {
        return res.status(400).json({ message: "verified must be a boolean" });
      }

      const document = await storage.verifyIdentityDocument(
        documentId,
        verified,
        "manual",
        !verified ? rejectionReason : undefined
      );

      if (!document) {
        return res.status(404).json({ message: "Document not found" });
      }

      // Log the verification
      await storage.createAuditLog({
        action: verified ? "document_verified" : "document_rejected",
        entityType: "identity_document",
        entityId: documentId,
        performedByUserId: adminId,
        performedByRole: req.userRole?.role || "admin",
        metadata: JSON.stringify({ verified, rejectionReason, documentType: document.documentType }),
      });

      return res.json({ message: verified ? "Document verified" : "Document rejected", document });
    } catch (error) {
      console.error("Error verifying document:", error);
      return res.status(500).json({ message: "Failed to verify document" });
    }
  });

  // Admin: Verify driver identity profile (address + identity)
  app.post("/api/admin/identity-profiles/:userId/verify", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { userId } = req.params;
      const { addressVerified, identityVerified } = req.body;

      const profile = await storage.verifyIdentityProfile(userId, addressVerified, identityVerified);
      if (!profile) {
        return res.status(404).json({ message: "Identity profile not found" });
      }

      // If both verified, update driver withdrawal verification status
      if (addressVerified && identityVerified) {
        await storage.updateDriverWithdrawalVerificationStatus(userId, "verified");
      }

      // Log the verification
      await storage.createAuditLog({
        action: "identity_profile_verified",
        entityType: "identity_profile",
        entityId: profile.id,
        performedByUserId: adminId,
        performedByRole: req.userRole?.role || "admin",
        metadata: JSON.stringify({ addressVerified, identityVerified }),
      });

      return res.json({ message: "Identity profile updated", profile });
    } catch (error) {
      console.error("Error verifying identity profile:", error);
      return res.status(500).json({ message: "Failed to verify identity profile" });
    }
  });

  // Admin: Update driver withdrawal verification status
  app.patch("/api/admin/drivers/:userId/withdrawal-status", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { userId } = req.params;
      const { status } = req.body;

      if (!status || !["pending_verification", "verified", "suspended"].includes(status)) {
        return res.status(400).json({ message: "Invalid status. Use pending_verification, verified, or suspended" });
      }

      const profile = await storage.updateDriverWithdrawalVerificationStatus(userId, status);
      if (!profile) {
        return res.status(404).json({ message: "Driver profile not found" });
      }

      // Log the status change
      await storage.createAuditLog({
        action: "driver_withdrawal_status_changed",
        entityType: "driver_profile",
        entityId: profile.id,
        performedByUserId: adminId,
        performedByRole: req.userRole?.role || "admin",
        metadata: JSON.stringify({ newStatus: status }),
      });

      return res.json({ message: "Driver withdrawal status updated", profile });
    } catch (error) {
      console.error("Error updating driver withdrawal status:", error);
      return res.status(500).json({ message: "Failed to update driver withdrawal status" });
    }
  });

  // Initiate a payout (finance/admin only)
  app.post("/api/payouts/initiate", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userRole = req.userRole;
      const { walletId, amount, method, periodStart, periodEnd } = req.body;

      if (!walletId || !amount || !periodStart || !periodEnd) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      const wallet = await storage.getWalletById(walletId);
      if (!wallet) {
        return res.status(404).json({ message: "Wallet not found" });
      }

      const availableBalance = parseFloat(wallet.balance) - parseFloat(wallet.lockedBalance);
      const payoutAmount = parseFloat(amount);

      if (payoutAmount > availableBalance) {
        return res.status(400).json({ message: "Insufficient available balance" });
      }

      // Hold the balance
      const held = await storage.holdWalletBalance(walletId, amount);
      if (!held) {
        return res.status(400).json({ message: "Failed to hold balance" });
      }

      const payout = await storage.createWalletPayout({
        walletId,
        amount,
        method: method || "bank",
        initiatedByUserId: userId,
        periodStart: new Date(periodStart),
        periodEnd: new Date(periodEnd),
      });

      // Audit log
      await storage.createAuditLog({
        action: "payout_initiated",
        entityType: "wallet_payout",
        entityId: payout.id,
        performedByUserId: userId,
        performedByRole: userRole,
        metadata: JSON.stringify({ walletId, amount, method }),
      });

      return res.json(payout);
    } catch (error) {
      console.error("Error initiating payout:", error);
      return res.status(500).json({ message: "Failed to initiate payout" });
    }
  });

  // Process a payout (finance only)
  app.post("/api/payouts/process", isAuthenticated, requireRole(["finance"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userRole = req.userRole;
      const { payoutId } = req.body;

      if (!payoutId) {
        return res.status(400).json({ message: "Missing payout ID" });
      }

      const payout = await storage.getWalletPayoutById(payoutId);
      if (!payout) {
        return res.status(404).json({ message: "Payout not found" });
      }

      if (payout.status !== "pending") {
        // First move to processing
        const updated = await storage.reverseWalletPayout(payoutId, "Processing");
        if (!updated) {
          return res.status(400).json({ message: "Cannot process this payout" });
        }
      }

      // Mark as processing first
      const processingPayout = await storage.getWalletPayoutById(payoutId);
      if (processingPayout?.status === "pending") {
        // Update to processing status manually for now
      }

      const processed = await storage.processWalletPayout(payoutId, userId);
      if (!processed) {
        return res.status(400).json({ message: "Failed to process payout" });
      }

      // Audit log
      await storage.createAuditLog({
        action: "payout_processed",
        entityType: "wallet_payout",
        entityId: payoutId,
        performedByUserId: userId,
        performedByRole: userRole,
        metadata: JSON.stringify({ status: "paid" }),
      });

      // Notify driver
      const wallet = await storage.getWalletById(payout.walletId);
      if (wallet) {
        await storage.createNotification({
          userId: wallet.userId,
          role: "driver",
          title: "Payout Processed",
          message: `Your payout of ${(parseFloat(String(payout.amount)) / 100).toFixed(2)} has been processed successfully.`,
          type: "success",
        });
      }

      return res.json(processed);
    } catch (error) {
      console.error("Error processing payout:", error);
      return res.status(500).json({ message: "Failed to process payout" });
    }
  });

  // Reverse a payout (admin only)
  app.post("/api/payouts/reverse", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userRole = req.userRole;
      const { payoutId, reason } = req.body;

      if (!payoutId || !reason) {
        return res.status(400).json({ message: "Missing payout ID or reason" });
      }

      const payout = await storage.getWalletPayoutById(payoutId);
      if (!payout) {
        return res.status(404).json({ message: "Payout not found" });
      }

      const reversed = await storage.reverseWalletPayout(payoutId, reason);
      if (!reversed) {
        return res.status(400).json({ message: "Failed to reverse payout" });
      }

      // Audit log
      await storage.createAuditLog({
        action: "payout_reversed",
        entityType: "wallet_payout",
        entityId: payoutId,
        performedByUserId: userId,
        performedByRole: userRole,
        metadata: JSON.stringify({ reason }),
      });

      // Notify driver
      const wallet = await storage.getWalletById(payout.walletId);
      if (wallet) {
        await storage.createNotification({
          userId: wallet.userId,
          role: "driver",
          title: "Payout Reversed",
          message: `Your payout of ${(parseFloat(String(payout.amount)) / 100).toFixed(2)} has been reversed. Reason: ${reason}`,
          type: "warning",
        });
      }

      return res.json(reversed);
    } catch (error) {
      console.error("Error reversing payout:", error);
      return res.status(500).json({ message: "Failed to reverse payout" });
    }
  });

  // Phase 12 - Analytics API Routes
  const parseAnalyticsDateRange = (range?: string): { startDate?: Date; endDate?: Date } => {
    const now = new Date();
    const endDate = new Date(now);
    endDate.setHours(23, 59, 59, 999);
    
    if (!range || range === "all") {
      return {};
    }
    
    let startDate = new Date(now);
    startDate.setHours(0, 0, 0, 0);
    
    switch (range) {
      case "today":
        break;
      case "7d":
        startDate.setDate(startDate.getDate() - 7);
        break;
      case "30d":
        startDate.setDate(startDate.getDate() - 30);
        break;
      case "90d":
        startDate.setDate(startDate.getDate() - 90);
        break;
      default:
        // Custom range: expect startDate,endDate format
        if (range.includes(",")) {
          const [start, end] = range.split(",");
          return { 
            startDate: new Date(start), 
            endDate: new Date(end) 
          };
        }
        return {};
    }
    
    return { startDate, endDate };
  };

  app.get("/api/analytics/overview", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const { range } = req.query;
      const { startDate, endDate } = parseAnalyticsDateRange(range as string);
      const overview = await storage.getAnalyticsOverview(startDate, endDate);
      return res.json(overview);
    } catch (error) {
      console.error("Error fetching analytics overview:", error);
      return res.status(500).json({ message: "Failed to fetch analytics overview" });
    }
  });

  app.get("/api/analytics/trips", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const { range } = req.query;
      const { startDate, endDate } = parseAnalyticsDateRange(range as string);
      const data = await storage.getTripsAnalytics(startDate, endDate);
      return res.json(data);
    } catch (error) {
      console.error("Error fetching trips analytics:", error);
      return res.status(500).json({ message: "Failed to fetch trips analytics" });
    }
  });

  app.get("/api/analytics/revenue", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const { range } = req.query;
      const { startDate, endDate } = parseAnalyticsDateRange(range as string);
      const data = await storage.getRevenueAnalytics(startDate, endDate);
      return res.json(data);
    } catch (error) {
      console.error("Error fetching revenue analytics:", error);
      return res.status(500).json({ message: "Failed to fetch revenue analytics" });
    }
  });

  app.get("/api/analytics/refunds", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const { range } = req.query;
      const { startDate, endDate } = parseAnalyticsDateRange(range as string);
      const data = await storage.getRefundsAnalytics(startDate, endDate);
      return res.json(data);
    } catch (error) {
      console.error("Error fetching refunds analytics:", error);
      return res.status(500).json({ message: "Failed to fetch refunds analytics" });
    }
  });

  app.get("/api/analytics/payouts", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const { range } = req.query;
      const { startDate, endDate } = parseAnalyticsDateRange(range as string);
      const data = await storage.getPayoutsAnalytics(startDate, endDate);
      return res.json(data);
    } catch (error) {
      console.error("Error fetching payouts analytics:", error);
      return res.status(500).json({ message: "Failed to fetch payouts analytics" });
    }
  });

  app.get("/api/analytics/reconciliation", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const { range } = req.query;
      const { startDate, endDate } = parseAnalyticsDateRange(range as string);
      const data = await storage.getReconciliationAnalytics(startDate, endDate);
      return res.json(data);
    } catch (error) {
      console.error("Error fetching reconciliation analytics:", error);
      return res.status(500).json({ message: "Failed to fetch reconciliation analytics" });
    }
  });

  // CSV Export endpoint
  app.get("/api/reports/export", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const { type, range, format } = req.query;
      const { startDate, endDate } = parseAnalyticsDateRange(range as string);
      
      let data: any[];
      let filename: string;
      
      switch (type) {
        case "trips":
          data = await storage.getTripsAnalytics(startDate, endDate);
          filename = "trips_report";
          break;
        case "revenue":
          data = await storage.getRevenueAnalytics(startDate, endDate);
          filename = "revenue_report";
          break;
        case "refunds":
          data = await storage.getRefundsAnalytics(startDate, endDate);
          filename = "refunds_report";
          break;
        case "payouts":
          data = await storage.getPayoutsAnalytics(startDate, endDate);
          filename = "payouts_report";
          break;
        default:
          const overview = await storage.getAnalyticsOverview(startDate, endDate);
          data = [overview];
          filename = "overview_report";
      }
      
      if (format === "csv") {
        if (data.length === 0) {
          return res.status(200).send("No data available for export");
        }
        
        const headers = Object.keys(data[0]);
        const csvRows = [
          headers.join(","),
          ...data.map(row => 
            headers.map(header => {
              const value = row[header];
              if (typeof value === "object") {
                return JSON.stringify(value).replace(/,/g, ";");
              }
              return String(value ?? "").replace(/,/g, ";");
            }).join(",")
          )
        ];
        
        res.setHeader("Content-Type", "text/csv");
        res.setHeader("Content-Disposition", `attachment; filename="${filename}_${new Date().toISOString().split("T")[0]}.csv"`);
        return res.send(csvRows.join("\n"));
      }
      
      // Default: return JSON
      return res.json({ data, filename, generatedAt: new Date().toISOString() });
    } catch (error) {
      console.error("Error generating report:", error);
      return res.status(500).json({ message: "Failed to generate report" });
    }
  });

  // Phase 13 - Fraud Detection Routes
  app.get("/api/fraud/overview", isAuthenticated, requireRole(["admin", "finance", "trip_coordinator"]), async (req: any, res) => {
    try {
      const overview = await storage.getFraudOverview();
      return res.json(overview);
    } catch (error) {
      console.error("Error fetching fraud overview:", error);
      return res.status(500).json({ message: "Failed to fetch fraud overview" });
    }
  });

  app.get("/api/fraud/users", isAuthenticated, requireRole(["admin", "finance", "trip_coordinator"]), async (req: any, res) => {
    try {
      const { level } = req.query;
      let profiles;
      if (level) {
        profiles = await storage.getRiskProfilesByLevel(level as string);
      } else {
        profiles = await storage.getAllRiskProfiles();
      }
      return res.json(profiles);
    } catch (error) {
      console.error("Error fetching fraud users:", error);
      return res.status(500).json({ message: "Failed to fetch fraud users" });
    }
  });

  app.get("/api/fraud/events", isAuthenticated, requireRole(["admin", "finance", "trip_coordinator"]), async (req: any, res) => {
    try {
      const { severity, unresolved } = req.query;
      let events;
      if (unresolved === "true") {
        events = await storage.getUnresolvedFraudEvents();
      } else if (severity) {
        events = await storage.getFraudEventsBySeverity(severity as string);
      } else {
        events = await storage.getAllFraudEvents();
      }
      return res.json(events);
    } catch (error) {
      console.error("Error fetching fraud events:", error);
      return res.status(500).json({ message: "Failed to fetch fraud events" });
    }
  });

  app.post("/api/fraud/evaluate", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const { userId, role } = req.body;
      
      if (userId && role) {
        const { evaluateUserRisk, evaluateAndRecordFraudEvents } = await import("./fraud");
        await evaluateAndRecordFraudEvents(userId, role, "Manual evaluation by admin");
        const result = await evaluateUserRisk(userId, role);
        
        await storage.createAuditLog({
          action: "fraud_evaluation",
          entityType: "user",
          entityId: userId,
          performedByUserId: req.user.id,
          performedByRole: "admin",
          metadata: JSON.stringify({ role, result }),
        });
        
        return res.json({ success: true, result });
      } else {
        const { runFullEvaluation } = await import("./fraud");
        const result = await runFullEvaluation();
        
        await storage.createAuditLog({
          action: "fraud_full_evaluation",
          entityType: "system",
          entityId: "fraud-evaluation",
          performedByUserId: req.user.id,
          performedByRole: "admin",
          metadata: JSON.stringify(result),
        });
        
        return res.json({ success: true, ...result });
      }
    } catch (error) {
      console.error("Error running fraud evaluation:", error);
      return res.status(500).json({ message: "Failed to run fraud evaluation" });
    }
  });

  app.post("/api/fraud/resolve/:eventId", isAuthenticated, requireRole(["admin", "trip_coordinator"]), async (req: any, res) => {
    try {
      const { eventId } = req.params;
      const event = await storage.getFraudEventById(eventId);
      if (!event) {
        return res.status(404).json({ message: "Fraud event not found" });
      }
      if (event.resolvedAt) {
        return res.status(400).json({ message: "Fraud event already resolved" });
      }
      
      const updated = await storage.resolveFraudEvent(eventId, req.user.id);
      
      await storage.createAuditLog({
        action: "fraud_event_resolved",
        entityType: "fraud_event",
        entityId: eventId,
        performedByUserId: req.user.id,
        performedByRole: req.user.role,
        metadata: JSON.stringify({ signalType: event.signalType, entityId: event.entityId }),
      });
      
      return res.json(updated);
    } catch (error) {
      console.error("Error resolving fraud event:", error);
      return res.status(500).json({ message: "Failed to resolve fraud event" });
    }
  });

  app.get("/api/fraud/user/:userId", isAuthenticated, requireRole(["admin", "finance", "trip_coordinator"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const profile = await storage.getRiskProfile(userId);
      const events = await storage.getFraudEventsByEntityId(userId);
      return res.json({ profile, events });
    } catch (error) {
      console.error("Error fetching user fraud data:", error);
      return res.status(500).json({ message: "Failed to fetch user fraud data" });
    }
  });

  // Phase 14 - Incentive Program Routes
  app.get("/api/incentives/stats", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const stats = await storage.getIncentiveStats();
      return res.json(stats);
    } catch (error) {
      console.error("Error fetching incentive stats:", error);
      return res.status(500).json({ message: "Failed to fetch incentive stats" });
    }
  });

  app.get("/api/incentives/active", isAuthenticated, async (req: any, res) => {
    try {
      const programs = await storage.getActiveIncentivePrograms();
      return res.json(programs);
    } catch (error) {
      console.error("Error fetching active incentives:", error);
      return res.status(500).json({ message: "Failed to fetch active incentives" });
    }
  });

  app.get("/api/incentives/programs", isAuthenticated, requireRole(["admin", "finance", "trip_coordinator"]), async (req: any, res) => {
    try {
      const programs = await storage.getAllIncentivePrograms();
      return res.json(programs);
    } catch (error) {
      console.error("Error fetching incentive programs:", error);
      return res.status(500).json({ message: "Failed to fetch incentive programs" });
    }
  });

  app.get("/api/incentives/earnings", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const earnings = await storage.getAllIncentiveEarnings();
      return res.json(earnings);
    } catch (error) {
      console.error("Error fetching incentive earnings:", error);
      return res.status(500).json({ message: "Failed to fetch incentive earnings" });
    }
  });

  app.get("/api/incentives/driver/:driverId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { driverId } = req.params;
      const userRole = await storage.getUserRole(userId);
      
      if (userId !== driverId && !["admin", "finance", "trip_coordinator"].includes(userRole?.role || "")) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const earnings = await storage.getDriverIncentiveEarnings(driverId);
      return res.json(earnings);
    } catch (error) {
      console.error("Error fetching driver incentives:", error);
      return res.status(500).json({ message: "Failed to fetch driver incentives" });
    }
  });

  // Driver's own incentive earnings
  app.get("/api/incentives/earnings/mine", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getDriverProfile(userId);
      
      if (!profile) {
        return res.json([]);
      }
      
      const earnings = await storage.getDriverIncentiveEarnings(profile.userId);
      return res.json(earnings);
    } catch (error) {
      console.error("Error fetching own incentive earnings:", error);
      return res.status(500).json({ message: "Failed to fetch incentive earnings" });
    }
  });

  app.post("/api/incentives/create", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const parsed = insertIncentiveProgramSchema.safeParse({ ...req.body, createdByUserId: userId });
      
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid incentive program data", errors: parsed.error.errors });
      }

      const program = await storage.createIncentiveProgram(parsed.data);

      await storage.createAuditLog({
        action: "incentive_program_created",
        entityType: "incentive_program",
        entityId: program.id,
        performedByUserId: userId,
        performedByRole: "admin",
        metadata: JSON.stringify({ name: program.name, type: program.type, rewardAmount: program.rewardAmount })
      });

      return res.json(program);
    } catch (error) {
      console.error("Error creating incentive program:", error);
      return res.status(500).json({ message: "Failed to create incentive program" });
    }
  });

  app.post("/api/incentives/update/:programId", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { programId } = req.params;
      
      const program = await storage.updateIncentiveProgram(programId, req.body);
      if (!program) {
        return res.status(404).json({ message: "Program not found" });
      }

      await storage.createAuditLog({
        action: "incentive_program_updated",
        entityType: "incentive_program",
        entityId: programId,
        performedByUserId: userId,
        performedByRole: "admin",
        metadata: JSON.stringify(req.body)
      });

      return res.json(program);
    } catch (error) {
      console.error("Error updating incentive program:", error);
      return res.status(500).json({ message: "Failed to update incentive program" });
    }
  });

  app.post("/api/incentives/pause/:programId", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { programId } = req.params;
      
      const program = await storage.pauseIncentiveProgram(programId);
      if (!program) {
        return res.status(404).json({ message: "Program not found" });
      }

      await storage.createAuditLog({
        action: "incentive_program_paused",
        entityType: "incentive_program",
        entityId: programId,
        performedByUserId: userId,
        performedByRole: "admin",
        metadata: JSON.stringify({ previousStatus: "active" })
      });

      return res.json(program);
    } catch (error) {
      console.error("Error pausing incentive program:", error);
      return res.status(500).json({ message: "Failed to pause incentive program" });
    }
  });

  app.post("/api/incentives/end/:programId", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { programId } = req.params;
      
      const program = await storage.endIncentiveProgram(programId);
      if (!program) {
        return res.status(404).json({ message: "Program not found" });
      }

      await storage.createAuditLog({
        action: "incentive_program_ended",
        entityType: "incentive_program",
        entityId: programId,
        performedByUserId: userId,
        performedByRole: "admin",
        metadata: JSON.stringify({ previousStatus: program.status })
      });

      return res.json(program);
    } catch (error) {
      console.error("Error ending incentive program:", error);
      return res.status(500).json({ message: "Failed to end incentive program" });
    }
  });

  app.post("/api/incentives/evaluate", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const { driverId } = req.body;
      
      if (driverId) {
        const result = await evaluateDriverForIncentives(driverId);
        return res.json(result);
      } else {
        const result = await evaluateAllDrivers();
        return res.json(result);
      }
    } catch (error) {
      console.error("Error evaluating incentives:", error);
      return res.status(500).json({ message: "Failed to evaluate incentives" });
    }
  });

  app.post("/api/incentives/approve/:earningId", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { earningId } = req.params;
      
      const result = await approveAndPayIncentive(earningId, userId);
      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true });
    } catch (error) {
      console.error("Error approving incentive:", error);
      return res.status(500).json({ message: "Failed to approve incentive" });
    }
  });

  app.post("/api/incentives/revoke/:earningId", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { earningId } = req.params;
      const { reason } = req.body;

      if (!reason) {
        return res.status(400).json({ message: "Revocation reason is required" });
      }
      
      const result = await revokeIncentive(earningId, userId, reason);
      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true });
    } catch (error) {
      console.error("Error revoking incentive:", error);
      return res.status(500).json({ message: "Failed to revoke incentive" });
    }
  });

  // ========================================
  // Phase 5 - Rider Promos Routes
  // ========================================

  app.get("/api/promos/mine", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const promos = await storage.getActiveRiderPromos(userId);
      return res.json(promos);
    } catch (error) {
      console.error("Error fetching rider promos:", error);
      return res.status(500).json({ message: "Failed to fetch promos" });
    }
  });

  app.get("/api/promos/history", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const promos = await storage.getRiderPromosByRider(userId);
      return res.json(promos);
    } catch (error) {
      console.error("Error fetching promo history:", error);
      return res.status(500).json({ message: "Failed to fetch promo history" });
    }
  });

  app.post("/api/promos/apply", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { promoCode, tripId } = req.body;
      if (!promoCode || !tripId) {
        return res.status(400).json({ message: "Promo code and trip ID are required" });
      }
      const result = await applyPromoToTrip(userId, promoCode, tripId);
      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }
      return res.json(result);
    } catch (error) {
      console.error("Error applying promo:", error);
      return res.status(500).json({ message: "Failed to apply promo" });
    }
  });

  app.post("/api/promos/assign-first-ride", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { currency } = req.body;
      const result = await assignFirstRidePromo(userId, currency || "USD");
      return res.json(result);
    } catch (error) {
      console.error("Error assigning first ride promo:", error);
      return res.status(500).json({ message: "Failed to assign promo" });
    }
  });

  app.get("/api/promos/all", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const promos = await storage.getAllRiderPromos();
      return res.json(promos);
    } catch (error) {
      console.error("Error fetching all promos:", error);
      return res.status(500).json({ message: "Failed to fetch promos" });
    }
  });

  app.post("/api/promos/void/:promoId", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { promoId } = req.params;
      const result = await storage.voidRiderPromo(promoId);
      if (!result) {
        return res.status(404).json({ message: "Promo not found" });
      }
      await storage.createAuditLog({
        action: "promo_voided",
        entityType: "rider_promo",
        entityId: promoId,
        performedByUserId: req.user.claims.sub,
        performedByRole: "admin",
        metadata: JSON.stringify({ promoId })
      });
      return res.json({ success: true });
    } catch (error) {
      console.error("Error voiding promo:", error);
      return res.status(500).json({ message: "Failed to void promo" });
    }
  });

  // ========================================
  // Phase 5 - Behavior Stats Routes
  // ========================================

  app.get("/api/behavior/mine", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const stats = await storage.getBehaviorStats(userId);
      return res.json(stats || null);
    } catch (error) {
      console.error("Error fetching behavior stats:", error);
      return res.status(500).json({ message: "Failed to fetch behavior stats" });
    }
  });

  app.get("/api/behavior/user/:userId", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const stats = await storage.getBehaviorStats(userId);
      return res.json(stats || null);
    } catch (error) {
      console.error("Error fetching user behavior stats:", error);
      return res.status(500).json({ message: "Failed to fetch behavior stats" });
    }
  });

  app.get("/api/behavior/all", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const stats = await storage.getAllBehaviorStats();
      return res.json(stats);
    } catch (error) {
      console.error("Error fetching all behavior stats:", error);
      return res.status(500).json({ message: "Failed to fetch behavior stats" });
    }
  });

  app.post("/api/behavior/evaluate", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { userId, role } = req.body;
      if (!userId || !role) {
        return res.status(400).json({ message: "User ID and role are required" });
      }
      const result = await evaluateBehaviorAndWarnings(userId, role);
      return res.json(result);
    } catch (error) {
      console.error("Error evaluating behavior:", error);
      return res.status(500).json({ message: "Failed to evaluate behavior" });
    }
  });

  // ========================================
  // Phase 5 - Driver Matching & Incentive Progress
  // ========================================

  app.get("/api/incentives/progress", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const progress = await getDriverIncentiveProgress(userId);
      return res.json(progress);
    } catch (error) {
      console.error("Error fetching incentive progress:", error);
      return res.status(500).json({ message: "Failed to fetch incentive progress" });
    }
  });

  app.get("/api/matching/score/:driverId", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { driverId } = req.params;
      const lat = req.query.lat ? parseFloat(req.query.lat) : undefined;
      const lng = req.query.lng ? parseFloat(req.query.lng) : undefined;
      const riderLocation = lat && lng ? { lat, lng } : undefined;
      const score = await calculateDriverMatchingScore(driverId, riderLocation);
      return res.json(score);
    } catch (error) {
      console.error("Error calculating matching score:", error);
      return res.status(500).json({ message: "Failed to calculate matching score" });
    }
  });

  app.post("/api/incentives/pause-all", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const activePrograms = await storage.getActiveIncentivePrograms();
      let paused = 0;
      for (const program of activePrograms) {
        await storage.pauseIncentiveProgram(program.id);
        paused++;
      }
      await storage.createAuditLog({
        action: "incentives_paused_all",
        entityType: "incentive_program",
        entityId: "system",
        performedByUserId: userId,
        performedByRole: "admin",
        metadata: JSON.stringify({ pausedCount: paused })
      });
      return res.json({ success: true, paused });
    } catch (error) {
      console.error("Error pausing all incentives:", error);
      return res.status(500).json({ message: "Failed to pause incentives" });
    }
  });

  // ========================================
  // Phase 14.5 - Trip Coordinator Routes
  // ========================================

  // Get trip coordinator profile
  app.get("/api/coordinator/profile", isAuthenticated, requireRole(["trip_coordinator"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getTripCoordinatorProfile(userId);
      return res.json(profile || null);
    } catch (error) {
      console.error("Error fetching coordinator profile:", error);
      return res.status(500).json({ message: "Failed to fetch profile" });
    }
  });

  // Create/update trip coordinator profile
  app.post("/api/coordinator/profile", isAuthenticated, requireRole(["trip_coordinator"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { organizationName, organizationType, contactEmail, contactPhone } = req.body;

      if (!organizationName || !organizationType || !contactEmail) {
        return res.status(400).json({ message: "Organization name, type, and contact email are required" });
      }

      const existing = await storage.getTripCoordinatorProfile(userId);
      if (existing) {
        return res.status(400).json({ message: "Profile already exists" });
      }

      const profile = await storage.createTripCoordinatorProfile({
        userId,
        organizationName,
        organizationType,
        contactEmail,
        contactPhone: contactPhone || null
      });

      await storage.createAuditLog({
        action: "coordinator_profile_created",
        entityType: "trip_coordinator_profile",
        entityId: profile.id,
        performedByUserId: userId,
        performedByRole: "trip_coordinator",
        metadata: JSON.stringify({ organizationName, organizationType })
      });

      return res.json(profile);
    } catch (error) {
      console.error("Error creating coordinator profile:", error);
      return res.status(500).json({ message: "Failed to create profile" });
    }
  });

  // Get coordinator's trips
  app.get("/api/coordinator/trips", isAuthenticated, requireRole(["trip_coordinator"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { status, startDate, endDate } = req.query;
      
      const filter: any = {};
      if (status) filter.status = status as string;
      if (startDate) filter.startDate = startDate as string;
      if (endDate) filter.endDate = endDate as string;

      const trips = await storage.getCoordinatorTrips(userId, filter);
      return res.json(trips);
    } catch (error) {
      console.error("Error fetching coordinator trips:", error);
      return res.status(500).json({ message: "Failed to fetch trips" });
    }
  });

  // Get coordinator trip statistics
  app.get("/api/coordinator/stats", isAuthenticated, requireRole(["trip_coordinator"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const stats = await storage.getCoordinatorTripStats(userId);
      return res.json(stats);
    } catch (error) {
      console.error("Error fetching coordinator stats:", error);
      return res.status(500).json({ message: "Failed to fetch stats" });
    }
  });

  // Create trip as coordinator (booking for third party)
  app.post("/api/coordinator/trips", isAuthenticated, requireRole(["trip_coordinator"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { pickupLocation, dropoffLocation, passengerCount, passengerName, passengerContact, notesForDriver } = req.body;

      if (!pickupLocation || !dropoffLocation) {
        return res.status(400).json({ message: "Pickup and dropoff locations are required" });
      }

      if (!passengerName) {
        return res.status(400).json({ message: "Passenger name is required for third-party bookings" });
      }

      const profile = await storage.getTripCoordinatorProfile(userId);
      if (!profile) {
        return res.status(400).json({ message: "Please complete your organization profile first" });
      }

      const trip = await storage.createTrip({
        riderId: userId,
        pickupLocation,
        dropoffLocation,
        passengerCount: passengerCount || 1,
        bookedForType: "third_party",
        passengerName,
        passengerContact: passengerContact || null,
        notesForDriver: notesForDriver || null
      });

      await storage.createAuditLog({
        action: "coordinator_trip_created",
        entityType: "trip",
        entityId: trip.id,
        performedByUserId: userId,
        performedByRole: "trip_coordinator",
        metadata: JSON.stringify({ passengerName, organizationName: profile.organizationName })
      });

      // Notify available drivers
      await storage.notifyAllDrivers(
        "New Trip Available",
        `Pickup: ${pickupLocation}  ${dropoffLocation}`,
        "info"
      );

      return res.json(trip);
    } catch (error) {
      console.error("Error creating coordinator trip:", error);
      return res.status(500).json({ message: "Failed to create trip" });
    }
  });

  // Get receipt for a completed trip
  app.get("/api/coordinator/receipts/:tripId", isAuthenticated, requireRole(["trip_coordinator"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { tripId } = req.params;

      const trip = await storage.getTripById(tripId);
      if (!trip) {
        return res.status(404).json({ message: "Trip not found" });
      }

      // Ensure the coordinator owns this trip
      if (trip.riderId !== userId) {
        return res.status(403).json({ message: "Access denied" });
      }

      if (trip.status !== "completed") {
        return res.status(400).json({ message: "Receipt only available for completed trips" });
      }

      const profile = await storage.getTripCoordinatorProfile(userId);

      return res.json({
        tripId: trip.id,
        organizationName: profile?.organizationName || "Unknown Organization",
        passengerName: trip.passengerName || "N/A",
        pickupLocation: trip.pickupLocation,
        dropoffLocation: trip.dropoffLocation,
        passengerCount: trip.passengerCount,
        fareAmount: trip.fareAmount,
        driverPayout: trip.driverPayout,
        commissionAmount: trip.commissionAmount,
        completedAt: trip.completedAt,
        createdAt: trip.createdAt
      });
    } catch (error) {
      console.error("Error fetching receipt:", error);
      return res.status(500).json({ message: "Failed to fetch receipt" });
    }
  });

  // Coordinator can submit disputes for their trips
  app.post("/api/coordinator/disputes", isAuthenticated, requireRole(["trip_coordinator"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { tripId, category, description } = req.body;

      if (!tripId || !category || !description) {
        return res.status(400).json({ message: "Trip ID, category, and description are required" });
      }

      const trip = await storage.getTripById(tripId);
      if (!trip) {
        return res.status(404).json({ message: "Trip not found" });
      }

      // Ensure the coordinator owns this trip
      if (trip.riderId !== userId) {
        return res.status(403).json({ message: "You can only submit disputes for your own trips" });
      }

      // Check if dispute already exists
      const existingDispute = await storage.getDisputeByTripAndUser(tripId, userId);
      if (existingDispute) {
        return res.status(400).json({ message: "A dispute already exists for this trip" });
      }

      const dispute = await storage.createDispute({
        tripId,
        raisedByRole: "rider", // Coordinators are treated as riders
        raisedById: userId,
        againstUserId: trip.driverId || "",
        category,
        description
      });

      await storage.createAuditLog({
        action: "coordinator_dispute_created",
        entityType: "dispute",
        entityId: dispute.id,
        performedByUserId: userId,
        performedByRole: "trip_coordinator",
        metadata: JSON.stringify({ tripId, category })
      });

      // Notify admins
      await storage.notifyAdminsAndDirectors(
        "New Dispute Submitted",
        `A trip coordinator has raised a dispute for trip ${tripId}`,
        "warning"
      );

      return res.json(dispute);
    } catch (error) {
      console.error("Error creating coordinator dispute:", error);
      return res.status(500).json({ message: "Failed to create dispute" });
    }
  });

  // Get coordinator's disputes
  app.get("/api/coordinator/disputes", isAuthenticated, requireRole(["trip_coordinator"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      // Get all disputes raised by this coordinator
      const allDisputes = await storage.getAllDisputes();
      const coordinatorDisputes = allDisputes.filter(d => d.raisedById === userId);
      
      return res.json(coordinatorDisputes);
    } catch (error) {
      console.error("Error fetching coordinator disputes:", error);
      return res.status(500).json({ message: "Failed to fetch disputes" });
    }
  });

  // Coordinator can rate drivers
  app.post("/api/coordinator/ratings", isAuthenticated, requireRole(["trip_coordinator"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { tripId, score, comment } = req.body;

      if (!tripId || score === undefined) {
        return res.status(400).json({ message: "Trip ID and score are required" });
      }

      if (score < 1 || score > 5) {
        return res.status(400).json({ message: "Score must be between 1 and 5" });
      }

      const trip = await storage.getTripById(tripId);
      if (!trip) {
        return res.status(404).json({ message: "Trip not found" });
      }

      if (trip.riderId !== userId) {
        return res.status(403).json({ message: "You can only rate trips you booked" });
      }

      if (trip.status !== "completed") {
        return res.status(400).json({ message: "Can only rate completed trips" });
      }

      if (!trip.driverId) {
        return res.status(400).json({ message: "No driver assigned to this trip" });
      }

      // Check if already rated
      const existingRating = await storage.getRatingByTripAndRater(tripId, userId);
      if (existingRating) {
        return res.status(400).json({ message: "You have already rated this trip" });
      }

      const rating = await storage.createRating({
        tripId,
        raterRole: "rider",
        raterId: userId,
        targetUserId: trip.driverId,
        score,
        comment: comment || null
      });

      // Update driver's average rating
      await storage.updateUserAverageRating(trip.driverId, "driver");

      return res.json(rating);
    } catch (error) {
      console.error("Error creating rating:", error);
      return res.status(500).json({ message: "Failed to create rating" });
    }
  });

  // Cancel a coordinator trip
  app.post("/api/coordinator/trips/:tripId/cancel", isAuthenticated, requireRole(["trip_coordinator"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { tripId } = req.params;
      const { reason } = req.body;

      const trip = await storage.getTripById(tripId);
      if (!trip) {
        return res.status(404).json({ message: "Trip not found" });
      }

      if (trip.riderId !== userId) {
        return res.status(403).json({ message: "You can only cancel your own trips" });
      }

      if (trip.status === "completed" || trip.status === "cancelled") {
        return res.status(400).json({ message: "Cannot cancel this trip" });
      }

      const cancelledTrip = await storage.cancelTrip(tripId, userId, reason || "Cancelled by coordinator");

      await storage.createAuditLog({
        action: "coordinator_trip_cancelled",
        entityType: "trip",
        entityId: tripId,
        performedByUserId: userId,
        performedByRole: "trip_coordinator",
        metadata: JSON.stringify({ reason })
      });

      return res.json(cancelledTrip);
    } catch (error) {
      console.error("Error cancelling coordinator trip:", error);
      return res.status(500).json({ message: "Failed to cancel trip" });
    }
  });

  // ========================================
  // Phase 15 - Multi-Country Tax, Currency & Compliance
  // ========================================

  // Get all countries
  app.get("/api/countries", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const countries = await storage.getAllCountries();
      return res.json(countries);
    } catch (error) {
      console.error("Error fetching countries:", error);
      return res.status(500).json({ message: "Failed to fetch countries" });
    }
  });

  // Get active countries (for trip creation dropdown)
  app.get("/api/countries/active", isAuthenticated, async (req: any, res) => {
    try {
      const countries = await storage.getActiveCountries();
      return res.json(countries);
    } catch (error) {
      console.error("Error fetching active countries:", error);
      return res.status(500).json({ message: "Failed to fetch active countries" });
    }
  });

  // Create country
  app.post("/api/countries", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const parsed = insertCountrySchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid country data", errors: parsed.error.errors });
      }

      const existing = await storage.getCountryByCode(parsed.data.isoCode);
      if (existing) {
        return res.status(400).json({ message: "Country with this ISO code already exists" });
      }

      const country = await storage.createCountry(parsed.data);

      await storage.createAuditLog({
        action: "country_created",
        entityType: "country",
        entityId: country.id,
        performedByUserId: userId,
        performedByRole: "admin",
        metadata: JSON.stringify({ name: country.name, isoCode: country.isoCode })
      });

      return res.status(201).json(country);
    } catch (error) {
      console.error("Error creating country:", error);
      return res.status(500).json({ message: "Failed to create country" });
    }
  });

  // Update country
  app.patch("/api/countries/:countryId", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { countryId } = req.params;
      const { name, currency, active } = req.body;

      const country = await storage.getCountryById(countryId);
      if (!country) {
        return res.status(404).json({ message: "Country not found" });
      }

      const updated = await storage.updateCountry(countryId, { name, currency, active });

      await storage.createAuditLog({
        action: "country_updated",
        entityType: "country",
        entityId: countryId,
        performedByUserId: userId,
        performedByRole: "admin",
        metadata: JSON.stringify({ name, currency, active })
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error updating country:", error);
      return res.status(500).json({ message: "Failed to update country" });
    }
  });

  // Get all tax rules
  app.get("/api/tax-rules", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const { countryId } = req.query;
      const rules = countryId 
        ? await storage.getTaxRulesByCountry(countryId as string)
        : await storage.getAllTaxRules();
      return res.json(rules);
    } catch (error) {
      console.error("Error fetching tax rules:", error);
      return res.status(500).json({ message: "Failed to fetch tax rules" });
    }
  });

  // Create tax rule
  app.post("/api/tax-rules", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const parsed = insertTaxRuleSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid tax rule data", errors: parsed.error.errors });
      }

      const country = await storage.getCountryById(parsed.data.countryId);
      if (!country) {
        return res.status(400).json({ message: "Country not found" });
      }

      const rule = await storage.createTaxRule(parsed.data);

      await storage.createAuditLog({
        action: "tax_rule_created",
        entityType: "tax_rule",
        entityId: rule.id,
        performedByUserId: userId,
        performedByRole: "admin",
        metadata: JSON.stringify({ countryId: rule.countryId, taxType: rule.taxType, rate: rule.rate })
      });

      return res.status(201).json(rule);
    } catch (error) {
      console.error("Error creating tax rule:", error);
      return res.status(500).json({ message: "Failed to create tax rule" });
    }
  });

  // Update tax rule
  app.patch("/api/tax-rules/:ruleId", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { ruleId } = req.params;
      const { rate, effectiveTo, name } = req.body;

      const rule = await storage.getTaxRuleById(ruleId);
      if (!rule) {
        return res.status(404).json({ message: "Tax rule not found" });
      }

      const updated = await storage.updateTaxRule(ruleId, { rate, effectiveTo, name });

      await storage.createAuditLog({
        action: "tax_rule_updated",
        entityType: "tax_rule",
        entityId: ruleId,
        performedByUserId: userId,
        performedByRole: "admin",
        metadata: JSON.stringify({ rate, effectiveTo })
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error updating tax rule:", error);
      return res.status(500).json({ message: "Failed to update tax rule" });
    }
  });

  // Get all exchange rates
  app.get("/api/exchange-rates", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const { base, target } = req.query;
      if (base && target) {
        const history = await storage.getExchangeRateHistory(base as string, target as string);
        return res.json(history);
      }
      const rates = await storage.getAllExchangeRates();
      return res.json(rates);
    } catch (error) {
      console.error("Error fetching exchange rates:", error);
      return res.status(500).json({ message: "Failed to fetch exchange rates" });
    }
  });

  // Create exchange rate
  app.post("/api/exchange-rates", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const parsed = insertExchangeRateSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid exchange rate data", errors: parsed.error.errors });
      }

      const rate = await storage.createExchangeRate(parsed.data);

      await storage.createAuditLog({
        action: "exchange_rate_created",
        entityType: "exchange_rate",
        entityId: rate.id,
        performedByUserId: userId,
        performedByRole: req.userRole,
        metadata: JSON.stringify({ base: rate.baseCurrency, target: rate.targetCurrency, rate: rate.rate })
      });

      return res.status(201).json(rate);
    } catch (error) {
      console.error("Error creating exchange rate:", error);
      return res.status(500).json({ message: "Failed to create exchange rate" });
    }
  });

  // Get latest exchange rate for a pair
  app.get("/api/exchange-rates/latest", isAuthenticated, async (req: any, res) => {
    try {
      const { base, target } = req.query;
      if (!base || !target) {
        return res.status(400).json({ message: "Base and target currencies are required" });
      }
      const rate = await storage.getLatestExchangeRate(base as string, target as string);
      return res.json(rate);
    } catch (error) {
      console.error("Error fetching latest exchange rate:", error);
      return res.status(500).json({ message: "Failed to fetch latest exchange rate" });
    }
  });

  // Get all compliance profiles
  app.get("/api/compliance", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const profiles = await storage.getAllComplianceProfiles();
      return res.json(profiles);
    } catch (error) {
      console.error("Error fetching compliance profiles:", error);
      return res.status(500).json({ message: "Failed to fetch compliance profiles" });
    }
  });

  // Create compliance profile
  app.post("/api/compliance", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const parsed = insertComplianceProfileSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid compliance profile data", errors: parsed.error.errors });
      }

      const existing = await storage.getComplianceProfileByCountry(parsed.data.countryId);
      if (existing) {
        return res.status(400).json({ message: "Compliance profile already exists for this country" });
      }

      const country = await storage.getCountryById(parsed.data.countryId);
      if (!country) {
        return res.status(400).json({ message: "Country not found" });
      }

      const profile = await storage.createComplianceProfile(parsed.data);

      await storage.createAuditLog({
        action: "compliance_profile_created",
        entityType: "compliance_profile",
        entityId: profile.id,
        performedByUserId: userId,
        performedByRole: "admin",
        metadata: JSON.stringify({ countryId: profile.countryId, legalEntityName: profile.legalEntityName })
      });

      return res.status(201).json(profile);
    } catch (error) {
      console.error("Error creating compliance profile:", error);
      return res.status(500).json({ message: "Failed to create compliance profile" });
    }
  });

  // Update compliance profile
  app.patch("/api/compliance/:profileId", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { profileId } = req.params;
      const { legalEntityName, registrationId, taxId, notes } = req.body;

      const allProfiles = await storage.getAllComplianceProfiles();
      const found = allProfiles.find((p: any) => p.id === profileId);
      if (!found) {
        return res.status(404).json({ message: "Compliance profile not found" });
      }

      const updated = await storage.updateComplianceProfile(profileId, {
        legalEntityName, registrationId, taxId, notes
      });

      await storage.createAuditLog({
        action: "compliance_profile_updated",
        entityType: "compliance_profile",
        entityId: profileId,
        performedByUserId: userId,
        performedByRole: "admin",
        metadata: JSON.stringify({ legalEntityName, notes })
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error updating compliance profile:", error);
      return res.status(500).json({ message: "Failed to update compliance profile" });
    }
  });

  // Get country analytics
  app.get("/api/analytics/countries", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const { countryId } = req.query;
      const analytics = await storage.getCountryAnalytics(countryId as string | undefined);
      return res.json(analytics);
    } catch (error) {
      console.error("Error fetching country analytics:", error);
      return res.status(500).json({ message: "Failed to fetch country analytics" });
    }
  });

  // Get compliance overview
  app.get("/api/compliance/overview", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const overview = await storage.getComplianceOverview();
      return res.json(overview);
    } catch (error) {
      console.error("Error fetching compliance overview:", error);
      return res.status(500).json({ message: "Failed to fetch compliance overview" });
    }
  });

  // ============================================
  // Phase 16 - Support System Routes
  // ============================================

  // Rate limiting map for support endpoints
  const supportRateLimits = new Map<string, { count: number; resetAt: number }>();
  const SUPPORT_RATE_LIMIT = 10; // requests per minute
  const SUPPORT_RATE_WINDOW = 60000; // 1 minute

  function checkSupportRateLimit(userId: string): boolean {
    const now = Date.now();
    const userLimit = supportRateLimits.get(userId);
    
    if (!userLimit || now > userLimit.resetAt) {
      supportRateLimits.set(userId, { count: 1, resetAt: now + SUPPORT_RATE_WINDOW });
      return true;
    }
    
    if (userLimit.count >= SUPPORT_RATE_LIMIT) {
      return false;
    }
    
    userLimit.count++;
    return true;
  }

  // Sanitize input to prevent XSS
  function sanitizeInput(input: string): string {
    return input
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;")
      .trim()
      .slice(0, 5000); // Max length
  }

  // Create support ticket (Rider, Driver, Trip Coordinator)
  app.post("/api/support/tickets/create", isAuthenticated, requireRole(["rider", "driver", "trip_coordinator"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const userRole = req.user?.role;
      
      if (!checkSupportRateLimit(userId)) {
        return res.status(429).json({ message: "Rate limit exceeded. Please wait before submitting again." });
      }
      
      const { subject, description, tripId, priority, supportContext } = req.body;
      
      if (!subject || !description) {
        return res.status(400).json({ message: "Subject and description are required" });
      }
      
      if (subject.length < 5 || subject.length > 255) {
        return res.status(400).json({ message: "Subject must be between 5 and 255 characters" });
      }
      
      if (description.length < 10 || description.length > 5000) {
        return res.status(400).json({ message: "Description must be between 10 and 5000 characters" });
      }
      
      // Map user role to ticket creator role
      let createdByRole: "rider" | "driver" | "trip_coordinator";
      if (userRole === "driver") {
        createdByRole = "driver";
      } else if (userRole === "trip_coordinator") {
        createdByRole = "trip_coordinator";
      } else {
        createdByRole = "rider";
      }
      
      // Validate tripId if provided
      if (tripId) {
        const trip = await storage.getTripById(tripId);
        if (!trip) {
          return res.status(400).json({ message: "Invalid trip ID" });
        }
        // Verify user is associated with trip
        if (trip.riderId !== userId && trip.driverId !== userId && trip.bookedByUserId !== userId) {
          return res.status(403).json({ message: "You are not associated with this trip" });
        }
      }
      
      const ticket = await storage.createSupportTicket({
        createdByUserId: userId,
        createdByRole,
        subject: sanitizeInput(subject),
        description: sanitizeInput(description),
        tripId: tripId || null,
        priority: priority || "medium",
        status: "open"
      });
      
      const contextMetadata: Record<string, any> = { subject: ticket.subject, tripId };
      if (supportContext && typeof supportContext === "object") {
        const safeContext: Record<string, string> = {};
        const allowedKeys = ["appType", "userId", "role", "country", "appVersion", "deviceType", "os", "language", "networkStatus", "timestamp", "currentScreen"];
        for (const key of allowedKeys) {
          if (supportContext[key] && typeof supportContext[key] === "string") {
            safeContext[key] = supportContext[key].substring(0, 255);
          }
        }
        contextMetadata.supportContext = safeContext;
      }

      await storage.createAuditLog({
        action: "support_ticket_created",
        entityType: "support_ticket",
        entityId: ticket.id,
        performedByUserId: userId,
        performedByRole: createdByRole,
        metadata: JSON.stringify(contextMetadata)
      });
      
      return res.json(ticket);
    } catch (error) {
      console.error("Error creating support ticket:", error);
      return res.status(500).json({ message: "Failed to create support ticket" });
    }
  });

  // Get user's own tickets (Rider, Driver, Trip Coordinator)
  app.get("/api/support/tickets/my", isAuthenticated, requireRole(["rider", "driver", "trip_coordinator"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const tickets = await storage.getUserSupportTickets(userId);
      return res.json(tickets);
    } catch (error) {
      console.error("Error fetching user tickets:", error);
      return res.status(500).json({ message: "Failed to fetch tickets" });
    }
  });

  // Get ticket details with messages (ticket owner or support agent)
  app.get("/api/support/tickets/:ticketId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const userRole = req.user?.role;
      const { ticketId } = req.params;
      
      const ticket = await storage.getSupportTicketById(ticketId);
      if (!ticket) {
        return res.status(404).json({ message: "Ticket not found" });
      }
      
      // Access control: ticket owner, assigned agent, support_agent, or admin
      const isOwner = ticket.createdByUserId === userId;
      const isAssigned = ticket.assignedToUserId === userId;
      const isSupportAgent = userRole === "support_agent";
      const isAdmin = userRole === "admin";
      
      if (!isOwner && !isAssigned && !isSupportAgent && !isAdmin) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Support agents and admins can see internal notes
      const includeInternal = isSupportAgent || isAdmin;
      const messages = await storage.getSupportMessages(ticketId, includeInternal);
      
      let supportContext = null;
      let walletContext = null;
      if (isSupportAgent || isAdmin) {
        try {
          const auditLogs = await storage.getAuditLogsByEntity("support_ticket", ticketId);
          const creationLog = auditLogs?.find((log: any) => log.action === "support_ticket_created");
          if (creationLog?.metadata) {
            const meta = typeof creationLog.metadata === "string" ? JSON.parse(creationLog.metadata) : creationLog.metadata;
            supportContext = meta.supportContext || null;
          }
        } catch (e) {
          // Context retrieval is optional, don't fail the request
        }
        try {
          const ticketUserId = ticket.createdByUserId;
          const wallet = await storage.getWalletByUserId(ticketUserId);
          if (wallet) {
            const autoTopUp = await storage.getAutoTopUpSettings(ticketUserId);
            walletContext = {
              balance: wallet.balance,
              currency: wallet.currency,
              isFrozen: (wallet as any).isFrozen || false,
              autoTopUp: autoTopUp ? {
                enabled: autoTopUp.autoTopUpEnabled,
                threshold: autoTopUp.autoTopUpThreshold,
                amount: autoTopUp.autoTopUpAmount,
                failureCount: autoTopUp.autoTopUpFailureCount,
              } : null,
            };
          }
        } catch (e) {
          // Wallet context retrieval is optional
        }
      }
      
      return res.json({ ticket, messages, supportContext, walletContext });
    } catch (error) {
      console.error("Error fetching ticket details:", error);
      return res.status(500).json({ message: "Failed to fetch ticket details" });
    }
  });

  // Get assigned tickets (Support Agent)
  app.get("/api/support/tickets/assigned", isAuthenticated, requireRole(["support_agent"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const tickets = await storage.getAssignedSupportTickets(userId);
      return res.json(tickets);
    } catch (error) {
      console.error("Error fetching assigned tickets:", error);
      return res.status(500).json({ message: "Failed to fetch assigned tickets" });
    }
  });

  // Get all open tickets (Support Agent queue)
  app.get("/api/support/tickets/queue", isAuthenticated, requireRole(["support_agent"]), async (req: any, res) => {
    try {
      const { status, priority } = req.query;
      const tickets = await storage.getAllSupportTickets({ 
        status: status as string, 
        priority: priority as string 
      });
      return res.json(tickets);
    } catch (error) {
      console.error("Error fetching ticket queue:", error);
      return res.status(500).json({ message: "Failed to fetch ticket queue" });
    }
  });

  // Get escalated tickets (Admin only)
  app.get("/api/support/tickets/escalated", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const tickets = await storage.getEscalatedSupportTickets();
      return res.json(tickets);
    } catch (error) {
      console.error("Error fetching escalated tickets:", error);
      return res.status(500).json({ message: "Failed to fetch escalated tickets" });
    }
  });

  // Get support stats (Admin, Support Agent)
  app.get("/api/support/stats", isAuthenticated, requireRole(["admin", "support_agent"]), async (req: any, res) => {
    try {
      const stats = await storage.getSupportStats();
      return res.json(stats);
    } catch (error) {
      console.error("Error fetching support stats:", error);
      return res.status(500).json({ message: "Failed to fetch support stats" });
    }
  });

  // Assign ticket to self (Support Agent)
  app.post("/api/support/tickets/:ticketId/assign", isAuthenticated, requireRole(["support_agent"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { ticketId } = req.params;
      
      const ticket = await storage.getSupportTicketById(ticketId);
      if (!ticket) {
        return res.status(404).json({ message: "Ticket not found" });
      }
      
      if (ticket.status === "closed" || ticket.status === "resolved") {
        return res.status(400).json({ message: "Cannot assign closed tickets" });
      }
      
      const updated = await storage.assignSupportTicket(ticketId, userId);
      
      await storage.createAuditLog({
        action: "support_ticket_assigned",
        entityType: "support_ticket",
        entityId: ticketId,
        performedByUserId: userId,
        performedByRole: "support_agent",
        metadata: JSON.stringify({ previousStatus: ticket.status })
      });
      
      return res.json(updated);
    } catch (error) {
      console.error("Error assigning ticket:", error);
      return res.status(500).json({ message: "Failed to assign ticket" });
    }
  });

  // Respond to ticket (owner or support agent)
  app.post("/api/support/tickets/respond", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const userRole = req.user?.role;
      const { ticketId, message, internal } = req.body;
      
      if (!checkSupportRateLimit(userId)) {
        return res.status(429).json({ message: "Rate limit exceeded" });
      }
      
      if (!ticketId || !message) {
        return res.status(400).json({ message: "Ticket ID and message are required" });
      }
      
      if (message.length < 1 || message.length > 5000) {
        return res.status(400).json({ message: "Message must be between 1 and 5000 characters" });
      }
      
      const ticket = await storage.getSupportTicketById(ticketId);
      if (!ticket) {
        return res.status(404).json({ message: "Ticket not found" });
      }
      
      // Check ticket is not closed
      if (ticket.status === "closed") {
        return res.status(400).json({ message: "Cannot respond to closed tickets" });
      }
      
      // Access control
      const isOwner = ticket.createdByUserId === userId;
      const isAssigned = ticket.assignedToUserId === userId;
      const isSupportAgent = userRole === "support_agent";
      const isAdmin = userRole === "admin";
      
      if (!isOwner && !isAssigned && !isSupportAgent && !isAdmin) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      // Only support agents and admins can post internal notes
      const isInternal = (isSupportAgent || isAdmin) && internal === true;
      
      const supportMessage = await storage.createSupportMessage({
        ticketId,
        senderUserId: userId,
        senderRole: userRole,
        message: sanitizeInput(message),
        internal: isInternal
      });
      
      await storage.createAuditLog({
        action: "support_message_sent",
        entityType: "support_ticket",
        entityId: ticketId,
        performedByUserId: userId,
        performedByRole: userRole,
        metadata: JSON.stringify({ internal: isInternal })
      });
      
      return res.json(supportMessage);
    } catch (error) {
      console.error("Error responding to ticket:", error);
      return res.status(500).json({ message: "Failed to send message" });
    }
  });

  // Escalate ticket (Support Agent)
  app.post("/api/support/tickets/escalate", isAuthenticated, requireRole(["support_agent"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { ticketId, reason } = req.body;
      
      if (!ticketId) {
        return res.status(400).json({ message: "Ticket ID is required" });
      }
      
      const ticket = await storage.getSupportTicketById(ticketId);
      if (!ticket) {
        return res.status(404).json({ message: "Ticket not found" });
      }
      
      if (ticket.status === "closed" || ticket.status === "resolved") {
        return res.status(400).json({ message: "Cannot escalate closed tickets" });
      }
      
      const updated = await storage.escalateSupportTicket(ticketId);
      
      // Add internal note about escalation
      if (reason) {
        await storage.createSupportMessage({
          ticketId,
          senderUserId: userId,
          senderRole: "support_agent",
          message: `Escalated: ${sanitizeInput(reason)}`,
          internal: true
        });
      }
      
      await storage.createAuditLog({
        action: "support_ticket_escalated",
        entityType: "support_ticket",
        entityId: ticketId,
        performedByUserId: userId,
        performedByRole: "support_agent",
        metadata: JSON.stringify({ reason: reason || "No reason provided" })
      });
      
      return res.json(updated);
    } catch (error) {
      console.error("Error escalating ticket:", error);
      return res.status(500).json({ message: "Failed to escalate ticket" });
    }
  });

  // Close/Resolve ticket (Support Agent or Admin)
  app.post("/api/support/tickets/close", isAuthenticated, requireRole(["support_agent", "admin"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const userRole = req.user?.role;
      const { ticketId, resolution } = req.body;
      
      if (!ticketId) {
        return res.status(400).json({ message: "Ticket ID is required" });
      }
      
      const ticket = await storage.getSupportTicketById(ticketId);
      if (!ticket) {
        return res.status(404).json({ message: "Ticket not found" });
      }
      
      if (ticket.status === "closed") {
        return res.status(400).json({ message: "Ticket is already closed" });
      }
      
      const updated = await storage.closeSupportTicket(ticketId, "resolved");
      
      // Add resolution note
      if (resolution) {
        await storage.createSupportMessage({
          ticketId,
          senderUserId: userId,
          senderRole: userRole,
          message: `Resolution: ${sanitizeInput(resolution)}`,
          internal: false
        });
      }
      
      await storage.createAuditLog({
        action: "support_ticket_closed",
        entityType: "support_ticket",
        entityId: ticketId,
        performedByUserId: userId,
        performedByRole: userRole,
        metadata: JSON.stringify({ previousStatus: ticket.status, resolution })
      });
      
      return res.json(updated);
    } catch (error) {
      console.error("Error closing ticket:", error);
      return res.status(500).json({ message: "Failed to close ticket" });
    }
  });

  // Phase 18 - Contracts, SLAs & Enterprise Billing

  // Get all contracts (Admin, Finance, Director)
  app.get("/api/contracts", isAuthenticated, requireRole(["admin", "finance", "director"]), async (req: any, res) => {
    try {
      const contracts = await storage.getAllOrganizationContracts();
      return res.json(contracts);
    } catch (error) {
      console.error("Error getting contracts:", error);
      return res.status(500).json({ message: "Failed to get contracts" });
    }
  });

  // Get contract stats (Admin, Finance, Director)
  app.get("/api/contracts/stats", isAuthenticated, requireRole(["admin", "finance", "director"]), async (req: any, res) => {
    try {
      const stats = await storage.getContractStats();
      return res.json(stats);
    } catch (error) {
      console.error("Error getting contract stats:", error);
      return res.status(500).json({ message: "Failed to get contract stats" });
    }
  });

  // Get single contract
  app.get("/api/contracts/:contractId", isAuthenticated, requireRole(["admin", "finance", "director", "trip_coordinator"]), async (req: any, res) => {
    try {
      const { contractId } = req.params;
      const userId = req.user?.claims?.sub;
      const userRole = req.userRole;

      const contract = await storage.getOrganizationContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }

      if (userRole === "trip_coordinator" && contract.tripCoordinatorId !== userId) {
        return res.status(403).json({ message: "Access denied" });
      }

      return res.json(contract);
    } catch (error) {
      console.error("Error getting contract:", error);
      return res.status(500).json({ message: "Failed to get contract" });
    }
  });

  // Create contract (Admin only)
  app.post("/api/contracts", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { tripCoordinatorId, contractName, contractType, startDate, endDate, billingModel, currency } = req.body;

      if (!tripCoordinatorId || !contractName || !contractType || !startDate || !endDate) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      const contract = await storage.createOrganizationContract({
        tripCoordinatorId,
        contractName: sanitizeInput(contractName),
        contractType,
        startDate: new Date(startDate),
        endDate: new Date(endDate),
        billingModel: billingModel || "MONTHLY_INVOICE",
        currency: currency || "NGN",
        status: "ACTIVE"
      });

      await storage.createAuditLog({
        action: "contract_created",
        entityType: "organization_contract",
        entityId: contract.id,
        performedByUserId: userId,
        performedByRole: "admin",
        metadata: JSON.stringify({ contractName, contractType, tripCoordinatorId })
      });

      return res.json(contract);
    } catch (error) {
      console.error("Error creating contract:", error);
      return res.status(500).json({ message: "Failed to create contract" });
    }
  });

  // Update contract (Admin only)
  app.patch("/api/contracts/:contractId", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { contractId } = req.params;
      const updates = req.body;

      const existing = await storage.getOrganizationContract(contractId);
      if (!existing) {
        return res.status(404).json({ message: "Contract not found" });
      }

      const updated = await storage.updateOrganizationContract(contractId, updates);

      await storage.createAuditLog({
        action: "contract_updated",
        entityType: "organization_contract",
        entityId: contractId,
        performedByUserId: userId,
        performedByRole: "admin",
        metadata: JSON.stringify({ updates })
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error updating contract:", error);
      return res.status(500).json({ message: "Failed to update contract" });
    }
  });

  // Get coordinator's contract (Trip Coordinator)
  app.get("/api/coordinator/contract", isAuthenticated, requireRole(["trip_coordinator"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const contract = await storage.getContractByCoordinator(userId);
      return res.json(contract);
    } catch (error) {
      console.error("Error getting coordinator contract:", error);
      return res.status(500).json({ message: "Failed to get contract" });
    }
  });

  // Get SLAs for a contract
  app.get("/api/contracts/:contractId/slas", isAuthenticated, requireRole(["admin", "finance", "director", "trip_coordinator"]), async (req: any, res) => {
    try {
      const { contractId } = req.params;
      const slas = await storage.getSLAsByContract(contractId);
      return res.json(slas);
    } catch (error) {
      console.error("Error getting SLAs:", error);
      return res.status(500).json({ message: "Failed to get SLAs" });
    }
  });

  // Create SLA (Admin only)
  app.post("/api/contracts/:contractId/slas", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { contractId } = req.params;
      const { metricType, targetValue, measurementPeriod, notes } = req.body;

      const contract = await storage.getOrganizationContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }

      const sla = await storage.createServiceLevelAgreement({
        contractId,
        metricType,
        targetValue: targetValue.toString(),
        measurementPeriod: measurementPeriod || "MONTHLY",
        notes: notes ? sanitizeInput(notes) : null
      });

      await storage.createAuditLog({
        action: "sla_created",
        entityType: "service_level_agreement",
        entityId: sla.id,
        performedByUserId: userId,
        performedByRole: "admin",
        metadata: JSON.stringify({ contractId, metricType, targetValue })
      });

      return res.json(sla);
    } catch (error) {
      console.error("Error creating SLA:", error);
      return res.status(500).json({ message: "Failed to create SLA" });
    }
  });

  // Get all invoices (Admin, Finance, Director)
  app.get("/api/invoices", isAuthenticated, requireRole(["admin", "finance", "director"]), async (req: any, res) => {
    try {
      const invoices = await storage.getAllEnterpriseInvoices();
      return res.json(invoices);
    } catch (error) {
      console.error("Error getting invoices:", error);
      return res.status(500).json({ message: "Failed to get invoices" });
    }
  });

  // Get invoices for a contract
  app.get("/api/contracts/:contractId/invoices", isAuthenticated, requireRole(["admin", "finance", "director", "trip_coordinator"]), async (req: any, res) => {
    try {
      const { contractId } = req.params;
      const invoices = await storage.getInvoicesByContract(contractId);
      return res.json(invoices);
    } catch (error) {
      console.error("Error getting contract invoices:", error);
      return res.status(500).json({ message: "Failed to get invoices" });
    }
  });

  // Generate invoice for contract (Admin, Finance)
  app.post("/api/contracts/:contractId/invoices/generate", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const userRole = req.userRole;
      const { contractId } = req.params;
      const { periodStart, periodEnd } = req.body;

      if (!periodStart || !periodEnd) {
        return res.status(400).json({ message: "Period start and end dates are required" });
      }

      const invoice = await storage.generateInvoiceForContract(
        contractId,
        new Date(periodStart),
        new Date(periodEnd)
      );

      if (!invoice) {
        return res.status(404).json({ message: "Contract not found" });
      }

      await storage.createAuditLog({
        action: "invoice_generated",
        entityType: "enterprise_invoice",
        entityId: invoice.id,
        performedByUserId: userId,
        performedByRole: userRole,
        metadata: JSON.stringify({ contractId, periodStart, periodEnd, totalAmount: invoice.totalAmount })
      });

      return res.json(invoice);
    } catch (error) {
      console.error("Error generating invoice:", error);
      return res.status(500).json({ message: "Failed to generate invoice" });
    }
  });

  // Update invoice status (Admin, Finance)
  app.patch("/api/invoices/:invoiceId/status", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const userRole = req.userRole;
      const { invoiceId } = req.params;
      const { status } = req.body;

      if (!["DRAFT", "ISSUED", "PAID", "OVERDUE"].includes(status)) {
        return res.status(400).json({ message: "Invalid status" });
      }

      const invoice = await storage.getEnterpriseInvoice(invoiceId);
      if (!invoice) {
        return res.status(404).json({ message: "Invoice not found" });
      }

      const updated = await storage.updateEnterpriseInvoiceStatus(invoiceId, status);

      await storage.createAuditLog({
        action: "invoice_status_updated",
        entityType: "enterprise_invoice",
        entityId: invoiceId,
        performedByUserId: userId,
        performedByRole: userRole,
        metadata: JSON.stringify({ previousStatus: invoice.status, newStatus: status })
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error updating invoice status:", error);
      return res.status(500).json({ message: "Failed to update invoice status" });
    }
  });

  // Phase 19 - Growth, Marketing & Partnerships

  // Generate unique referral code
  function generateReferralCode(): string {
    const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
    let code = "";
    for (let i = 0; i < 8; i++) {
      code += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return code;
  }

  // Create referral code (any authenticated user)
  app.post("/api/referrals/create", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const userRole = req.userRole;

      if (!["rider", "driver", "trip_coordinator"].includes(userRole)) {
        return res.status(403).json({ message: "Only riders, drivers, and trip coordinators can create referral codes" });
      }

      const existingCodes = await storage.getReferralCodesByOwner(userId);
      const activeCode = existingCodes.find(c => c.active);
      if (activeCode) {
        return res.json(activeCode);
      }

      let code = generateReferralCode();
      let attempts = 0;
      while (await storage.getReferralCodeByCode(code) && attempts < 10) {
        code = generateReferralCode();
        attempts++;
      }

      const referralCode = await storage.createReferralCode({
        code,
        ownerUserId: userId,
        ownerRole: userRole as any,
        active: true,
        maxUsage: null
      });

      await storage.createAuditLog({
        action: "referral_code_created",
        entityType: "referral_code",
        entityId: referralCode.id,
        performedByUserId: userId,
        performedByRole: userRole,
        metadata: JSON.stringify({ code })
      });

      return res.json(referralCode);
    } catch (error) {
      console.error("Error creating referral code:", error);
      return res.status(500).json({ message: "Failed to create referral code" });
    }
  });

  // Get my referral codes (any authenticated user)
  app.get("/api/referrals/my", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const codes = await storage.getReferralCodesByOwner(userId);
      return res.json(codes);
    } catch (error) {
      console.error("Error getting referral codes:", error);
      return res.status(500).json({ message: "Failed to get referral codes" });
    }
  });

  // Get referral stats for current user
  app.get("/api/referrals/stats", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const stats = await storage.getReferralStats(userId);
      return res.json(stats);
    } catch (error) {
      console.error("Error getting referral stats:", error);
      return res.status(500).json({ message: "Failed to get referral stats" });
    }
  });

  // Get all referral codes (Admin only)
  app.get("/api/referrals", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const codes = await storage.getAllReferralCodes();
      return res.json(codes);
    } catch (error) {
      console.error("Error getting all referral codes:", error);
      return res.status(500).json({ message: "Failed to get referral codes" });
    }
  });

  // Create marketing campaign (Admin only)
  app.post("/api/campaigns", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { name, type, startAt, endAt, notes } = req.body;

      if (!name || !type || !startAt || !endAt) {
        return res.status(400).json({ message: "Name, type, start date, and end date are required" });
      }

      if (!["REFERRAL", "PROMO", "PARTNERSHIP"].includes(type)) {
        return res.status(400).json({ message: "Invalid campaign type" });
      }

      const campaign = await storage.createMarketingCampaign({
        name,
        type,
        startAt: new Date(startAt),
        endAt: new Date(endAt),
        notes: notes || null,
        status: "ACTIVE"
      });

      await storage.createAuditLog({
        action: "campaign_created",
        entityType: "marketing_campaign",
        entityId: campaign.id,
        performedByUserId: userId,
        performedByRole: "admin",
        metadata: JSON.stringify({ name, type })
      });

      return res.json(campaign);
    } catch (error) {
      console.error("Error creating campaign:", error);
      return res.status(500).json({ message: "Failed to create campaign" });
    }
  });

  // Get active campaigns
  app.get("/api/campaigns/active", isAuthenticated, async (req: any, res) => {
    try {
      const campaigns = await storage.getActiveCampaigns();
      return res.json(campaigns);
    } catch (error) {
      console.error("Error getting active campaigns:", error);
      return res.status(500).json({ message: "Failed to get active campaigns" });
    }
  });

  // Get all campaigns (Admin only)
  app.get("/api/campaigns", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const campaigns = await storage.getAllMarketingCampaigns();
      return res.json(campaigns);
    } catch (error) {
      console.error("Error getting campaigns:", error);
      return res.status(500).json({ message: "Failed to get campaigns" });
    }
  });

  // Update campaign status (Admin only)
  app.patch("/api/campaigns/:campaignId/status", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { campaignId } = req.params;
      const { status } = req.body;

      if (!["ACTIVE", "PAUSED", "ENDED"].includes(status)) {
        return res.status(400).json({ message: "Invalid status" });
      }

      const campaign = await storage.getMarketingCampaign(campaignId);
      if (!campaign) {
        return res.status(404).json({ message: "Campaign not found" });
      }

      const updated = await storage.updateMarketingCampaignStatus(campaignId, status);

      await storage.createAuditLog({
        action: "campaign_status_updated",
        entityType: "marketing_campaign",
        entityId: campaignId,
        performedByUserId: userId,
        performedByRole: "admin",
        metadata: JSON.stringify({ previousStatus: campaign.status, newStatus: status })
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error updating campaign status:", error);
      return res.status(500).json({ message: "Failed to update campaign status" });
    }
  });

  // Create partner lead (Admin only)
  app.post("/api/partners/lead", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { organizationName, contactName, contactEmail, partnerType, notes } = req.body;

      if (!organizationName || !contactName || !contactEmail || !partnerType) {
        return res.status(400).json({ message: "Organization name, contact name, email, and partner type are required" });
      }

      if (!["NGO", "HOSPITAL", "CHURCH", "SCHOOL", "GOV", "CORPORATE"].includes(partnerType)) {
        return res.status(400).json({ message: "Invalid partner type" });
      }

      const lead = await storage.createPartnerLead({
        organizationName,
        contactName,
        contactEmail,
        partnerType,
        notes: notes || null,
        status: "NEW"
      });

      await storage.createAuditLog({
        action: "partner_lead_created",
        entityType: "partner_lead",
        entityId: lead.id,
        performedByUserId: userId,
        performedByRole: "admin",
        metadata: JSON.stringify({ organizationName, partnerType })
      });

      return res.json(lead);
    } catch (error) {
      console.error("Error creating partner lead:", error);
      return res.status(500).json({ message: "Failed to create partner lead" });
    }
  });

  // Get all partner leads (Admin only)
  app.get("/api/partners/leads", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const leads = await storage.getAllPartnerLeads();
      return res.json(leads);
    } catch (error) {
      console.error("Error getting partner leads:", error);
      return res.status(500).json({ message: "Failed to get partner leads" });
    }
  });

  // Update partner lead status (Admin only)
  app.patch("/api/partners/leads/:leadId/status", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { leadId } = req.params;
      const { status } = req.body;

      if (!["NEW", "CONTACTED", "IN_DISCUSSION", "SIGNED", "LOST"].includes(status)) {
        return res.status(400).json({ message: "Invalid status" });
      }

      const lead = await storage.getPartnerLead(leadId);
      if (!lead) {
        return res.status(404).json({ message: "Partner lead not found" });
      }

      const updated = await storage.updatePartnerLeadStatus(leadId, status);

      await storage.createAuditLog({
        action: "partner_lead_status_updated",
        entityType: "partner_lead",
        entityId: leadId,
        performedByUserId: userId,
        performedByRole: "admin",
        metadata: JSON.stringify({ previousStatus: lead.status, newStatus: status })
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error updating partner lead status:", error);
      return res.status(500).json({ message: "Failed to update partner lead status" });
    }
  });

  // Get growth stats (Admin only)
  app.get("/api/growth/stats", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const stats = await storage.getGrowthStats();
      return res.json(stats);
    } catch (error) {
      console.error("Error getting growth stats:", error);
      return res.status(500).json({ message: "Failed to get growth stats" });
    }
  });

  // =============================================
  // PHASE 11A: GROWTH, MARKETING & VIRALITY
  // =============================================

  // Apply a referral code (rider joining via referral)
  app.post("/api/referrals/apply", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { code } = req.body;

      if (!code) {
        return res.status(400).json({ message: "Referral code is required" });
      }

      const referralCode = await storage.getReferralCodeByCode(code);
      if (!referralCode) {
        return res.status(404).json({ message: "Referral code not found" });
      }

      if (!referralCode.isActive) {
        return res.status(400).json({ message: "Referral code is no longer active" });
      }

      if (referralCode.ownerUserId === userId) {
        return res.status(400).json({ message: "You cannot use your own referral code" });
      }

      const existingReward = await storage.getRiderReferralRewardByReferred(userId);
      if (existingReward) {
        return res.status(400).json({ message: "You have already used a referral code" });
      }

      await storage.createReferralEvent({
        referralCodeId: referralCode.id,
        referredUserId: userId,
        eventType: "signup",
      });

      await storage.updateReferralCodeUsage(referralCode.id);

      const reward = await storage.createRiderReferralReward({
        referrerUserId: referralCode.ownerUserId,
        referredRiderUserId: userId,
        referralCodeId: referralCode.id,
        rewardAmount: "500.00",
        currency: "NGN",
      });

      await storage.createMarketingAttribution({
        userId,
        source: "REFERRAL",
        referralCodeId: referralCode.id,
      });

      return res.json(reward);
    } catch (error) {
      console.error("Error applying referral code:", error);
      return res.status(500).json({ message: "Failed to apply referral code" });
    }
  });

  // Get my rider referral rewards (for referrer)
  app.get("/api/referrals/rider-rewards", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const rewards = await storage.getRiderReferralRewardsByReferrer(userId);
      return res.json(rewards);
    } catch (error) {
      console.error("Error getting rider referral rewards:", error);
      return res.status(500).json({ message: "Failed to get rider referral rewards" });
    }
  });

  // Get pending shareable moments for current user
  app.get("/api/shareable-moments", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const moments = await storage.getPendingShareableMoments(userId);
      return res.json(moments);
    } catch (error) {
      console.error("Error getting shareable moments:", error);
      return res.status(500).json({ message: "Failed to get shareable moments" });
    }
  });

  // Mark a moment as shared
  app.post("/api/shareable-moments/:id/share", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const result = await storage.markMomentShared(id);
      if (!result) {
        return res.status(404).json({ message: "Moment not found" });
      }
      return res.json(result);
    } catch (error) {
      console.error("Error marking moment as shared:", error);
      return res.status(500).json({ message: "Failed to mark moment as shared" });
    }
  });

  // Dismiss a moment
  app.post("/api/shareable-moments/:id/dismiss", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const result = await storage.dismissMoment(id);
      if (!result) {
        return res.status(404).json({ message: "Moment not found" });
      }
      return res.json(result);
    } catch (error) {
      console.error("Error dismissing moment:", error);
      return res.status(500).json({ message: "Failed to dismiss moment" });
    }
  });

  // Add campaign details (Admin only)
  app.post("/api/campaigns/:campaignId/details", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { campaignId } = req.params;
      const { targetAudience, countryCode, subregion, incentiveType, incentiveValue, incentiveRules, maxRedemptions } = req.body;

      const campaign = await storage.getMarketingCampaign(campaignId);
      if (!campaign) {
        return res.status(404).json({ message: "Campaign not found" });
      }

      const detail = await storage.createCampaignDetail({
        campaignId,
        targetAudience,
        countryCode,
        subregion,
        incentiveType,
        incentiveValue,
        incentiveRules,
        maxRedemptions,
      });

      await storage.createAuditLog({
        userId,
        action: "campaign_detail_created",
        entityType: "campaign_detail",
        entityId: detail.id,
        metadata: JSON.stringify({ campaignId }),
      });

      return res.json(detail);
    } catch (error) {
      console.error("Error creating campaign detail:", error);
      return res.status(500).json({ message: "Failed to create campaign detail" });
    }
  });

  // Get all campaigns with details (Admin only)
  app.get("/api/campaigns/with-details", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const campaigns = await storage.getCampaignsWithDetails();
      return res.json(campaigns);
    } catch (error) {
      console.error("Error getting campaigns with details:", error);
      return res.status(500).json({ message: "Failed to get campaigns with details" });
    }
  });

  // Create reactivation rule (Admin only)
  app.post("/api/reactivation-rules", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { name, targetRole, inactiveDaysThreshold, messageTitle, messageBody, incentiveType, incentiveValue, countryCode } = req.body;

      if (!name || !targetRole || !messageTitle || !messageBody) {
        return res.status(400).json({ message: "Name, targetRole, messageTitle, and messageBody are required" });
      }

      const rule = await storage.createReactivationRule({
        name,
        targetRole,
        inactiveDaysThreshold: inactiveDaysThreshold || 14,
        messageTitle,
        messageBody,
        incentiveType,
        incentiveValue,
        countryCode,
        createdBy: userId,
      });

      await storage.createAuditLog({
        userId,
        action: "reactivation_rule_created",
        entityType: "reactivation_rule",
        entityId: rule.id,
        metadata: JSON.stringify({ name, targetRole }),
      });

      return res.json(rule);
    } catch (error) {
      console.error("Error creating reactivation rule:", error);
      return res.status(500).json({ message: "Failed to create reactivation rule" });
    }
  });

  // Get all reactivation rules (Admin only)
  app.get("/api/reactivation-rules", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const rules = await storage.getReactivationRules();
      return res.json(rules);
    } catch (error) {
      console.error("Error getting reactivation rules:", error);
      return res.status(500).json({ message: "Failed to get reactivation rules" });
    }
  });

  // Update reactivation rule status (Admin only)
  app.patch("/api/reactivation-rules/:ruleId/status", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { ruleId } = req.params;
      const { status } = req.body;

      if (!status || !["ACTIVE", "PAUSED", "ENDED"].includes(status)) {
        return res.status(400).json({ message: "Status must be ACTIVE, PAUSED, or ENDED" });
      }

      const rule = await storage.updateReactivationRuleStatus(ruleId, status);
      if (!rule) {
        return res.status(404).json({ message: "Reactivation rule not found" });
      }

      await storage.createAuditLog({
        userId,
        action: "reactivation_rule_status_updated",
        entityType: "reactivation_rule",
        entityId: ruleId,
        metadata: JSON.stringify({ status }),
      });

      return res.json(rule);
    } catch (error) {
      console.error("Error updating reactivation rule status:", error);
      return res.status(500).json({ message: "Failed to update reactivation rule status" });
    }
  });

  // Get attribution stats (Admin only)
  app.get("/api/attribution/stats", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const stats = await storage.getAttributionStats();
      return res.json(stats);
    } catch (error) {
      console.error("Error getting attribution stats:", error);
      return res.status(500).json({ message: "Failed to get attribution stats" });
    }
  });

  // Get my attribution source
  app.get("/api/attribution/my", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const attribution = await storage.getMarketingAttribution(userId);
      return res.json(attribution);
    } catch (error) {
      console.error("Error getting attribution:", error);
      return res.status(500).json({ message: "Failed to get attribution" });
    }
  });

  // Get growth safety status (Admin only)
  app.get("/api/growth-safety", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const status = await storage.getGrowthSafetyStatus();
      return res.json(status);
    } catch (error) {
      console.error("Error getting growth safety status:", error);
      return res.status(500).json({ message: "Failed to get growth safety status" });
    }
  });

  // Update growth safety controls (Admin only)
  app.post("/api/growth-safety", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { controlType, enabled, countryCode, maxReferralRewardPerUser, maxDailyReferrals, viralityEnabled, shareMomentsEnabled, reactivationEnabled } = req.body;

      if (!controlType) {
        return res.status(400).json({ message: "controlType is required" });
      }

      const control = await storage.upsertGrowthSafetyControl({
        controlType,
        enabled: enabled ?? true,
        countryCode: countryCode || null,
        maxReferralRewardPerUser,
        maxDailyReferrals,
        viralityEnabled: viralityEnabled ?? true,
        shareMomentsEnabled: shareMomentsEnabled ?? true,
        reactivationEnabled: reactivationEnabled ?? true,
        updatedBy: userId,
      });

      await storage.createAuditLog({
        userId,
        action: "growth_safety_control_updated",
        entityType: "growth_safety_control",
        entityId: control.id,
        metadata: JSON.stringify({ controlType, countryCode }),
      });

      return res.json(control);
    } catch (error) {
      console.error("Error updating growth safety control:", error);
      return res.status(500).json({ message: "Failed to update growth safety control" });
    }
  });

  // Phase 20 - Post-Launch Monitoring & Feature Flags

  // Get metrics overview (Admin, Finance)
  app.get("/api/metrics/overview", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const overview = await storage.getMetricsOverview();
      return res.json(overview);
    } catch (error) {
      console.error("Error getting metrics overview:", error);
      return res.status(500).json({ message: "Failed to get metrics overview" });
    }
  });

  // Get platform metrics (Admin, Finance)
  app.get("/api/metrics/platform", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const metrics = await storage.getPlatformMetrics();
      return res.json(metrics);
    } catch (error) {
      console.error("Error getting platform metrics:", error);
      return res.status(500).json({ message: "Failed to get platform metrics" });
    }
  });

  // Get rider metrics (Admin, Finance)
  app.get("/api/metrics/riders", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const metrics = await storage.getRiderMetrics();
      return res.json(metrics);
    } catch (error) {
      console.error("Error getting rider metrics:", error);
      return res.status(500).json({ message: "Failed to get rider metrics" });
    }
  });

  // Get driver metrics (Admin, Finance)
  app.get("/api/metrics/drivers", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const metrics = await storage.getDriverMetrics();
      return res.json(metrics);
    } catch (error) {
      console.error("Error getting driver metrics:", error);
      return res.status(500).json({ message: "Failed to get driver metrics" });
    }
  });

  // Get organization metrics (Admin, Finance)
  app.get("/api/metrics/organizations", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const metrics = await storage.getOrganizationMetrics();
      return res.json(metrics);
    } catch (error) {
      console.error("Error getting organization metrics:", error);
      return res.status(500).json({ message: "Failed to get organization metrics" });
    }
  });

  // Get financial metrics (Admin, Finance)
  app.get("/api/metrics/financials", isAuthenticated, requireRole(["admin", "finance"]), async (req: any, res) => {
    try {
      const metrics = await storage.getFinancialMetrics();
      return res.json(metrics);
    } catch (error) {
      console.error("Error getting financial metrics:", error);
      return res.status(500).json({ message: "Failed to get financial metrics" });
    }
  });

  // Get all feature flags (Admin only)
  app.get("/api/feature-flags", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const flags = await storage.getAllFeatureFlags();
      return res.json(flags);
    } catch (error) {
      console.error("Error getting feature flags:", error);
      return res.status(500).json({ message: "Failed to get feature flags" });
    }
  });

  // Create feature flag (Admin only)
  app.post("/api/feature-flags", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { name, description, enabled, rolloutPercentage } = req.body;

      if (!name) {
        return res.status(400).json({ message: "Feature flag name is required" });
      }

      const existing = await storage.getFeatureFlag(name);
      if (existing) {
        return res.status(400).json({ message: "Feature flag with this name already exists" });
      }

      const flag = await storage.createFeatureFlag({
        name,
        description: description || null,
        enabled: enabled || false,
        rolloutPercentage: rolloutPercentage || 0
      });

      await storage.createAuditLog({
        action: "feature_flag_created",
        entityType: "feature_flag",
        entityId: flag.id,
        performedByUserId: userId,
        performedByRole: "admin",
        metadata: JSON.stringify({ name, enabled, rolloutPercentage })
      });

      return res.json(flag);
    } catch (error) {
      console.error("Error creating feature flag:", error);
      return res.status(500).json({ message: "Failed to create feature flag" });
    }
  });

  // Update feature flag (Admin only)
  app.patch("/api/feature-flags/:name", isAuthenticated, requireRole(["admin"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { name } = req.params;
      const { enabled, rolloutPercentage, description } = req.body;

      const existing = await storage.getFeatureFlag(name);
      if (!existing) {
        return res.status(404).json({ message: "Feature flag not found" });
      }

      const updated = await storage.updateFeatureFlag(name, {
        enabled: enabled !== undefined ? enabled : existing.enabled,
        rolloutPercentage: rolloutPercentage !== undefined ? rolloutPercentage : existing.rolloutPercentage,
        description: description !== undefined ? description : existing.description
      });

      await storage.createAuditLog({
        action: "feature_flag_updated",
        entityType: "feature_flag",
        entityId: existing.id,
        performedByUserId: userId,
        performedByRole: "admin",
        metadata: JSON.stringify({ 
          name, 
          previousEnabled: existing.enabled, 
          newEnabled: updated?.enabled,
          previousRollout: existing.rolloutPercentage,
          newRollout: updated?.rolloutPercentage
        })
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error updating feature flag:", error);
      return res.status(500).json({ message: "Failed to update feature flag" });
    }
  });

  // Check if feature is enabled for current user
  app.get("/api/feature-flags/:name/check", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { name } = req.params;
      const enabled = await storage.isFeatureEnabled(name, userId);
      return res.json({ enabled });
    } catch (error) {
      console.error("Error checking feature flag:", error);
      return res.status(500).json({ message: "Failed to check feature flag" });
    }
  });

  // ================================================
  // Phase 22 - Enhanced Ride Lifecycle Routes
  // ================================================

  // Create a new ride request (Rider action)
  app.post("/api/rides", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      
      // Verify user is a rider
      const role = await storage.getUserRole(userId);
      if (role?.role !== "rider") {
        return res.status(403).json({ message: "Only riders can request rides" });
      }

      const { pickupLat, pickupLng, pickupAddress, dropoffLat, dropoffLng, dropoffAddress, passengerCount, paymentMethodId } = req.body;

      // Validate required fields
      if (!pickupLat || !pickupLng || !dropoffLat || !dropoffLng) {
        return res.status(400).json({ message: "Pickup and dropoff coordinates are required" });
      }

      // CURRENCY LOCK: Get currency from rider's country (MANDATORY)
      const { getCurrencyFromCountry } = await import("@shared/currency");
      const userRole = await storage.getUserRole(userId);
      const riderCountryCode = userRole?.countryCode || "NG";
      const currencyCode = getCurrencyFromCountry(riderCountryCode);

      // Get or create rider wallet with user's country currency
      let riderWallet = await storage.getRiderWallet(userId);
      if (!riderWallet) {
        riderWallet = await storage.createRiderWallet({ userId, currency: currencyCode });
      }

      // Validate rider's wallet currency matches country currency
      if (riderWallet.currency !== currencyCode) {
        return res.status(400).json({ 
          message: `Currency mismatch: Your wallet (${riderWallet.currency}) does not match your country currency (${currencyCode})`,
          error: "CURRENCY_MISMATCH"
        });
      }

      // Check if wallet is frozen
      if (riderWallet.isFrozen) {
        console.log(`[SECURITY AUDIT] Frozen wallet ride request attempt: userId=${userId}`);
        return res.status(403).json({ 
          message: "Your wallet is frozen. Please contact support.",
          code: "WALLET_FROZEN"
        });
      }

      // SERVER-SIDE PAYMENT SOURCE RESOLUTION
      const isTester = await storage.isUserTester(userId);
      
      // Resolve payment source based on tester status and requested payment method
      let resolvedPaymentSource: "TEST_WALLET" | "MAIN_WALLET" | "CARD" | "BANK";
      let paymentMethod = null;
      
      if (isTester) {
        // RULE: Testers MUST use TEST_WALLET only - no exceptions
        resolvedPaymentSource = "TEST_WALLET";
        console.log(`[PAYMENT SOURCE] Tester user ${userId} - forcing TEST_WALLET`);
      } else if (paymentMethodId) {
        // Non-tester with saved payment method - validate and use CARD
        paymentMethod = await storage.getRiderPaymentMethod(paymentMethodId);
        
        if (!paymentMethod || paymentMethod.userId !== userId) {
          return res.status(400).json({ 
            message: "Invalid payment method",
            code: "INVALID_PAYMENT_METHOD"
          });
        }
        
        if (!paymentMethod.isActive) {
          return res.status(400).json({ 
            message: "This payment method is no longer active",
            code: "PAYMENT_METHOD_INACTIVE"
          });
        }
        
        // RULE: Payment method currency MUST match ride currency
        if (paymentMethod.currency !== currencyCode) {
          return res.status(400).json({ 
            message: `Payment method currency (${paymentMethod.currency}) does not match ride currency (${currencyCode})`,
            code: "PAYMENT_CURRENCY_MISMATCH"
          });
        }
        
        if (paymentMethod.type === "CARD") {
          resolvedPaymentSource = "CARD";
        } else if (paymentMethod.type === "BANK_TRANSFER") {
          // RULE: BANK_TRANSFER is future-only, not active
          return res.status(400).json({ 
            message: "Bank transfer payments are not yet available",
            code: "BANK_TRANSFER_NOT_AVAILABLE"
          });
        } else {
          resolvedPaymentSource = "MAIN_WALLET";
        }
      } else {
        // Non-tester without payment method - use MAIN_WALLET
        resolvedPaymentSource = "MAIN_WALLET";
      }

      // AUTHORIZATION LOGIC based on payment source
      let availableBalance: number;
      let walletType: string;
      const minimumRequiredBalance = 5.00; // Minimum 5.00

      if (resolvedPaymentSource === "TEST_WALLET") {
        availableBalance = parseFloat(String(riderWallet.testerWalletBalance || "0"));
        walletType = "TEST";
        console.log(`[WALLET AUTH] Tester ${userId} - TEST_WALLET balance: ${availableBalance}`);
        
        if (availableBalance < minimumRequiredBalance) {
          return res.status(400).json({ 
            message: "Insufficient test wallet balance. Please contact support for test credit.",
            code: "INSUFFICIENT_BALANCE",
            paymentSource: resolvedPaymentSource,
            required: minimumRequiredBalance,
            available: availableBalance
          });
        }
      } else if (resolvedPaymentSource === "MAIN_WALLET") {
        availableBalance = parseFloat(String(riderWallet.balance || "0")) - parseFloat(String(riderWallet.lockedBalance || "0"));
        walletType = "MAIN";
        console.log(`[WALLET AUTH] User ${userId} - MAIN_WALLET balance: ${availableBalance}`);
        
        if (availableBalance < minimumRequiredBalance) {
          return res.status(400).json({ 
            message: "Insufficient wallet balance. Please add funds to continue.",
            code: "INSUFFICIENT_BALANCE",
            paymentSource: resolvedPaymentSource,
            required: minimumRequiredBalance,
            available: availableBalance
          });
        }
      } else if (resolvedPaymentSource === "CARD") {
        // CARD: Check country has real payments enabled
        const country = await storage.getCountryByCode(riderCountryCode);
        if (!country?.paymentsEnabled) {
          return res.status(400).json({ 
            message: "Card payments are not available in your region yet",
            code: "CARD_PAYMENTS_NOT_ENABLED"
          });
        }
        
        // Card authorization happens at ride start, not request
        // For now, we validate the card is reusable
        if (!paymentMethod?.providerReusable) {
          return res.status(400).json({ 
            message: "This card cannot be used for payments",
            code: "CARD_NOT_REUSABLE"
          });
        }
        
        walletType = "CARD";
        console.log(`[CARD AUTH] User ${userId} - CARD payment method validated`);
      }

      // Update wallet's payment source to match resolved source
      if (riderWallet.paymentSource !== resolvedPaymentSource) {
        await storage.updateRiderWalletPaymentSource(userId, resolvedPaymentSource);
      }

      // Create the ride with payment source snapshot
      const { getRideClassMultiplier, isValidRideClass, getRideClass } = await import("@shared/ride-classes");
      const selectedRideClass = req.body.rideClass && isValidRideClass(req.body.rideClass) ? req.body.rideClass : "go";
      const rideClassMultiplier = getRideClassMultiplier(selectedRideClass);

      // Edge case: Verify class is still active
      const classConfig = getRideClass(selectedRideClass);
      if (!classConfig.isActive) {
        return res.status(400).json({
          message: "This ride class is currently unavailable in your area. Please choose a different ride class.",
          code: "RIDE_CLASS_DISABLED",
          rideClass: selectedRideClass,
        });
      }

      const ride = await storage.createRide({
        riderId: userId,
        pickupLat: pickupLat.toString(),
        pickupLng: pickupLng.toString(),
        pickupAddress: pickupAddress || null,
        dropoffLat: dropoffLat.toString(),
        dropoffLng: dropoffLng.toString(),
        dropoffAddress: dropoffAddress || null,
        passengerCount: passengerCount || 1,
        currencyCode,
        paymentSource: resolvedPaymentSource,
        paymentMethodId: paymentMethod?.id || null,
        rideClass: selectedRideClass,
        fareMultiplier: rideClassMultiplier.toString(),
      });

      console.log(`[RIDE CREATED] rideId=${ride.id}, userId=${userId}, paymentSource=${resolvedPaymentSource}, currency=${currencyCode}, isTester=${isTester}`);

      // Log the action
      await storage.createRideAuditLog({
        rideId: ride.id,
        action: "ride_requested",
        actorId: userId,
        actorRole: "rider",
        previousStatus: null,
        newStatus: "matching",
        metadata: JSON.stringify({ pickupAddress, dropoffAddress, paymentSource: resolvedPaymentSource }),
      });

      return res.status(201).json(ride);
    } catch (error) {
      console.error("Error creating ride:", error);
      return res.status(500).json({ message: "Failed to create ride" });
    }
  });

  // Get available rides for drivers (matching status)
  app.get("/api/rides/available", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      
      // Verify user is a driver
      const role = await storage.getUserRole(userId);
      if (role?.role !== "driver") {
        return res.status(403).json({ message: "Only drivers can view available rides" });
      }

      const rides = await storage.getRidesByStatus("matching");
      
      // Filter out expired matching windows
      const now = new Date();
      const activeRides = rides.filter(ride => 
        !ride.matchingExpiresAt || new Date(ride.matchingExpiresAt) > now
      );

      return res.json(activeRides);
    } catch (error) {
      console.error("Error fetching available rides:", error);
      return res.status(500).json({ message: "Failed to fetch available rides" });
    }
  });

  // Get ride by ID
  app.get("/api/rides/:rideId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { rideId } = req.params;

      const ride = await storage.getRideById(rideId);
      if (!ride) {
        return res.status(404).json({ message: "Ride not found" });
      }

      // Only rider, assigned driver, or admin can view
      const role = await storage.getUserRole(userId);
      if (ride.riderId !== userId && ride.driverId !== userId && role?.role !== "admin") {
        return res.status(403).json({ message: "Not authorized to view this ride" });
      }

      return res.json(ride);
    } catch (error) {
      console.error("Error fetching ride:", error);
      return res.status(500).json({ message: "Failed to fetch ride" });
    }
  });

  // Get rider's rides
  app.get("/api/rides/rider/me", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const rides = await storage.getRiderRides(userId);
      return res.json(rides);
    } catch (error) {
      console.error("Error fetching rider rides:", error);
      return res.status(500).json({ message: "Failed to fetch rides" });
    }
  });

  // Get rider's current active ride
  app.get("/api/rides/rider/current", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const ride = await storage.getCurrentRiderRide(userId);
      
      if (ride && ride.driverId) {
        const driverProfile = await storage.getDriverProfile(ride.driverId);
        if (driverProfile) {
          return res.json({
            ...ride,
            driverName: driverProfile.fullName,
            driverPhone: driverProfile.phone,
            driverVehicle: `${driverProfile.vehicleMake} ${driverProfile.vehicleModel}`,
            driverLicensePlate: driverProfile.licensePlate,
            driverRating: driverProfile.averageRating,
          });
        }
      }
      
      return res.json(ride);
    } catch (error) {
      console.error("Error fetching current rider ride:", error);
      return res.status(500).json({ message: "Failed to fetch current ride" });
    }
  });

  // Get driver's current active ride
  app.get("/api/rides/driver/current", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      
      const role = await storage.getUserRole(userId);
      if (role?.role !== "driver") {
        return res.status(403).json({ message: "Only drivers can access this" });
      }
      
      const ride = await storage.getCurrentDriverRide(userId);
      
      if (ride && ride.riderId) {
        const riderProfile = await storage.getRiderProfile(ride.riderId);
        if (riderProfile) {
          return res.json({
            ...ride,
            riderName: riderProfile.fullName || "Rider",
          });
        }
      }
      
      return res.json(ride);
    } catch (error) {
      console.error("Error fetching current driver ride:", error);
      return res.status(500).json({ message: "Failed to fetch current ride" });
    }
  });

  // Get driver's rides
  app.get("/api/rides/driver/me", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const rides = await storage.getDriverRides(userId);
      return res.json(rides);
    } catch (error) {
      console.error("Error fetching driver rides:", error);
      return res.status(500).json({ message: "Failed to fetch rides" });
    }
  });

  // Driver accepts a ride
  app.post("/api/rides/:rideId/accept", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { rideId } = req.params;

      // Verify user is a driver
      const role = await storage.getUserRole(userId);
      if (role?.role !== "driver") {
        return res.status(403).json({ message: "Only drivers can accept rides" });
      }

      // MANDATORY SETUP CHECK - Block ride acceptance if setup incomplete
      const driverProfile = await storage.getDriverProfile(userId);
      if (driverProfile) {
        const missingFields: string[] = [];
        if (driverProfile.locationPermissionStatus !== "granted") missingFields.push("locationPermission");
        if (!driverProfile.navigationProvider) missingFields.push("navigationProvider");
        if (!driverProfile.navigationVerified) missingFields.push("navigationVerified");
        
        if (missingFields.length > 0) {
          return res.status(403).json({ 
            message: "Driver setup incomplete",
            error: "DRIVER_SETUP_INCOMPLETE",
            missingFields,
            setupCompleted: false
          });
        }
      }

      const ride = await storage.getRideById(rideId);
      if (!ride) {
        return res.status(404).json({ message: "Ride not found" });
      }

      // Ride class eligibility check
      if (ride.rideClass && ride.rideClass !== "go") {
        const { getDriverEligibleClasses } = await import("@shared/ride-classes");
        const driverRating = driverProfile?.averageRating ? parseFloat(String(driverProfile.averageRating)) : 0;
        const vehicleYear = driverProfile?.vehicleYear ? parseInt(String(driverProfile.vehicleYear)) : null;
        const eligibleClasses = getDriverEligibleClasses({
          driverRating,
          vehicleYear,
          hasPetApproval: !!(driverProfile as any)?.petApproved,
          hasBackgroundCheck: !!(driverProfile as any)?.backgroundCheckVerified,
          hasEliteApproval: !!(driverProfile as any)?.eliteApproved,
        });
        const isEligible = eligibleClasses.some(ec => ec.id === ride.rideClass);
        if (!isEligible) {
          return res.status(403).json({
            message: "You are not eligible for this ride class",
            code: "RIDE_CLASS_INELIGIBLE",
            rideClass: ride.rideClass,
          });
        }
      }

      // Validate action using lifecycle rules
      const { validateAction } = await import("./ride-lifecycle.js");
      const validation = validateAction("accept_ride", "driver", ride.status as any, {
        matchingExpiresAt: ride.matchingExpiresAt,
      });

      if (!validation.allowed) {
        return res.status(400).json({ message: validation.error });
      }

      const updatedRide = await storage.assignDriverToRide(rideId, userId);

      // Log the action
      await storage.createRideAuditLog({
        rideId,
        action: "ride_accepted",
        actorId: userId,
        actorRole: "driver",
        previousStatus: ride.status,
        newStatus: "accepted",
      });

      // Notify rider
      await storage.createNotification({
        userId: ride.riderId,
        role: "rider",
        title: "Driver Assigned",
        type: "ride_update",
        message: "Your driver is on the way!",
      });

      return res.json(updatedRide);
    } catch (error: any) {
      console.error("Error accepting ride:", error);
      return res.status(500).json({ message: error.message || "Failed to accept ride" });
    }
  });

  // Driver starts pickup navigation
  app.post("/api/rides/:rideId/start-pickup", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { rideId } = req.params;

      const ride = await storage.getRideById(rideId);
      if (!ride) {
        return res.status(404).json({ message: "Ride not found" });
      }

      // Validate driver is assigned
      if (ride.driverId !== userId) {
        return res.status(403).json({ message: "Only the assigned driver can perform this action" });
      }

      const { validateAction, isValidTransition } = await import("./ride-lifecycle.js");
      const validation = validateAction("start_pickup", "driver", ride.status as any, {
        isAssignedDriver: true,
      });

      if (!validation.allowed) {
        return res.status(400).json({ message: validation.error });
      }

      // Validate state transition
      const transition = isValidTransition(ride.status as any, "driver_en_route");
      if (!transition.valid) {
        return res.status(400).json({ message: transition.error });
      }

      const updatedRide = await storage.updateRideStatus(rideId, "driver_en_route");

      // Log the action
      await storage.createRideAuditLog({
        rideId,
        action: "pickup_started",
        actorId: userId,
        actorRole: "driver",
        previousStatus: ride.status,
        newStatus: "driver_en_route",
      });

      return res.json(updatedRide);
    } catch (error) {
      console.error("Error starting pickup:", error);
      return res.status(500).json({ message: "Failed to start pickup" });
    }
  });

  // Driver arrives at pickup
  app.post("/api/rides/:rideId/arrive", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { rideId } = req.params;

      const ride = await storage.getRideById(rideId);
      if (!ride) {
        return res.status(404).json({ message: "Ride not found" });
      }

      if (ride.driverId !== userId) {
        return res.status(403).json({ message: "Only the assigned driver can perform this action" });
      }

      const { validateAction, isValidTransition } = await import("./ride-lifecycle.js");
      const validation = validateAction("arrive", "driver", ride.status as any, {
        isAssignedDriver: true,
      });

      if (!validation.allowed) {
        return res.status(400).json({ message: validation.error });
      }

      const transition = isValidTransition(ride.status as any, "arrived");
      if (!transition.valid) {
        return res.status(400).json({ message: transition.error });
      }

      const updatedRide = await storage.updateRideStatus(rideId, "arrived");

      // Log the action
      await storage.createRideAuditLog({
        rideId,
        action: "driver_arrived",
        actorId: userId,
        actorRole: "driver",
        previousStatus: ride.status,
        newStatus: "arrived",
      });

      // Notify rider
      await storage.createNotification({
        userId: ride.riderId,
        role: "rider",
        title: "Driver Arrived",
        type: "ride_update",
        message: "Your driver has arrived!",
      });

      return res.json(updatedRide);
    } catch (error) {
      console.error("Error marking arrival:", error);
      return res.status(500).json({ message: "Failed to mark arrival" });
    }
  });

  // System/Driver starts waiting period
  app.post("/api/rides/:rideId/start-waiting", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { rideId } = req.params;

      const ride = await storage.getRideById(rideId);
      if (!ride) {
        return res.status(404).json({ message: "Ride not found" });
      }

      if (ride.driverId !== userId) {
        return res.status(403).json({ message: "Only the assigned driver can perform this action" });
      }

      const { isValidTransition } = await import("./ride-lifecycle.js");
      const transition = isValidTransition(ride.status as any, "waiting");
      if (!transition.valid) {
        return res.status(400).json({ message: transition.error });
      }

      const updatedRide = await storage.updateRideStatus(rideId, "waiting");

      // Log the action
      await storage.createRideAuditLog({
        rideId,
        action: "waiting_started",
        actorId: userId,
        actorRole: "driver",
        previousStatus: ride.status,
        newStatus: "waiting",
      });

      return res.json(updatedRide);
    } catch (error) {
      console.error("Error starting waiting:", error);
      return res.status(500).json({ message: "Failed to start waiting period" });
    }
  });

  // Driver starts the trip
  app.post("/api/rides/:rideId/start-trip", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { rideId } = req.params;

      const ride = await storage.getRideById(rideId);
      if (!ride) {
        return res.status(404).json({ message: "Ride not found" });
      }

      if (ride.driverId !== userId) {
        return res.status(403).json({ message: "Only the assigned driver can perform this action" });
      }

      const { validateAction, isValidTransition, calculateWaitingTime } = await import("./ride-lifecycle.js");
      const validation = validateAction("start_trip", "driver", ride.status as any, {
        isAssignedDriver: true,
      });

      if (!validation.allowed) {
        return res.status(400).json({ message: validation.error });
      }

      const transition = isValidTransition(ride.status as any, "in_progress");
      if (!transition.valid) {
        return res.status(400).json({ message: transition.error });
      }

      // Calculate waiting time if applicable
      let waitingData: any = {};
      if (ride.waitingStartedAt) {
        const waiting = calculateWaitingTime(ride.waitingStartedAt);
        waitingData = {
          waitingPaidMin: waiting.paidMinutes + waiting.bonusMinutes,
        };
      }

      const updatedRide = await storage.updateRideStatus(rideId, "in_progress", {
        ...waitingData,
        lastMovementAt: new Date(),
      });

      // Log the action
      await storage.createRideAuditLog({
        rideId,
        action: "trip_started",
        actorId: userId,
        actorRole: "driver",
        previousStatus: ride.status,
        newStatus: "in_progress",
        metadata: JSON.stringify(waitingData),
      });

      return res.json(updatedRide);
    } catch (error) {
      console.error("Error starting trip:", error);
      return res.status(500).json({ message: "Failed to start trip" });
    }
  });

  // Driver completes the trip
  app.post("/api/rides/:rideId/complete", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { rideId } = req.params;
      const { confirmFinalDestination, isEarlyStop } = req.body;

      const ride = await storage.getRideById(rideId);
      if (!ride) {
        return res.status(404).json({ message: "Ride not found" });
      }

      if (ride.driverId !== userId) {
        return res.status(403).json({ message: "Only the assigned driver can perform this action" });
      }

      const { validateAction, isValidTransition } = await import("./ride-lifecycle.js");
      const validation = validateAction("complete_trip", "driver", ride.status as any, {
        isAssignedDriver: true,
      });

      if (!validation.allowed) {
        return res.status(400).json({ message: validation.error });
      }

      // Require confirmation that this is the final destination
      if (confirmFinalDestination !== true) {
        return res.status(400).json({ 
          message: "Please confirm this is the final destination",
          requiresConfirmation: true 
        });
      }

      const transition = isValidTransition(ride.status as any, "completed");
      if (!transition.valid) {
        return res.status(400).json({ message: transition.error });
      }

      // Calculate trip duration
      const startedAt = ride.startedAt ? new Date(ride.startedAt) : new Date();
      const completedAt = new Date();
      const tripDurationMin = (completedAt.getTime() - startedAt.getTime()) / (1000 * 60);

      // Get total distance from driver movements
      const movement = await storage.getTotalDriverMovement(rideId);
      const actualDistanceKm = movement.distanceKm;

      // Import fare calculation module
      const { 
        calculateCompleteFare, 
        generateFareReceipt,
        recalculateFareForEarlyStop 
      } = await import("./fare-calculation.js");

      // Calculate fare with all components
      const currencyCode = ride.currencyCode || "NGN";
      const fareBreakdown = calculateCompleteFare({
        distanceKm: actualDistanceKm,
        durationMin: tripDurationMin,
        estimatedDurationMin: parseFloat(ride.estimatedDurationMin || "0"),
        waitingStartedAt: ride.waitingStartedAt ? new Date(ride.waitingStartedAt) : null,
        tripEndedAt: completedAt,
        currencyCode,
        fareMultiplier: parseFloat(ride.fareMultiplier || "1.00"),
      });

      // Handle early stop case
      let earlyStopData = null;
      if (isEarlyStop) {
        earlyStopData = recalculateFareForEarlyStop({
          originalEstimatedKm: parseFloat(ride.estimatedDistanceKm || "0"),
          actualDistanceKm,
          originalEstimatedMin: parseFloat(ride.estimatedDurationMin || "0"),
          actualDurationMin: tripDurationMin,
          waitingStartedAt: ride.waitingStartedAt ? new Date(ride.waitingStartedAt) : null,
          tripEndedAt: completedAt,
          currencyCode
        });
      }

      // Update ride with final fare breakdown
      const updatedRide = await storage.updateRideStatus(rideId, "completed", {
        actualDurationMin: tripDurationMin.toString(),
        actualDistanceKm: actualDistanceKm.toString(),
        baseFare: fareBreakdown.baseFare.toString(),
        distanceFare: fareBreakdown.distanceFare.toString(),
        timeFare: fareBreakdown.timeFare.toString(),
        waitingFee: fareBreakdown.waitingFee.toString(),
        trafficFee: fareBreakdown.trafficFee.toString(),
        totalFare: fareBreakdown.totalFare.toString(),
        driverEarning: fareBreakdown.driverEarning.toString(),
        platformFee: fareBreakdown.platformFee.toString(),
        earlyStopConfirmed: isEarlyStop || false,
      });

      // Get driver info for receipt
      const driverProfile = await storage.getDriverProfile(userId);

      // Generate receipt
      const receipt = generateFareReceipt({
        rideId,
        fareBreakdown,
        pickupAddress: ride.pickupAddress || "Pickup location",
        dropoffAddress: ride.dropoffAddress || "Dropoff location",
        distanceKm: actualDistanceKm,
        durationMin: tripDurationMin,
        driverName: driverProfile?.fullName || "Your driver",
        completedAt
      });

      // Log the action
      await storage.createRideAuditLog({
        rideId,
        action: "trip_completed",
        actorId: userId,
        actorRole: "driver",
        previousStatus: ride.status,
        newStatus: "completed",
        metadata: JSON.stringify({ 
          tripDurationMin,
          fareBreakdown,
          receipt,
          earlyStopData,
          isEarlyStop: isEarlyStop || false
        }),
      });

      // PAYMENT CAPTURE & SETTLEMENT based on paymentSource
      const paymentSource = ride.paymentSource || "MAIN_WALLET";
      const riderRole = await storage.getUserRole(ride.riderId);
      const isTestRide = Boolean(riderRole?.isTester);
      
      let captureSucceeded = true;
      let captureError: string | null = null;
      
      try {
        if (paymentSource === "TEST_WALLET") {
          // Debit tester wallet
          const riderWallet = await storage.getRiderWallet(ride.riderId);
          if (riderWallet) {
            const currentBalance = parseFloat(String(riderWallet.testerWalletBalance || "0"));
            if (currentBalance >= fareBreakdown.totalFare) {
              await storage.adjustRiderTesterWalletBalance(
                ride.riderId, 
                -fareBreakdown.totalFare, 
                `RIDE_FARE: ${rideId}`, 
                "system"
              );
              console.log(`[PAYMENT CAPTURE] TEST_WALLET debited ${fareBreakdown.totalFare} ${currencyCode} for ride ${rideId}`);
            } else {
              captureSucceeded = false;
              captureError = "Insufficient test wallet balance";
            }
          }
        } else if (paymentSource === "MAIN_WALLET") {
          // Debit main wallet
          const riderWallet = await storage.getRiderWallet(ride.riderId);
          if (riderWallet) {
            const availableBalance = parseFloat(String(riderWallet.balance || "0")) - parseFloat(String(riderWallet.lockedBalance || "0"));
            if (availableBalance >= fareBreakdown.totalFare) {
              await storage.adjustRiderWalletBalance(
                ride.riderId, 
                -fareBreakdown.totalFare, 
                `RIDE_FARE: ${rideId}`, 
                "system"
              );
              console.log(`[PAYMENT CAPTURE] MAIN_WALLET debited ${fareBreakdown.totalFare} ${currencyCode} for ride ${rideId}`);
            } else {
              captureSucceeded = false;
              captureError = "Insufficient main wallet balance";
            }
          }
        } else if (paymentSource === "CARD") {
          // Capture card authorization
          // In test mode or if no authorization exists, skip real capture
          if (!ride.authorizationReference) {
            console.log(`[PAYMENT CAPTURE] CARD - No authorization reference, treating as test mode for ride ${rideId}`);
          } else {
            // Real card capture would happen here via payment provider
            // For now, log and mark as captured
            console.log(`[PAYMENT CAPTURE] CARD authorization ${ride.authorizationReference} would be captured for ${fareBreakdown.totalFare} ${currencyCode}`);
            
            // Update ride with capture info
            await storage.updateRideStatus(rideId, "completed", {
              captureAmount: fareBreakdown.totalFare.toString(),
              capturedAt: new Date(),
            });
          }
        }
      } catch (paymentError) {
        console.error(`[PAYMENT CAPTURE FAILED] ride ${rideId}:`, paymentError);
        captureSucceeded = false;
        captureError = paymentError instanceof Error ? paymentError.message : "Payment capture failed";
      }

      // Check auto top-up trigger after wallet debit
      if (captureSucceeded && (paymentSource === "MAIN_WALLET" || paymentSource === "TEST_WALLET")) {
        const shouldTopUp = await storage.shouldTriggerAutoTopUp(ride.riderId);
        if (shouldTopUp) {
          storage.triggerAutoTopUp(ride.riderId).catch(err => console.error("[AUTO_TOPUP] Error:", err));
        }
      }

      // If capture failed, move ride to PAYMENT_REVIEW instead of completed
      if (!captureSucceeded) {
        console.log(`[PAYMENT REVIEW] Ride ${rideId} moved to payment_review: ${captureError}`);
        
        await storage.updateRideStatus(rideId, "payment_review" as any, {
          actualDurationMin: tripDurationMin.toString(),
          actualDistanceKm: actualDistanceKm.toString(),
          baseFare: fareBreakdown.baseFare.toString(),
          distanceFare: fareBreakdown.distanceFare.toString(),
          timeFare: fareBreakdown.timeFare.toString(),
          waitingFee: fareBreakdown.waitingFee.toString(),
          trafficFee: fareBreakdown.trafficFee.toString(),
          totalFare: fareBreakdown.totalFare.toString(),
        });

        // Log payment failure
        await storage.createRideAuditLog({
          rideId,
          action: "payment_failed" as any,
          actorId: "system",
          actorRole: "system",
          previousStatus: ride.status,
          newStatus: "payment_review" as any,
          metadata: JSON.stringify({ 
            captureError,
            paymentSource,
            attemptedAmount: fareBreakdown.totalFare
          }),
        });

        // Driver earnings are protected - still credit driver
        // This ensures driver is paid even if rider payment fails
      }

      // REVENUE SPLIT: 80% driver, 20% platform (MANDATORY)
      // Process even for payment_review rides to protect driver earnings
      const revenueSplit = await storage.processRevenueSplit({
        rideId,
        riderId: ride.riderId,
        driverId: userId,
        totalFare: fareBreakdown.totalFare.toString(),
        currencyCode,
        isTestRide,
      });

      // Notify rider with receipt info (using correct currency)
      const { formatCurrency } = await import("@shared/currency");
      await storage.createNotification({
        userId: ride.riderId,
        role: "rider",
        title: "Trip Complete",
        type: "ride_update",
        message: `Your trip is complete! Total fare: ${formatCurrency(fareBreakdown.totalFare, currencyCode)}. Please rate your driver.`,
      });

      return res.json({
        ...updatedRide,
        fareBreakdown,
        receipt,
        earlyStopData,
        revenueSplit: {
          driverEarning: revenueSplit.driverShare,
          platformFee: revenueSplit.zibaShare,
          currencyCode: revenueSplit.currencyCode,
        }
      });
    } catch (error) {
      console.error("Error completing trip:", error);
      return res.status(500).json({ message: "Failed to complete trip" });
    }
  });

  // Cancel a ride (Rider or Driver)
  app.post("/api/rides/:rideId/cancel", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { rideId } = req.params;
      const { reason, driverCancelReason } = req.body;

      const ride = await storage.getRideById(rideId);
      if (!ride) {
        return res.status(404).json({ message: "Ride not found" });
      }

      // Determine role
      const isRider = ride.riderId === userId;
      const isDriver = ride.driverId === userId;

      if (!isRider && !isDriver) {
        return res.status(403).json({ message: "Only the rider or assigned driver can cancel" });
      }

      const role = isRider ? "rider" : "driver";
      const { validateAction, isDriverEligibleForCompensation } = await import("./ride-lifecycle.js");
      const { 
        calculateCancellationCompensation, 
        canCancelWithoutPenalty,
        isJustifiedCancellation 
      } = await import("./fare-calculation.js");

      // Block rider cancellation during in_progress
      if (isRider && ride.status === "in_progress") {
        return res.status(400).json({ 
          message: "You cannot cancel a ride that is already in progress. Please contact your driver directly.",
          blocked: true 
        });
      }

      // Get driver movement if applicable
      let driverMovement = { distanceKm: 0, durationSec: 0 };
      if (ride.driverId) {
        driverMovement = await storage.getTotalDriverMovement(rideId);
      }

      const validation = validateAction("cancel_ride", role, ride.status as any, {
        driverMovement,
        driverAcceptedAt: ride.acceptedAt ? new Date(ride.acceptedAt) : null,
      });

      if (!validation.allowed) {
        return res.status(400).json({ message: validation.error });
      }

      // Check if reason is required (driver cancelling in_progress)
      if (validation.requiresReason && !reason) {
        return res.status(400).json({ 
          message: "Cancellation reason is required",
          requiresReason: true,
          validReasons: ["rider_requested", "safety_concern", "vehicle_issue", "emergency", "rider_no_show", "other"]
        });
      }

      // Calculate compensation for rider cancellation
      let compensationData = null;
      let compensationEligible = false;
      if (isRider && ride.driverId) {
        compensationData = calculateCancellationCompensation({
          distanceKm: driverMovement.distanceKm,
          durationSec: driverMovement.durationSec,
          waitingStartedAt: ride.waitingStartedAt ? new Date(ride.waitingStartedAt) : null,
          cancelledAt: new Date()
        });
        compensationEligible = compensationData.eligible;
      }

      // For driver cancellation, check if reason is justified
      let driverCompensation = null;
      if (isDriver && driverCancelReason) {
        const justified = isJustifiedCancellation(driverCancelReason);
        if (justified && ["rider_requested", "rider_no_show"].includes(driverCancelReason)) {
          // Driver gets compensated for rider-caused cancellations
          driverCompensation = calculateCancellationCompensation({
            distanceKm: driverMovement.distanceKm,
            durationSec: driverMovement.durationSec,
            waitingStartedAt: ride.waitingStartedAt ? new Date(ride.waitingStartedAt) : null,
            cancelledAt: new Date()
          });
        }
      }

      // Check penalty status for riders
      let penaltyInfo = null;
      if (isRider && ride.waitingStartedAt) {
        penaltyInfo = canCancelWithoutPenalty(new Date(ride.waitingStartedAt));
      }

      const cancelledBy = isRider ? "rider" : "driver";
      const updatedRide = await storage.cancelRide(rideId, cancelledBy, reason, {
        driverCancelReason,
        cancellationFee: compensationData?.riderCharge || null,
        driverCancelCompensation: (compensationData?.driverCompensation || driverCompensation?.driverCompensation) || null,
        platformCancelFee: (compensationData?.platformFee || driverCompensation?.platformFee) || null,
        compensationEligible,
      });

      let feeAmount = 0;
      let feeApplied = false;
      let walletDebitSuccess = false;
      let insufficientBalance = false;

      if (validation.requiresFee && isRider) {
        feeAmount = validation.estimatedFee || (ride.status === "arrived" ? 750 : 500);
        feeApplied = true;

        try {
          const riderWallet = await storage.getRiderWallet(userId);
          const currentBalance = riderWallet ? parseFloat(riderWallet.balance?.toString() || "0") : 0;

          if (currentBalance < feeAmount) {
            insufficientBalance = true;
          }

          await storage.updateRiderWalletBalance(userId, feeAmount, "debit");
          walletDebitSuccess = true;

          if (insufficientBalance) {
            await storage.createFinancialAuditLog({
              rideId,
              userId,
              actorRole: "SYSTEM",
              eventType: "CANCELLATION_FEE",
              amount: feeAmount.toFixed(2),
              currency: "NGN",
              description: `Cancellation fee applied with insufficient balance. Previous balance: ${currentBalance.toFixed(2)}`,
              metadata: JSON.stringify({ feeAmount, previousBalance: currentBalance, insufficientBalance: true }),
            });
          }
        } catch (walletError) {
          console.error("Error debiting rider wallet for cancellation fee:", walletError);
        }

        await storage.createNotification({
          userId,
          role: "rider",
          title: "Cancellation Fee Applied",
          type: "ride_cancelled",
          message: `A cancellation fee of ${feeAmount.toFixed(2)} has been deducted from your wallet.`,
        });

        try {
          await storage.createRiderInboxMessage({
            userId,
            title: "Cancellation Fee Applied",
            body: `A cancellation fee of ${feeAmount.toFixed(2)} has been applied to your account. Check your wallet for details.`,
            type: "trip_update",
          });
        } catch (e) { console.warn("[INBOX] Failed to send cancellation fee message:", e); }

        // Check auto top-up trigger after cancellation fee debit
        if (walletDebitSuccess) {
          const shouldTopUp = await storage.shouldTriggerAutoTopUp(userId);
          if (shouldTopUp) {
            storage.triggerAutoTopUp(userId).catch(err => console.error("[AUTO_TOPUP] Error:", err));
          }
        }
      }

      await storage.createRideAuditLog({
        rideId,
        action: "ride_cancelled",
        actorId: userId,
        actorRole: role,
        previousStatus: ride.status,
        newStatus: "cancelled",
        metadata: JSON.stringify({ 
          reason, 
          driverCancelReason,
          cancelledBy,
          compensationEligible,
          compensationData,
          driverCompensation,
          driverMovement,
          penaltyInfo,
          appliedFee: validation.requiresFee,
          cancellation_timestamp: new Date().toISOString(),
          driver_accept_timestamp: ride.acceptedAt || null,
          driver_en_route_timestamp: ride.enRouteAt || null,
          cancellation_reason: reason || null,
          fee_applied: feeApplied,
          fee_amount: feeAmount,
          grace_period_active: validation.withinGracePeriod || false,
          wallet_debit_success: walletDebitSuccess,
          insufficient_balance: insufficientBalance,
        }),
      });

      if (isRider && ride.driverId) {
        const compensationMsg = compensationEligible 
          ? ` You will receive a compensation of ${((compensationData?.driverCompensation || 0) / 100).toFixed(2)}.`
          : "";
        await storage.createNotification({
          userId: ride.driverId,
          role: "driver",
          title: "Ride Cancelled",
          type: "ride_update",
          message: `The rider has cancelled the ride.${compensationMsg}`,
        });
      } else if (isDriver) {
        await storage.createNotification({
          userId: ride.riderId,
          role: "rider",
          title: "Ride Cancelled",
          type: "ride_update",
          message: "Your driver has cancelled the ride. We'll find you another driver.",
        });
      }

      return res.json({
        ...updatedRide,
        compensationEligible,
        compensationData,
        driverCompensation,
        penaltyInfo,
        feeApplied,
        feeAmount: feeApplied ? feeAmount : undefined,
      });
    } catch (error) {
      console.error("Error cancelling ride:", error);
      return res.status(500).json({ message: "Failed to cancel ride" });
    }
  });

  // Record driver movement (for tracking en route)
  app.post("/api/rides/:rideId/movement", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { rideId } = req.params;
      const { lat, lng, distanceKm, durationSec } = req.body;

      const ride = await storage.getRideById(rideId);
      if (!ride) {
        return res.status(404).json({ message: "Ride not found" });
      }

      if (ride.driverId !== userId) {
        return res.status(403).json({ message: "Only the assigned driver can record movement" });
      }

      // Only track movement during en_route or in_progress
      if (ride.status !== "driver_en_route" && ride.status !== "in_progress") {
        return res.status(400).json({ message: "Movement tracking not active for current status" });
      }

      const movement = await storage.createDriverMovement({
        rideId,
        driverId: userId,
        lat: lat?.toString(),
        lng: lng?.toString(),
        distanceKm: distanceKm?.toString(),
        durationSec,
      });

      // Update last movement timestamp for safety detection
      if (ride.status === "in_progress") {
        await storage.updateRideStatus(rideId, ride.status, {
          lastMovementAt: new Date(),
        });
      }

      return res.json(movement);
    } catch (error) {
      console.error("Error recording movement:", error);
      return res.status(500).json({ message: "Failed to record movement" });
    }
  });

  // Safety check - report safe status
  app.post("/api/rides/:rideId/safety-check", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { rideId } = req.params;
      const { isSafe, message } = req.body;

      const ride = await storage.getRideById(rideId);
      if (!ride) {
        return res.status(404).json({ message: "Ride not found" });
      }

      // Either rider or driver can respond
      if (ride.riderId !== userId && ride.driverId !== userId) {
        return res.status(403).json({ message: "Only ride participants can respond to safety check" });
      }

      const role = ride.riderId === userId ? "rider" : "driver";

      // Log the safety response
      await storage.createRideAuditLog({
        rideId,
        action: "safety_check_response",
        actorId: userId,
        actorRole: role,
        previousStatus: ride.status,
        newStatus: ride.status,
        metadata: JSON.stringify({ isSafe, message, respondedBy: role }),
      });

      // Update safety check timestamp
      await storage.updateRideStatus(rideId, ride.status, {
        safetyCheckAt: new Date(),
      });

      return res.json({ success: true, message: "Safety response recorded" });
    } catch (error) {
      console.error("Error recording safety check:", error);
      return res.status(500).json({ message: "Failed to record safety check" });
    }
  });

  // Get ride audit logs
  app.get("/api/rides/:rideId/audit-logs", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { rideId } = req.params;

      const ride = await storage.getRideById(rideId);
      if (!ride) {
        return res.status(404).json({ message: "Ride not found" });
      }

      // Only rider, driver, or admin can view
      const role = await storage.getUserRole(userId);
      if (ride.riderId !== userId && ride.driverId !== userId && role?.role !== "admin") {
        return res.status(403).json({ message: "Not authorized to view audit logs" });
      }

      const logs = await storage.getRideAuditLogs(rideId);
      return res.json(logs);
    } catch (error) {
      console.error("Error fetching audit logs:", error);
      return res.status(500).json({ message: "Failed to fetch audit logs" });
    }
  });

  // ==========================================
  // Ride Offers Routes
  // ==========================================

  // Get pending ride offer for current driver
  app.get("/api/ride-offers/pending", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const offer = await storage.getPendingRideOfferForDriver(userId);
      
      if (!offer) {
        return res.json(null);
      }

      // Get ride details
      const ride = await storage.getRideById(offer.rideId);
      if (!ride) {
        return res.json(null);
      }

      return res.json({
        ...offer,
        ride: {
          pickupAddress: ride.pickupAddress,
          dropoffAddress: ride.dropoffAddress,
          estimatedFare: ride.totalFare || ride.baseFare,
          passengerCount: ride.passengerCount,
        }
      });
    } catch (error) {
      console.error("Error getting pending offer:", error);
      return res.status(500).json({ message: "Failed to get pending offer" });
    }
  });

  // Accept a ride offer
  app.post("/api/ride-offers/:offerId/accept", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { offerId } = req.params;

      // MANDATORY SETUP CHECK - Block ride acceptance if setup incomplete
      const driverProfile = await storage.getDriverProfile(userId);
      if (driverProfile) {
        // Check if driver is suspended
        if (driverProfile.withdrawalVerificationStatus === "suspended") {
          return res.status(403).json({ 
            message: "Your account is suspended. Contact support for assistance.",
            code: "DRIVER_SUSPENDED"
          });
        }

        const missingFields: string[] = [];
        if (driverProfile.locationPermissionStatus !== "granted") missingFields.push("locationPermission");
        if (!driverProfile.navigationProvider) missingFields.push("navigationProvider");
        if (!driverProfile.navigationVerified) missingFields.push("navigationVerified");
        
        if (missingFields.length > 0) {
          return res.status(403).json({ 
            message: "Driver setup incomplete",
            error: "DRIVER_SETUP_INCOMPLETE",
            missingFields,
            setupCompleted: false
          });
        }
      }

      const offer = await storage.getPendingRideOfferForDriver(userId);
      if (!offer || offer.id !== offerId) {
        return res.status(400).json({ message: "Offer not found or expired" });
      }

      // Check if offer is expired
      if (new Date() > new Date(offer.offerExpiresAt)) {
        await storage.updateRideOfferStatus(offerId, "expired");
        return res.status(400).json({ message: "Offer has expired" });
      }

      const ride = await storage.getRideById(offer.rideId);
      if (!ride || ride.status !== "matching") {
        await storage.updateRideOfferStatus(offerId, "expired");
        return res.status(400).json({ message: "Ride is no longer available" });
      }

      // Accept the offer
      await storage.updateRideOfferStatus(offerId, "accepted");

      // Assign driver to ride
      const updatedRide = await storage.assignDriverToRide(offer.rideId, userId);
      
      if (!updatedRide) {
        return res.status(500).json({ message: "Failed to assign driver to ride" });
      }

      // Expire all other pending offers for this ride
      await storage.expirePendingOffersForRide(offer.rideId, userId);

      // Send notifications
      await notificationService.onRideAccepted(updatedRide, userId);

      // Log the action
      await storage.createRideAuditLog({
        rideId: offer.rideId,
        action: "ride_accepted",
        actorId: userId,
        actorRole: "driver",
        previousStatus: "matching",
        newStatus: "accepted",
      });

      return res.json({ success: true, ride: updatedRide });
    } catch (error) {
      console.error("Error accepting offer:", error);
      return res.status(500).json({ message: "Failed to accept offer" });
    }
  });

  // Decline a ride offer
  app.post("/api/ride-offers/:offerId/decline", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { offerId } = req.params;

      const offer = await storage.getPendingRideOfferForDriver(userId);
      if (!offer || offer.id !== offerId) {
        return res.status(400).json({ message: "Offer not found" });
      }

      await storage.updateRideOfferStatus(offerId, "declined");

      return res.json({ success: true });
    } catch (error) {
      console.error("Error declining offer:", error);
      return res.status(500).json({ message: "Failed to decline offer" });
    }
  });

  // ==========================================
  // Profile Photo Routes
  // ==========================================

  // Upload profile photo (driver or rider)
  app.post("/api/profile/photo", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { photoData } = req.body;

      if (photoData === undefined || photoData === null) {
        return res.status(400).json({ message: "Photo data is required" });
      }

      if (typeof photoData === "string" && photoData.length > 0) {
        const validPrefixes = ["data:image/jpeg", "data:image/png", "data:image/webp"];
        if (!validPrefixes.some(p => photoData.startsWith(p))) {
          return res.status(400).json({ message: "Invalid image format. Use JPG, PNG, or WebP." });
        }
        const base64Part = photoData.split(",")[1] || "";
        const sizeBytes = Math.ceil(base64Part.length * 0.75);
        if (sizeBytes > 5 * 1024 * 1024) {
          return res.status(400).json({ message: "Image must be under 5MB." });
        }
      }

      const role = await storage.getUserRole(userId);
      const photo = photoData === "" ? null : photoData;
      
      if (role?.role === "driver") {
        await storage.updateDriverProfilePhoto(userId, photo || "");
      } else if (role?.role === "rider") {
        await storage.updateRiderProfilePhoto(userId, photo || "");
      } else {
        return res.status(400).json({ message: "Profile photos are for riders and drivers only" });
      }

      return res.json({ success: true });
    } catch (error) {
      console.error("Error uploading profile photo:", error);
      return res.status(500).json({ message: "Failed to upload photo" });
    }
  });

  // Upload verification photo (live photo for identity verification)
  app.post("/api/profile/verification-photo", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { photoData, sessionId } = req.body;

      if (!photoData || !sessionId) {
        return res.status(400).json({ message: "Photo data and session ID are required" });
      }

      const role = await storage.getUserRole(userId);
      
      if (role?.role === "driver") {
        await storage.updateDriverVerificationPhoto(userId, photoData, sessionId);
      } else if (role?.role === "rider") {
        await storage.updateRiderVerificationPhoto(userId, photoData, sessionId);
      } else {
        return res.status(400).json({ message: "Verification photos are for riders and drivers only" });
      }

      return res.json({ success: true, status: "pending_review" });
    } catch (error) {
      console.error("Error uploading verification photo:", error);
      return res.status(500).json({ message: "Failed to upload verification photo" });
    }
  });

  // Admin: Get drivers needing verification
  app.get("/api/admin/drivers/pending-verification", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const drivers = await storage.getDriversNeedingVerification();
      return res.json(drivers);
    } catch (error) {
      console.error("Error getting pending verifications:", error);
      return res.status(500).json({ message: "Failed to get pending verifications" });
    }
  });

  // Admin: Approve or reject driver verification
  app.post("/api/admin/drivers/:driverId/verify", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { driverId } = req.params;
      const { status } = req.body;

      if (!["verified", "rejected"].includes(status)) {
        return res.status(400).json({ message: "Invalid verification status" });
      }

      await storage.updateDriverVerificationStatus(driverId, status);

      // Notify driver
      const message = status === "verified" 
        ? "Your identity has been verified. You can now start accepting rides."
        : "Your identity verification was not approved. Please submit a new photo.";

      await storage.createNotification({
        userId: driverId,
        role: "driver",
        title: status === "verified" ? "Verification Approved" : "Verification Rejected",
        message,
        type: status === "verified" ? "success" : "warning",
      });

      return res.json({ success: true });
    } catch (error) {
      console.error("Error updating verification:", error);
      return res.status(500).json({ message: "Failed to update verification" });
    }
  });

  // ================================================
  // Phase 24 - Reservations / Scheduled Trips Routes
  // ================================================

  // Create a new reservation (Rider action)
  app.post("/api/reservations", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      
      const role = await storage.getUserRole(userId);
      if (role?.role !== "rider") {
        return res.status(403).json({ message: "Only riders can create reservations" });
      }

      const { pickupLat, pickupLng, dropoffLat, dropoffLng, pickupAddress, dropoffAddress, scheduledPickupAt, passengerCount } = req.body;

      if (!scheduledPickupAt) {
        return res.status(400).json({ message: "Scheduled pickup time is required" });
      }

      const scheduledTime = new Date(scheduledPickupAt);
      const now = new Date();
      const minAdvanceTime = new Date(now.getTime() + 60 * 60 * 1000);
      
      if (scheduledTime < minAdvanceTime) {
        return res.status(400).json({ message: "Reservations must be at least 1 hour in advance" });
      }

      const estimatedDistanceKm = Math.random() * 15 + 3;
      const estimatedDurationMin = estimatedDistanceKm * 3 + Math.random() * 10;
      const baseFare = 2.50;
      const distanceFare = estimatedDistanceKm * 0.75;
      const reservationPremium = 5.00;
      const totalFare = baseFare + distanceFare + reservationPremium;

      const reservation = await storage.createReservation({
        riderId: userId,
        pickupLat: pickupLat.toString(),
        pickupLng: pickupLng.toString(),
        dropoffLat: dropoffLat.toString(),
        dropoffLng: dropoffLng.toString(),
        pickupAddress,
        dropoffAddress,
        scheduledPickupAt: scheduledTime,
        passengerCount: passengerCount || 1,
        estimatedDistanceKm: estimatedDistanceKm.toFixed(2),
        estimatedDurationMin: estimatedDurationMin.toFixed(0),
        baseFare: baseFare.toFixed(2),
        distanceFare: distanceFare.toFixed(2),
        reservationPremium: reservationPremium.toFixed(2),
        totalFare: totalFare.toFixed(2),
      });

      await notificationService.notifyRider(
        userId,
        "ride_accepted",
        "Reservation Confirmed",
        `Your ride is scheduled for ${scheduledTime.toLocaleString()}`,
        reservation.id
      );

      return res.json(reservation);
    } catch (error) {
      console.error("Error creating reservation:", error);
      return res.status(500).json({ message: "Failed to create reservation" });
    }
  });

  // Get rider's upcoming reservations
  app.get("/api/reservations/upcoming", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const reservations = await storage.getUpcomingReservations(userId);
      return res.json(reservations);
    } catch (error) {
      console.error("Error fetching reservations:", error);
      return res.status(500).json({ message: "Failed to fetch reservations" });
    }
  });

  // Get driver's upcoming assigned reservations
  app.get("/api/reservations/driver/upcoming", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const role = await storage.getUserRole(userId);
      if (role?.role !== "driver") {
        return res.status(403).json({ message: "Only drivers can view assigned reservations" });
      }
      const reservations = await storage.getDriverUpcomingReservations(userId);
      return res.json(reservations);
    } catch (error) {
      console.error("Error fetching driver reservations:", error);
      return res.status(500).json({ message: "Failed to fetch reservations" });
    }
  });

  // Get all upcoming reservations (Admin)
  app.get("/api/reservations/all", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const role = await storage.getUserRole(userId);
      if (!["admin", "super_admin"].includes(role?.role || "")) {
        return res.status(403).json({ message: "Admin access required" });
      }
      const reservations = await storage.getAllUpcomingReservations();
      return res.json(reservations);
    } catch (error) {
      console.error("Error fetching all reservations:", error);
      return res.status(500).json({ message: "Failed to fetch reservations" });
    }
  });

  // Assign driver to reservation (Admin)
  app.post("/api/reservations/:id/assign", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { id } = req.params;
      const { driverId } = req.body;

      const role = await storage.getUserRole(userId);
      if (!["admin", "super_admin"].includes(role?.role || "")) {
        return res.status(403).json({ message: "Admin access required" });
      }

      const reservation = await storage.assignDriverToReservation(id, driverId);
      if (!reservation) {
        return res.status(404).json({ message: "Reservation not found or already assigned" });
      }

      await notificationService.notifyDriver(
        driverId,
        "ride_accepted",
        "New Reserved Trip",
        `You've been assigned a scheduled pickup for ${new Date(reservation.scheduledPickupAt!).toLocaleString()}`,
        id
      );

      await notificationService.notifyRider(
        reservation.riderId,
        "ride_accepted",
        "Driver Assigned",
        "A driver has been assigned to your scheduled trip",
        id
      );

      return res.json(reservation);
    } catch (error) {
      console.error("Error assigning driver:", error);
      return res.status(500).json({ message: "Failed to assign driver" });
    }
  });

  // Cancel reservation (Rider action)
  app.post("/api/reservations/:id/cancel", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { id } = req.params;
      const { reason } = req.body;

      const reservation = await storage.getRideById(id);
      if (!reservation || reservation.riderId !== userId) {
        return res.status(404).json({ message: "Reservation not found" });
      }

      const cancelled = await storage.cancelReservation(id, "rider", reason);
      if (!cancelled) {
        return res.status(400).json({ message: "Failed to cancel reservation" });
      }

      if (cancelled.assignedDriverId) {
        await notificationService.notifyDriver(
          cancelled.assignedDriverId,
          "ride_cancelled",
          "Reservation Cancelled",
          "A scheduled trip has been cancelled by the rider",
          id
        );
      }

      return res.json(cancelled);
    } catch (error) {
      console.error("Error cancelling reservation:", error);
      return res.status(500).json({ message: "Failed to cancel reservation" });
    }
  });

  // Start reserved trip (Driver action - when entering prep window)
  app.post("/api/reservations/:id/start", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { id } = req.params;

      const role = await storage.getUserRole(userId);
      if (role?.role !== "driver") {
        return res.status(403).json({ message: "Only drivers can start reserved trips" });
      }

      const reservation = await storage.getRideById(id);
      if (!reservation || reservation.assignedDriverId !== userId) {
        return res.status(404).json({ message: "Reservation not found or not assigned to you" });
      }

      const updated = await storage.updateReservationStatus(id, "active");
      if (updated) {
        await storage.updateRideStatus(id, "driver_en_route", {
          enRouteAt: new Date(),
          driverEnRouteStartedAt: new Date(),
        });

        await notificationService.notifyRider(
          reservation.riderId,
          "driver_en_route",
          "Driver On The Way",
          "Your driver is heading to the pickup location",
          id
        );
      }

      return res.json(updated);
    } catch (error) {
      console.error("Error starting reservation:", error);
      return res.status(500).json({ message: "Failed to start reservation" });
    }
  });

  // Apply early arrival bonus
  app.post("/api/reservations/:id/early-bonus", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { id } = req.params;

      const role = await storage.getUserRole(userId);
      if (!["admin", "super_admin"].includes(role?.role || "")) {
        return res.status(403).json({ message: "Admin access required" });
      }

      const reservation = await storage.getRideById(id);
      if (!reservation || !reservation.isReserved) {
        return res.status(404).json({ message: "Reservation not found" });
      }

      if (!reservation.arrivedAt || !reservation.scheduledPickupAt) {
        return res.status(400).json({ message: "Cannot calculate bonus - missing arrival data" });
      }

      const arrivedTime = new Date(reservation.arrivedAt);
      const scheduledTime = new Date(reservation.scheduledPickupAt);
      const minutesEarly = (scheduledTime.getTime() - arrivedTime.getTime()) / (1000 * 60);

      if (minutesEarly <= 0) {
        return res.status(400).json({ message: "Driver did not arrive early" });
      }

      const bonusAmountNum = Math.min(minutesEarly * 0.50, 10.00);
      const bonusAmount = bonusAmountNum.toFixed(2);
      const updated = await storage.applyEarlyArrivalBonus(id, bonusAmount);

      if (updated && reservation.driverId) {
        const wallet = await storage.getWalletByUserId(reservation.driverId);
        if (wallet) {
          await storage.creditWallet(
            wallet.id,
            bonusAmount,
            "incentive",
            id,
            userId,
            `Early arrival bonus for reservation ${id}`
          );
        }

        await notificationService.notifyDriver(
          reservation.driverId,
          "ride_completed",
          "Early Arrival Bonus",
          `You earned ${(bonusAmountNum / 100).toFixed(2)} for arriving ${Math.round(minutesEarly)} minutes early`,
          id
        );
      }

      return res.json(updated);
    } catch (error) {
      console.error("Error applying early bonus:", error);
      return res.status(500).json({ message: "Failed to apply bonus" });
    }
  });

  // Get reservations in prep window (for notification service)
  app.get("/api/reservations/prep-window", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const role = await storage.getUserRole(userId);
      if (!["admin", "super_admin"].includes(role?.role || "")) {
        return res.status(403).json({ message: "Admin access required" });
      }
      const reservations = await storage.getReservationsInPrepWindow();
      return res.json(reservations);
    } catch (error) {
      console.error("Error fetching prep window reservations:", error);
      return res.status(500).json({ message: "Failed to fetch reservations" });
    }
  });

  // Get available reservation offers for drivers to accept
  app.get("/api/reservations/offers", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const role = await storage.getUserRole(userId);
      if (role?.role !== "driver") {
        return res.status(403).json({ message: "Only drivers can view reservation offers" });
      }
      
      const driverProfile = await storage.getDriverProfile(userId);
      if (!driverProfile || driverProfile.status !== "approved") {
        return res.status(403).json({ message: "Only approved drivers can view offers" });
      }
      
      const offers = await storage.getAvailableReservationOffers();
      return res.json(offers);
    } catch (error) {
      console.error("Error fetching reservation offers:", error);
      return res.status(500).json({ message: "Failed to fetch offers" });
    }
  });

  // Driver accepts a reservation offer
  app.post("/api/reservations/:id/accept", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { id } = req.params;

      const role = await storage.getUserRole(userId);
      if (role?.role !== "driver") {
        return res.status(403).json({ message: "Only drivers can accept reservations" });
      }

      const driverProfile = await storage.getDriverProfile(userId);
      if (!driverProfile || driverProfile.status !== "approved") {
        return res.status(403).json({ message: "Only approved drivers can accept reservations" });
      }

      const reservation = await storage.getRideById(id);
      if (!reservation) {
        return res.status(404).json({ message: "Reservation not found" });
      }
      if (!reservation.isReserved || reservation.reservationStatus !== "scheduled") {
        return res.status(400).json({ message: "Reservation is not available for acceptance" });
      }
      if (reservation.assignedDriverId) {
        return res.status(400).json({ message: "This reservation has already been accepted by another driver" });
      }

      const updated = await storage.acceptReservationOffer(id, userId);
      if (!updated) {
        return res.status(400).json({ message: "Could not accept reservation - it may have been taken" });
      }

      await storage.createRideAuditLog({
        rideId: id,
        action: "reservation_accepted",
        actorId: userId,
        actorRole: "driver",
        previousStatus: "requested",
        newStatus: "requested",
        metadata: JSON.stringify({ driverId: userId }),
      });

      await notificationService.notifyRider(
        reservation.riderId,
        "ride_accepted",
        "Driver Assigned",
        `A driver has accepted your reservation for ${new Date(reservation.scheduledPickupAt!).toLocaleString()}`,
        id
      );

      await notificationService.notifyDriver(
        userId,
        "ride_accepted",
        "Reservation Confirmed",
        `You've accepted a reservation for ${new Date(reservation.scheduledPickupAt!).toLocaleString()}`,
        id
      );

      return res.json(updated);
    } catch (error) {
      console.error("Error accepting reservation:", error);
      return res.status(500).json({ message: "Failed to accept reservation" });
    }
  });

  // ==========================================
  // PHASE 25 - MONETIZATION, FRAUD & PRICING
  // ==========================================

  // Country Pricing Rules
  app.get("/api/country-pricing-rules", isAuthenticated, requireRole(["super_admin", "admin", "finance"]), async (req, res) => {
    try {
      const rules = await storage.getAllCountryPricingRules();
      return res.json(rules);
    } catch (error) {
      console.error("Error fetching country pricing rules:", error);
      return res.status(500).json({ message: "Failed to fetch pricing rules" });
    }
  });

  app.get("/api/country-pricing-rules/:countryId", isAuthenticated, requireRole(["super_admin", "admin", "finance"]), async (req, res) => {
    try {
      const countryId = req.params.countryId as string;
      const rules = await storage.getCountryPricingRules(countryId);
      if (!rules) {
        return res.status(404).json({ message: "Pricing rules not found" });
      }
      return res.json(rules);
    } catch (error) {
      console.error("Error fetching country pricing rules:", error);
      return res.status(500).json({ message: "Failed to fetch pricing rules" });
    }
  });

  app.post("/api/country-pricing-rules", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const rules = await storage.createCountryPricingRules(req.body);
      return res.status(201).json(rules);
    } catch (error) {
      console.error("Error creating country pricing rules:", error);
      return res.status(500).json({ message: "Failed to create pricing rules" });
    }
  });

  app.patch("/api/country-pricing-rules/:countryId", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const countryId = req.params.countryId as string;
      const rules = await storage.updateCountryPricingRules(countryId, req.body);
      if (!rules) {
        return res.status(404).json({ message: "Pricing rules not found" });
      }
      return res.json(rules);
    } catch (error) {
      console.error("Error updating country pricing rules:", error);
      return res.status(500).json({ message: "Failed to update pricing rules" });
    }
  });

  // Rider Wallets
  app.get("/api/rider-wallets", isAuthenticated, requireRole(["super_admin", "admin", "finance"]), async (req, res) => {
    try {
      const wallets = await storage.getAllRiderWallets();
      return res.json(wallets);
    } catch (error) {
      console.error("Error fetching rider wallets:", error);
      return res.status(500).json({ message: "Failed to fetch wallets" });
    }
  });

  app.get("/api/rider-wallets/:userId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const targetUserId = req.params.userId;
      
      // Allow users to see their own wallet, or admins to see any wallet
      const userRole = await storage.getUserRole(userId);
      if (userId !== targetUserId && !["super_admin", "admin", "finance"].includes(userRole?.role || "")) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      let wallet = await storage.getRiderWallet(targetUserId);
      if (!wallet) {
        const currency = await getUserCurrency(targetUserId);
        wallet = await storage.createRiderWallet({ userId: targetUserId, currency });
      }
      return res.json(wallet);
    } catch (error) {
      console.error("Error fetching rider wallet:", error);
      return res.status(500).json({ message: "Failed to fetch wallet" });
    }
  });

  // Driver Wallets (V2 - Phase 25)
  app.get("/api/driver-wallets-v2", isAuthenticated, requireRole(["super_admin", "admin", "finance"]), async (req, res) => {
    try {
      const wallets = await storage.getAllDriverWalletsV2();
      return res.json(wallets);
    } catch (error) {
      console.error("Error fetching driver wallets:", error);
      return res.status(500).json({ message: "Failed to fetch wallets" });
    }
  });

  app.get("/api/driver-wallets-v2/:userId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const targetUserId = req.params.userId;
      
      const userRole = await storage.getUserRole(userId);
      if (userId !== targetUserId && !["super_admin", "admin", "finance"].includes(userRole?.role || "")) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      let wallet = await storage.getDriverWallet(targetUserId);
      if (!wallet) {
        const currency = await getUserCurrency(targetUserId);
        wallet = await storage.createDriverWallet({ userId: targetUserId, currency });
      }
      return res.json(wallet);
    } catch (error) {
      console.error("Error fetching driver wallet:", error);
      return res.status(500).json({ message: "Failed to fetch wallet" });
    }
  });

  // Driver Payouts
  app.post("/api/driver-payouts", isAuthenticated, requireRole(["super_admin", "admin", "finance"]), async (req: any, res) => {
    try {
      const { driverId, amount } = req.body;
      const userId = req.user?.claims?.sub;
      
      if (!driverId || !amount || amount <= 0) {
        return res.status(400).json({ message: "Driver ID and positive amount required" });
      }
      
      const payout = await storage.initiateDriverPayoutV2(driverId, amount, userId);
      if (!payout) {
        return res.status(400).json({ message: "Insufficient withdrawable balance" });
      }
      
      return res.status(201).json(payout);
    } catch (error) {
      console.error("Error initiating payout:", error);
      return res.status(500).json({ message: "Failed to initiate payout" });
    }
  });

  app.get("/api/driver-payouts/pending", isAuthenticated, requireRole(["super_admin", "admin", "finance"]), async (req, res) => {
    try {
      const payouts = await storage.getPendingPayoutsV2();
      return res.json(payouts);
    } catch (error) {
      console.error("Error fetching pending payouts:", error);
      return res.status(500).json({ message: "Failed to fetch payouts" });
    }
  });

  app.patch("/api/driver-payouts/:id/complete", isAuthenticated, requireRole(["super_admin", "admin", "finance"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { transactionRef } = req.body;
      
      const payout = await storage.completeDriverPayout(req.params.id, userId, transactionRef);
      if (!payout) {
        return res.status(404).json({ message: "Payout not found" });
      }
      
      return res.json(payout);
    } catch (error) {
      console.error("Error completing payout:", error);
      return res.status(500).json({ message: "Failed to complete payout" });
    }
  });

  app.patch("/api/driver-payouts/:id/fail", isAuthenticated, requireRole(["super_admin", "admin", "finance"]), async (req, res) => {
    try {
      const payoutId = req.params.id as string;
      const { reason } = req.body;
      
      const payout = await storage.failDriverPayout(payoutId, reason || "Unknown error");
      if (!payout) {
        return res.status(404).json({ message: "Payout not found" });
      }
      
      return res.json(payout);
    } catch (error) {
      console.error("Error failing payout:", error);
      return res.status(500).json({ message: "Failed to update payout" });
    }
  });

  // Admin Wallet Management - Freeze/Unfreeze/Adjust (ADMIN ONLY)
  app.post("/api/admin/wallet/freeze/rider/:userId", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const targetUserId = req.params.userId as string;
      const { reason } = req.body;
      
      if (!reason) {
        return res.status(400).json({ message: "Freeze reason is required" });
      }
      
      const wallet = await storage.freezeRiderWallet(targetUserId, reason, adminId);
      if (!wallet) {
        return res.status(404).json({ message: "Rider wallet not found" });
      }
      
      console.log(`[SECURITY AUDIT] Rider wallet frozen: targetUserId=${targetUserId}, by=${adminId}, reason=${reason}`);
      
      await storage.createAuditLog({
        action: "wallet_frozen",
        entityType: "rider_wallet",
        entityId: targetUserId,
        performedByUserId: adminId,
        performedByRole: "admin",
        metadata: JSON.stringify({ reason, frozenAt: new Date().toISOString() }),
      });
      
      return res.json({ message: "Rider wallet frozen", wallet });
    } catch (error) {
      console.error("Error freezing rider wallet:", error);
      return res.status(500).json({ message: "Failed to freeze wallet" });
    }
  });

  app.post("/api/admin/wallet/unfreeze/rider/:userId", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const targetUserId = req.params.userId as string;
      
      const wallet = await storage.unfreezeRiderWallet(targetUserId);
      if (!wallet) {
        return res.status(404).json({ message: "Rider wallet not found" });
      }
      
      console.log(`[SECURITY AUDIT] Rider wallet unfrozen: targetUserId=${targetUserId}, by=${adminId}`);
      
      await storage.createAuditLog({
        action: "wallet_unfrozen",
        entityType: "rider_wallet",
        entityId: targetUserId,
        performedByUserId: adminId,
        performedByRole: "admin",
        metadata: JSON.stringify({ unfrozenAt: new Date().toISOString() }),
      });
      
      return res.json({ message: "Rider wallet unfrozen", wallet });
    } catch (error) {
      console.error("Error unfreezing rider wallet:", error);
      return res.status(500).json({ message: "Failed to unfreeze wallet" });
    }
  });

  app.post("/api/admin/wallet/freeze/driver/:userId", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const targetUserId = req.params.userId as string;
      const { reason } = req.body;
      
      if (!reason) {
        return res.status(400).json({ message: "Freeze reason is required" });
      }
      
      const wallet = await storage.freezeDriverWallet(targetUserId, reason, adminId);
      if (!wallet) {
        return res.status(404).json({ message: "Driver wallet not found" });
      }
      
      console.log(`[SECURITY AUDIT] Driver wallet frozen: targetUserId=${targetUserId}, by=${adminId}, reason=${reason}`);
      
      await storage.createAuditLog({
        action: "wallet_frozen",
        entityType: "driver_wallet",
        entityId: targetUserId,
        performedByUserId: adminId,
        performedByRole: "admin",
        metadata: JSON.stringify({ reason, frozenAt: new Date().toISOString() }),
      });
      
      return res.json({ message: "Driver wallet frozen", wallet });
    } catch (error) {
      console.error("Error freezing driver wallet:", error);
      return res.status(500).json({ message: "Failed to freeze wallet" });
    }
  });

  app.post("/api/admin/wallet/unfreeze/driver/:userId", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const targetUserId = req.params.userId as string;
      
      const wallet = await storage.unfreezeDriverWallet(targetUserId);
      if (!wallet) {
        return res.status(404).json({ message: "Driver wallet not found" });
      }
      
      console.log(`[SECURITY AUDIT] Driver wallet unfrozen: targetUserId=${targetUserId}, by=${adminId}`);
      
      await storage.createAuditLog({
        action: "wallet_unfrozen",
        entityType: "driver_wallet",
        entityId: targetUserId,
        performedByUserId: adminId,
        performedByRole: "admin",
        metadata: JSON.stringify({ unfrozenAt: new Date().toISOString() }),
      });
      
      return res.json({ message: "Driver wallet unfrozen", wallet });
    } catch (error) {
      console.error("Error unfreezing driver wallet:", error);
      return res.status(500).json({ message: "Failed to unfreeze wallet" });
    }
  });

  app.post("/api/admin/wallet/adjust/rider/:userId", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const targetUserId = req.params.userId as string;
      const { amount, reason } = req.body;
      
      if (amount === undefined || !reason) {
        return res.status(400).json({ message: "Amount and reason are required" });
      }
      
      const wallet = await storage.adjustRiderWalletBalance(targetUserId, parseFloat(amount), reason, adminId);
      if (!wallet) {
        return res.status(404).json({ message: "Rider wallet not found" });
      }
      
      console.log(`[SECURITY AUDIT] Rider wallet adjusted: targetUserId=${targetUserId}, amount=${amount}, by=${adminId}, reason=${reason}`);
      
      return res.json({ message: "Rider wallet adjusted", wallet });
    } catch (error) {
      console.error("Error adjusting rider wallet:", error);
      return res.status(500).json({ message: "Failed to adjust wallet" });
    }
  });

  app.post("/api/admin/wallet/adjust/driver/:userId", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const targetUserId = req.params.userId as string;
      const { amount, reason } = req.body;
      
      if (amount === undefined || !reason) {
        return res.status(400).json({ message: "Amount and reason are required" });
      }
      
      const wallet = await storage.adjustDriverWalletBalance(targetUserId, parseFloat(amount), reason, adminId);
      if (!wallet) {
        return res.status(404).json({ message: "Driver wallet not found" });
      }
      
      console.log(`[SECURITY AUDIT] Driver wallet adjusted: targetUserId=${targetUserId}, amount=${amount}, by=${adminId}, reason=${reason}`);
      
      return res.json({ message: "Driver wallet adjusted", wallet });
    } catch (error) {
      console.error("Error adjusting driver wallet:", error);
      return res.status(500).json({ message: "Failed to adjust wallet" });
    }
  });

  app.post("/api/admin/wallet/reverse-transaction", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { userId, walletType, originalAmount, reason } = req.body;
      
      if (!userId || !walletType || originalAmount === undefined || !reason) {
        return res.status(400).json({ message: "userId, walletType, originalAmount, and reason are required" });
      }
      
      const reverseAmount = -parseFloat(originalAmount);
      let wallet;
      
      if (walletType === "rider") {
        wallet = await storage.adjustRiderWalletBalance(userId, reverseAmount, `REVERSAL: ${reason}`, adminId);
      } else if (walletType === "driver") {
        wallet = await storage.adjustDriverWalletBalance(userId, reverseAmount, `REVERSAL: ${reason}`, adminId);
      } else {
        return res.status(400).json({ message: "Invalid walletType. Must be 'rider' or 'driver'" });
      }
      
      if (!wallet) {
        return res.status(404).json({ message: "Wallet not found" });
      }
      
      console.log(`[SECURITY AUDIT] Transaction reversed: userId=${userId}, walletType=${walletType}, amount=${reverseAmount}, by=${adminId}, reason=${reason}`);
      
      return res.json({ message: "Transaction reversed", wallet });
    } catch (error) {
      console.error("Error reversing transaction:", error);
      return res.status(500).json({ message: "Failed to reverse transaction" });
    }
  });

  // ==========================================
  // TEST WALLET CREDIT (SUPER_ADMIN ONLY)
  // ==========================================
  // This allows SUPER_ADMIN to credit wallets for testing
  // without real money movement (no Paystack calls)
  app.post("/api/admin/wallet/test-credit", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const adminEmail = req.user.claims.email;
      const { userId, amount, walletType = "rider" } = req.body;
      
      if (!userId || !amount) {
        return res.status(400).json({ message: "userId and amount are required" });
      }
      
      const creditAmount = parseFloat(amount);
      if (isNaN(creditAmount) || creditAmount <= 0) {
        return res.status(400).json({ message: "Amount must be a positive number" });
      }
      
      // Credit the appropriate wallet
      let wallet;
      if (walletType === "driver") {
        wallet = await storage.adjustDriverWalletBalance(userId, creditAmount, "TEST_CREDIT", adminId);
      } else {
        wallet = await storage.adjustRiderWalletBalance(userId, creditAmount, "TEST_CREDIT", adminId);
      }
      
      if (!wallet) {
        return res.status(404).json({ message: `${walletType} wallet not found for user` });
      }
      
      // Log for audit trail
      console.log(`[TEST_CREDIT AUDIT] adminId=${adminId}, adminEmail=${adminEmail}, userId=${userId}, walletType=${walletType}, amount=${creditAmount}, reason=TESTING, timestamp=${new Date().toISOString()}`);
      
      // Also log to financial audit
      await storage.createFinancialAuditLog({
        eventType: "ADJUSTMENT",
        userId,
        amount: String(creditAmount),
        actorRole: "ADMIN",
        currency: "NGN",
        description: `TEST_CREDIT by SUPER_ADMIN (${adminEmail})`,
        metadata: JSON.stringify({ adminId, adminEmail, reason: "TESTING", walletType }),
      });
      
      return res.json({ 
        message: `Test credit of ${creditAmount} applied to ${walletType} wallet`,
        wallet,
        creditAmount,
        walletType,
      });
    } catch (error) {
      console.error("Error applying test credit:", error);
      return res.status(500).json({ message: "Failed to apply test credit" });
    }
  });

  // ==========================================
  // WALLET TOP-UP (SUPER_ADMIN ONLY)
  // ==========================================
  // POST /api/admin/wallet/topup - Top up any user's wallet
  app.post("/api/admin/wallet/topup", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const adminEmail = req.user.claims.email;
      const { userId, amount, walletType, note } = req.body;
      
      if (!userId || !amount || !walletType) {
        return res.status(400).json({ message: "userId, amount, and walletType (TEST or MAIN) are required" });
      }
      
      if (!["TEST", "MAIN"].includes(walletType)) {
        return res.status(400).json({ message: "walletType must be TEST or MAIN" });
      }
      
      const topupAmount = parseFloat(amount);
      if (isNaN(topupAmount) || topupAmount <= 0) {
        return res.status(400).json({ message: "Amount must be a positive number" });
      }
      
      // Get user's country and currency
      const userRole = await storage.getUserRole(userId);
      const countryCode = userRole?.countryCode || "NG";
      const currencyMap: Record<string, string> = { NG: "NGN", US: "USD", ZA: "ZAR" };
      const currency = currencyMap[countryCode] || "NGN";
      
      // Find which wallet type the user has (rider or driver)
      let riderWallet = await storage.getRiderWallet(userId);
      let driverWallet = await storage.getDriverWallet(userId);
      
      let walletUpdated = false;
      let walletData: any = null;
      
      if (walletType === "TEST") {
        // Credit tester wallet balance
        if (riderWallet) {
          walletData = await storage.adjustRiderTesterWalletBalance(userId, topupAmount, "ADMIN_TOPUP", adminId);
          walletUpdated = true;
        } else if (driverWallet) {
          walletData = await storage.adjustDriverTesterWalletBalance(userId, topupAmount, "ADMIN_TOPUP", adminId);
          walletUpdated = true;
        }
      } else {
        // Credit main wallet balance
        if (riderWallet) {
          walletData = await storage.adjustRiderWalletBalance(userId, topupAmount, "ADMIN_TOPUP", adminId);
          walletUpdated = true;
        } else if (driverWallet) {
          walletData = await storage.adjustDriverWalletBalance(userId, topupAmount, "ADMIN_TOPUP", adminId);
          walletUpdated = true;
        }
      }
      
      if (!walletUpdated) {
        return res.status(404).json({ message: "No wallet found for this user. Create a wallet first." });
      }
      
      // Log to wallet_topup_logs
      await storage.createWalletTopupLog({
        userId,
        adminId,
        walletType,
        amount: String(topupAmount),
        currency,
        note: note || null,
      });
      
      // Log for audit trail
      console.log(`[WALLET_TOPUP AUDIT] adminId=${adminId}, adminEmail=${adminEmail}, userId=${userId}, walletType=${walletType}, amount=${topupAmount}, currency=${currency}, note=${note || "none"}, timestamp=${new Date().toISOString()}`);
      
      // Also log to financial audit
      await storage.createFinancialAuditLog({
        eventType: "ADJUSTMENT",
        userId,
        amount: String(topupAmount),
        actorRole: "ADMIN",
        currency,
        description: `ADMIN_TOPUP (${walletType}) by SUPER_ADMIN (${adminEmail})${note ? `: ${note}` : ""}`,
        metadata: JSON.stringify({ adminId, adminEmail, walletType, note }),
      });
      
      return res.json({ 
        message: `Successfully topped up ${walletType} wallet with ${currency} ${topupAmount}`,
        wallet: walletData,
        topupAmount,
        walletType,
        currency,
      });
    } catch (error) {
      console.error("Error topping up wallet:", error);
      return res.status(500).json({ message: "Failed to top up wallet" });
    }
  });

  // GET /api/admin/wallet/topup-logs - Get all top-up logs
  app.get("/api/admin/wallet/topup-logs", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const logs = await storage.getWalletTopupLogs();
      return res.json(logs);
    } catch (error) {
      console.error("Error fetching top-up logs:", error);
      return res.status(500).json({ message: "Failed to fetch top-up logs" });
    }
  });

  // ==========================================
  // TESTER MANAGEMENT - SUPER ADMIN ONLY
  // ==========================================

  // Create Rider Tester
  app.post("/api/admin/testers/rider", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const adminEmail = req.user.claims.email;
      const { userId, email } = req.body;
      
      if (!userId) {
        return res.status(400).json({ message: "userId is required" });
      }
      
      // Update user role to rider with tester flag
      await storage.setUserAsTester(userId, "RIDER", adminId);
      
      // Create wallet with 45,000 credit (4500000 kobo)
      let wallet = await storage.getRiderWallet(userId);
      if (!wallet) {
        const currency = await getUserCurrency(userId);
        wallet = await storage.createRiderWallet({ userId, currency });
      }
      
      // Credit test credits to TESTER WALLET (separate from main wallet)
      const creditAmount = 4500000;
      await storage.adjustRiderTesterWalletBalance(userId, creditAmount, "INITIAL_TEST_CREDIT", adminId);
      
      console.log(`[TESTER CREATED] type=RIDER, userId=${userId}, adminId=${adminId}, adminEmail=${adminEmail}, testerCredit=45,000`);
      
      await storage.createFinancialAuditLog({
        eventType: "ADJUSTMENT",
        userId,
        amount: String(creditAmount),
        actorRole: "ADMIN",
        currency: "NGN",
        description: `INITIAL_TEST_CREDIT - Rider Tester created by ${adminEmail}`,
        metadata: JSON.stringify({ testerType: "RIDER", adminId, source: "TESTER_SYSTEM", walletType: "TESTER" }),
      });
      
      return res.json({ 
        success: true,
        message: "Rider tester created with 45,000 test credit",
        userId,
        testerType: "RIDER",
        testerWalletBalance: creditAmount,
      });
    } catch (error) {
      console.error("Error creating rider tester:", error);
      return res.status(500).json({ message: "Failed to create rider tester" });
    }
  });

  // Create Driver Tester
  app.post("/api/admin/testers/driver", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const adminEmail = req.user.claims.email;
      const { userId } = req.body;
      
      if (!userId) {
        return res.status(400).json({ message: "userId is required" });
      }
      
      // Update user role to driver with tester flag
      await storage.setUserAsTester(userId, "DRIVER", adminId);
      
      // Create driver wallet (main balance stays at 0)
      let wallet = await storage.getDriverWallet(userId);
      if (!wallet) {
        const currency = await getUserCurrency(userId);
        wallet = await storage.createDriverWallet({ userId, currency });
      }
      
      // Credit test credits to TESTER WALLET (separate from main wallet)
      const creditAmount = 4500000;
      await storage.adjustDriverTesterWalletBalance(userId, creditAmount, "INITIAL_TEST_CREDIT", adminId);
      
      console.log(`[TESTER CREATED] type=DRIVER, userId=${userId}, adminId=${adminId}, adminEmail=${adminEmail}, testerCredit=45,000`);
      
      await storage.createFinancialAuditLog({
        eventType: "ADJUSTMENT",
        userId,
        amount: String(creditAmount),
        actorRole: "ADMIN",
        currency: "NGN",
        description: `INITIAL_TEST_CREDIT - Driver Tester created by ${adminEmail}`,
        metadata: JSON.stringify({ testerType: "DRIVER", adminId, source: "TESTER_SYSTEM", walletType: "TESTER" }),
      });
      
      return res.json({ 
        success: true,
        message: "Driver tester created with 45,000 test credit",
        userId,
        testerType: "DRIVER",
        testerWalletBalance: creditAmount,
      });
    } catch (error) {
      console.error("Error creating driver tester:", error);
      return res.status(500).json({ message: "Failed to create driver tester" });
    }
  });

  // Get all testers with wallet balances
  app.get("/api/admin/testers", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const testers = await storage.getAllTesters();
      
      // Enrich with wallet info
      const testersWithWallets = await Promise.all(testers.map(async (tester: any) => {
        let testerWalletBalance = 0;
        let mainWalletBalance = 0;
        
        if (tester.testerType === "RIDER") {
          const wallet = await storage.getRiderWallet(tester.userId);
          if (wallet) {
            testerWalletBalance = parseFloat(String(wallet.testerWalletBalance || 0));
            mainWalletBalance = parseFloat(String(wallet.balance || 0));
          }
        } else if (tester.testerType === "DRIVER") {
          const wallet = await storage.getDriverWallet(tester.userId);
          if (wallet) {
            testerWalletBalance = parseFloat(String(wallet.testerWalletBalance || 0));
            mainWalletBalance = parseFloat(String(wallet.balance || 0));
          }
        }
        
        return {
          ...tester,
          testerWalletBalance,
          mainWalletBalance,
        };
      }));
      
      return res.json(testersWithWallets);
    } catch (error) {
      console.error("Error fetching testers:", error);
      return res.status(500).json({ message: "Failed to fetch testers" });
    }
  });

  // Remove tester status
  app.delete("/api/admin/testers/:userId", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { userId } = req.params;
      
      await storage.removeTesterStatus(userId);
      
      console.log(`[TESTER REMOVED] userId=${userId}, removedBy=${adminId}`);
      
      return res.json({ success: true, message: "Tester status removed" });
    } catch (error) {
      console.error("Error removing tester:", error);
      return res.status(500).json({ message: "Failed to remove tester" });
    }
  });

  // Adjust tester credit (TOP_UP or REFUND) - SUPER_ADMIN only
  app.post("/api/admin/testers/adjust-credit", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const adminEmail = req.user.claims.email;
      const { userId, amount, action } = req.body;

      if (!userId || !amount || !action) {
        return res.status(400).json({ message: "userId, amount, and action are required" });
      }

      if (!["TOP_UP", "REFUND"].includes(action)) {
        return res.status(400).json({ message: "Action must be TOP_UP or REFUND" });
      }

      if (typeof amount !== "number" || amount <= 0) {
        return res.status(400).json({ message: "Amount must be a positive number" });
      }

      // Check if user is a tester
      const testerStatus = await storage.getUserTesterStatus(userId);
      if (!testerStatus?.isTester) {
        return res.status(400).json({ message: "User is not a tester. Can only adjust tester wallets." });
      }

      // Get the appropriate wallet and adjust TESTER WALLET BALANCE (separate from main wallet)
      if (testerStatus.testerType === "RIDER") {
        const wallet = await storage.getRiderWallet(userId);
        if (!wallet) {
          return res.status(404).json({ message: "Rider wallet not found" });
        }

        if (action === "REFUND") {
          // Check TESTER wallet balance first (already in kobo)
          const currentTesterBalance = typeof wallet.testerWalletBalance === 'string' 
            ? parseFloat(wallet.testerWalletBalance)
            : Number(wallet.testerWalletBalance || 0);
          if (currentTesterBalance < amount) {
            return res.status(400).json({ message: "Insufficient tester wallet balance for refund. Cannot go below 0." });
          }
          // Refund from TESTER WALLET
          await storage.adjustRiderTesterWalletBalance(userId, -amount, `TESTER_REFUND by ${adminEmail}`, adminId);
        } else {
          // TOP_UP - add to TESTER WALLET
          await storage.adjustRiderTesterWalletBalance(userId, amount, `TESTER_TOPUP by ${adminEmail}`, adminId);
        }
      } else if (testerStatus.testerType === "DRIVER") {
        const wallet = await storage.getDriverWallet(userId);
        if (!wallet) {
          return res.status(404).json({ message: "Driver wallet not found" });
        }

        if (action === "REFUND") {
          // Check TESTER wallet balance first (already in kobo)
          const currentTesterBalance = typeof wallet.testerWalletBalance === 'string' 
            ? parseFloat(wallet.testerWalletBalance)
            : Number(wallet.testerWalletBalance || 0);
          if (currentTesterBalance < amount) {
            return res.status(400).json({ message: "Insufficient tester wallet balance for refund. Cannot go below 0." });
          }
          // Refund from TESTER WALLET
          await storage.adjustDriverTesterWalletBalance(userId, -amount, `TESTER_REFUND by ${adminEmail}`, adminId);
        } else {
          // TOP_UP - add to TESTER WALLET
          await storage.adjustDriverTesterWalletBalance(userId, amount, `TESTER_TOPUP by ${adminEmail}`, adminId);
        }
      } else {
        return res.status(400).json({ message: "Unknown tester type" });
      }

      const nairaAmount = (amount / 100).toFixed(2);
      console.log(`[TESTER ${action}] userId=${userId}, amount=${nairaAmount}, by=${adminEmail}`);

      return res.json({
        success: true,
        message: `${action === "TOP_UP" ? "Topped up" : "Refunded"} ${nairaAmount} ${action === "TOP_UP" ? "to" : "from"} tester wallet`,
      });
    } catch (error) {
      console.error("Error adjusting tester credit:", error);
      return res.status(500).json({ message: "Failed to adjust tester credit" });
    }
  });

  // Check if user is a tester
  app.get("/api/user/tester-status", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const testerStatus = await storage.getUserTesterStatus(userId);
      return res.json(testerStatus);
    } catch (error) {
      console.error("Error getting tester status:", error);
      return res.status(500).json({ message: "Failed to get tester status" });
    }
  });

  // Get list of users for admin wallet management
  app.get("/api/admin/users/for-wallet-credit", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const users = await storage.getAllUsersWithRoles();
      const usersWithWallets = await Promise.all(
        users.map(async (user: any) => {
          const riderWallet = await storage.getRiderWallet(user.userId);
          const driverWallet = await storage.getDriverWallet(user.userId);
          return {
            id: user.userId,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
            role: user.role,
            riderBalance: riderWallet?.balance || 0,
            driverBalance: driverWallet?.balance || 0,
          };
        })
      );
      return res.json(usersWithWallets);
    } catch (error) {
      console.error("Error fetching users for wallet credit:", error);
      return res.status(500).json({ message: "Failed to fetch users" });
    }
  });

  // ZIBA Platform Wallet
  app.get("/api/ziba-wallet", isAuthenticated, requireRole(["super_admin", "admin", "finance", "director"]), async (req, res) => {
    try {
      const wallet = await storage.getZibaPlatformWallet();
      return res.json(wallet);
    } catch (error) {
      console.error("Error fetching ZIBA wallet:", error);
      return res.status(500).json({ message: "Failed to fetch platform wallet" });
    }
  });

  // Financial Audit Logs
  app.get("/api/financial-audit-logs", isAuthenticated, requireRole(["super_admin", "admin", "finance"]), async (req, res) => {
    try {
      const { rideId, userId, eventType, limit } = req.query;
      const logs = await storage.getFinancialAuditLogs(
        { 
          rideId: rideId as string, 
          userId: userId as string, 
          eventType: eventType as string 
        },
        limit ? parseInt(limit as string) : 100
      );
      return res.json(logs);
    } catch (error) {
      console.error("Error fetching financial audit logs:", error);
      return res.status(500).json({ message: "Failed to fetch logs" });
    }
  });

  // Abuse Flags
  app.get("/api/abuse-flags", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const { status } = req.query;
      const flags = await storage.getAbuseFlags(status as any);
      return res.json(flags);
    } catch (error) {
      console.error("Error fetching abuse flags:", error);
      return res.status(500).json({ message: "Failed to fetch flags" });
    }
  });

  app.patch("/api/abuse-flags/:id/resolve", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { status, reviewNotes, penaltyApplied } = req.body;
      
      if (!["resolved", "dismissed"].includes(status)) {
        return res.status(400).json({ message: "Status must be 'resolved' or 'dismissed'" });
      }
      
      const flag = await storage.resolveAbuseFlag(
        req.params.id,
        userId,
        status,
        reviewNotes,
        penaltyApplied
      );
      
      if (!flag) {
        return res.status(404).json({ message: "Flag not found" });
      }
      
      return res.json(flag);
    } catch (error) {
      console.error("Error resolving abuse flag:", error);
      return res.status(500).json({ message: "Failed to resolve flag" });
    }
  });

  // Escrows
  app.get("/api/escrows", isAuthenticated, requireRole(["super_admin", "admin", "finance"]), async (req, res) => {
    try {
      const { status } = req.query;
      const escrows = await storage.getEscrowsByStatus(status as any || "locked");
      return res.json(escrows);
    } catch (error) {
      console.error("Error fetching escrows:", error);
      return res.status(500).json({ message: "Failed to fetch escrows" });
    }
  });

  app.get("/api/escrows/ride/:rideId", isAuthenticated, requireRole(["super_admin", "admin", "finance"]), async (req, res) => {
    try {
      const rideId = req.params.rideId as string;
      const escrow = await storage.getEscrowByRideId(rideId);
      if (!escrow) {
        return res.status(404).json({ message: "Escrow not found" });
      }
      return res.json(escrow);
    } catch (error) {
      console.error("Error fetching escrow:", error);
      return res.status(500).json({ message: "Failed to fetch escrow" });
    }
  });

  // ==========================================
  // RIDER AUTO TOP-UP
  // ==========================================

  app.get("/api/rider/auto-topup", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const settings = await storage.getAutoTopUpSettings(userId);
      if (!settings) {
        return res.json({
          enabled: false,
          threshold: "500.00",
          amount: "1000.00",
          paymentMethodId: null,
          failureCount: 0,
        });
      }
      return res.json({
        enabled: settings.autoTopUpEnabled,
        threshold: settings.autoTopUpThreshold,
        amount: settings.autoTopUpAmount,
        paymentMethodId: settings.autoTopUpPaymentMethodId,
        failureCount: settings.autoTopUpFailureCount,
      });
    } catch (error) {
      console.error("Error fetching auto top-up settings:", error);
      return res.status(500).json({ message: "Failed to fetch auto top-up settings" });
    }
  });

  app.post("/api/rider/auto-topup", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { enabled, threshold, amount, paymentMethodId } = req.body;

      if (typeof enabled !== "boolean") {
        return res.status(400).json({ message: "enabled must be a boolean" });
      }

      if (threshold !== undefined && threshold < 100) {
        return res.status(400).json({ message: "Threshold must be at least 100" });
      }

      if (amount !== undefined && amount < 200) {
        return res.status(400).json({ message: "Amount must be at least 200" });
      }

      if (paymentMethodId) {
        const method = await storage.getRiderPaymentMethod(paymentMethodId);
        if (!method || method.userId !== userId) {
          return res.status(400).json({ message: "Invalid payment method" });
        }
        if (!method.isActive) {
          return res.status(400).json({ message: "Payment method is not active" });
        }
      }

      let existingWallet = await storage.getRiderWallet(userId);
      if (!existingWallet) {
        let currency = "NGN";
        try {
          currency = await getUserCurrency(userId);
        } catch (e) {
          console.warn(`[AUTO_TOPUP] Failed to get currency for user ${userId}, defaulting to NGN`);
        }
        try {
          existingWallet = await storage.createRiderWallet({ userId, currency });
        } catch (e: any) {
          if (e?.code === "23505" || e?.message?.includes("duplicate")) {
            existingWallet = await storage.getRiderWallet(userId);
          } else {
            throw e;
          }
        }
      }

      const wallet = await storage.updateAutoTopUpSettings(userId, {
        enabled,
        threshold: threshold !== undefined ? threshold.toString() : undefined,
        amount: amount !== undefined ? amount.toString() : undefined,
        paymentMethodId: paymentMethodId !== undefined ? paymentMethodId : undefined,
      });

      if (!wallet) {
        return res.status(500).json({ message: "Failed to update auto top-up settings" });
      }

      return res.json({
        success: true,
        message: enabled ? "Auto top-up enabled" : "Auto top-up disabled",
        settings: {
          autoTopUpEnabled: wallet.autoTopUpEnabled,
          autoTopUpThreshold: wallet.autoTopUpThreshold,
          autoTopUpAmount: wallet.autoTopUpAmount,
          autoTopUpPaymentMethodId: wallet.autoTopUpPaymentMethodId,
        },
      });
    } catch (error) {
      console.error("Error updating auto top-up settings:", error);
      return res.status(500).json({ message: "Failed to update auto top-up settings" });
    }
  });

  app.post("/api/rider/auto-topup/trigger", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const shouldTopUp = await storage.shouldTriggerAutoTopUp(userId);
      if (shouldTopUp) {
        storage.triggerAutoTopUp(userId).catch(err => console.error("[AUTO_TOPUP] Error:", err));
        return res.json({ triggered: true, message: "Auto top-up triggered" });
      }
      return res.json({ triggered: false, message: "Auto top-up not needed" });
    } catch (error) {
      console.error("Error triggering auto top-up:", error);
      return res.status(500).json({ message: "Failed to trigger auto top-up" });
    }
  });

  // ==========================================
  // WALLET FUNDING (Paystack for Nigeria)
  // ==========================================
  
  // Initialize wallet funding (Paystack for NG, simulated for others)
  app.post("/api/wallet/fund", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const userEmail = req.user?.claims?.email;
      const { amount, countryCode = "NG" } = req.body;
      
      if (!amount || amount < 100) {
        return res.status(400).json({ message: "Minimum funding amount is 100 NGN" });
      }
      
      const { processPayment } = await import("./payment-provider");
      
      const result = await processPayment(countryCode, {
        amount,
        currency: "NGN",
        userId,
        email: userEmail || undefined,
        description: "ZIBA Wallet Funding",
        callbackUrl: `${req.protocol}://${req.get("host")}/api/wallet/verify`,
      });
      
      if (!result.success) {
        return res.status(400).json({ message: result.error || "Payment initialization failed" });
      }
      
      console.log(`[Wallet] Funding initiated: ${amount} for ${userId}`);
      
      return res.json({
        success: true,
        transactionRef: result.transactionRef,
        authorizationUrl: result.authorizationUrl,
        message: result.message,
      });
    } catch (error) {
      console.error("Error initiating wallet funding:", error);
      return res.status(500).json({ message: "Failed to initialize payment" });
    }
  });
  
  // Verify wallet funding callback
  app.get("/api/wallet/verify", async (req, res) => {
    try {
      const { reference, trxref } = req.query;
      const transactionRef = (reference || trxref) as string;
      
      if (!transactionRef) {
        return res.redirect("/?payment=failed&reason=no_reference");
      }
      
      const { verifyPayment } = await import("./payment-provider");
      const result = await verifyPayment("NG", transactionRef);
      
      if (result.success) {
        console.log(`[Wallet] Payment verified: ${transactionRef}`);
        return res.redirect(`/?payment=success&ref=${transactionRef}`);
      } else {
        console.log(`[Wallet] Payment failed: ${transactionRef}`);
        return res.redirect(`/?payment=failed&ref=${transactionRef}`);
      }
    } catch (error) {
      console.error("Error verifying payment:", error);
      return res.redirect("/?payment=error");
    }
  });
  
  // Get payment status summary for admin
  app.get("/api/admin/payment-status", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const { getPaymentStatusSummary } = await import("./payment-provider");
      const status = await getPaymentStatusSummary();
      return res.json(status);
    } catch (error) {
      console.error("Error getting payment status:", error);
      return res.status(500).json({ message: "Failed to get status" });
    }
  });

  // Rider Transaction History
  app.get("/api/rider-transactions/:riderId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const targetRiderId = req.params.riderId;
      
      const userRole = await storage.getUserRole(userId);
      if (userId !== targetRiderId && !["super_admin", "admin", "finance"].includes(userRole?.role || "")) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const transactions = await storage.getRiderTransactionHistory(targetRiderId);
      return res.json(transactions);
    } catch (error) {
      console.error("Error fetching rider transactions:", error);
      return res.status(500).json({ message: "Failed to fetch transactions" });
    }
  });

  // Driver Payout History
  app.get("/api/driver-payout-history/:driverId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const targetDriverId = req.params.driverId;
      
      const userRole = await storage.getUserRole(userId);
      if (userId !== targetDriverId && !["super_admin", "admin", "finance"].includes(userRole?.role || "")) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const history = await storage.getDriverPayoutHistoryV2(targetDriverId);
      return res.json(history);
    } catch (error) {
      console.error("Error fetching payout history:", error);
      return res.status(500).json({ message: "Failed to fetch history" });
    }
  });

  // ==========================================
  // PRODUCTION SWITCHES (Phase 26)
  // SUPER_ADMIN ONLY - Server-side, Logged
  // ==========================================

  // Get all system configs (admin view)
  app.get("/api/admin/system-config", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const configs = await storage.getAllSystemConfigs();
      const launchMode = await storage.getSystemConfig("LAUNCH_MODE");
      const explanationMode = await storage.getSystemConfig("EXPLANATION_MODE");
      const inviteRequired = await storage.getSystemConfig("INVITE_REQUIRED");
      const driverCap = await storage.getSystemConfig("DRIVER_ONBOARDING_CAP");
      const dailyRideLimit = await storage.getSystemConfig("DAILY_RIDE_LIMIT");
      
      return res.json({
        configs,
        current: {
          launchMode: launchMode || "soft_launch",
          explanationMode: explanationMode === "true",
          inviteRequired: inviteRequired !== "false",
          driverOnboardingCap: parseInt(driverCap) || 50,
          dailyRideLimit: parseInt(dailyRideLimit) || 100,
        }
      });
    } catch (error) {
      console.error("Error getting system config:", error);
      return res.status(500).json({ message: "Failed to get config" });
    }
  });

  // Update system config (SUPER_ADMIN ONLY)
  app.patch("/api/admin/system-config/:key", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { key } = req.params;
      const { value, reason } = req.body;
      
      if (!value) {
        return res.status(400).json({ message: "Value is required" });
      }

      const validKeys = ["LAUNCH_MODE", "EXPLANATION_MODE", "INVITE_REQUIRED", "DRIVER_ONBOARDING_CAP", "DAILY_RIDE_LIMIT"];
      if (!validKeys.includes(key)) {
        return res.status(400).json({ message: "Invalid config key" });
      }

      if (key === "LAUNCH_MODE" && !["soft_launch", "full_launch"].includes(value)) {
        return res.status(400).json({ message: "Invalid launch mode" });
      }

      const config = await storage.setSystemConfig(key, value, userId, reason);
      console.log(`[SECURITY AUDIT] System config ${key} changed to "${value}" by ${userId}`);
      
      return res.json({ message: "Config updated", config });
    } catch (error) {
      console.error("Error updating system config:", error);
      return res.status(500).json({ message: "Failed to update config" });
    }
  });

  // Get countries with payment status
  app.get("/api/admin/countries/payments", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const countries = await storage.getAllCountriesWithPaymentStatus();
      return res.json(countries);
    } catch (error) {
      console.error("Error getting countries:", error);
      return res.status(500).json({ message: "Failed to get countries" });
    }
  });

  // Enable/Disable real payments for a country (SUPER_ADMIN ONLY)
  app.patch("/api/admin/countries/:countryId/payments", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { countryId } = req.params;
      const { paymentsEnabled, paymentProvider, confirmation } = req.body;

      // Require explicit confirmation for enabling payments
      if (paymentsEnabled === true && confirmation !== "ENABLE_REAL_PAYMENTS") {
        return res.status(400).json({ 
          message: "Enabling real payments requires explicit confirmation",
          required: "Send confirmation: 'ENABLE_REAL_PAYMENTS'" 
        });
      }

      const updated = await storage.setCountryPaymentSettings(
        countryId, 
        paymentsEnabled, 
        paymentProvider || null, 
        userId
      );

      if (!updated) {
        return res.status(404).json({ message: "Country not found" });
      }

      console.log(`[SECURITY AUDIT] Country ${countryId} payments=${paymentsEnabled} provider=${paymentProvider} by ${userId}`);
      
      return res.json({ 
        message: paymentsEnabled ? "Real payments ENABLED" : "Payments disabled (simulated mode)", 
        country: updated 
      });
    } catch (error) {
      console.error("Error updating country payments:", error);
      return res.status(500).json({ message: "Failed to update" });
    }
  });

  // Get config audit logs (SUPER_ADMIN ONLY)
  app.get("/api/admin/config-audit-logs", isAuthenticated, requireRole(["super_admin"]), async (req, res) => {
    try {
      const logs = await storage.getConfigAuditLogs(100);
      return res.json(logs);
    } catch (error) {
      console.error("Error getting audit logs:", error);
      return res.status(500).json({ message: "Failed to get logs" });
    }
  });

  // Get explanation mode content (for admin dashboard)
  app.get("/api/admin/explanation-summary", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const explanationEnabled = await storage.getSystemConfig("EXPLANATION_MODE");
      if (explanationEnabled !== "true") {
        return res.json({ enabled: false, content: null });
      }

      return res.json({
        enabled: true,
        content: {
          title: "ZIBA Platform - Operational Summary",
          sections: [
            {
              heading: "Wallet-First Payment Model",
              description: "All rides are prepaid from rider wallets. Funds are escrowed during the ride and released to drivers upon completion. This eliminates payment failures and disputes."
            },
            {
              heading: "Escrow Handling",
              description: "When a ride starts, the fare is locked in escrow. On completion, the driver receives their payout and ZIBA collects commission. On cancellation or dispute, funds are held pending resolution."
            },
            {
              heading: "Navigation Approach",
              description: "ZIBA does not embed map SDKs to reduce costs and complexity. Navigation is handled by opening the rider's/driver's native GPS apps (Google Maps, Apple Maps) via deep links."
            },
            {
              heading: "Cost Control Decisions",
              description: "No external routing APIs, no real-time map tiles, no third-party geolocation services. Distance is calculated using internal Haversine formula. This keeps operational costs near zero."
            },
            {
              heading: "Driver Classification",
              description: "Drivers are independent contractors, not employees. They set their own hours, accept or decline rides freely, and are responsible for their own vehicles and expenses."
            },
            {
              heading: "Fraud Protections",
              description: "Rule-based fraud detection flags suspicious patterns (excessive cancellations, fake movements, reservation abuse). All financial transactions are logged for audit."
            }
          ]
        }
      });
    } catch (error) {
      console.error("Error getting explanation:", error);
      return res.status(500).json({ message: "Failed to get explanation" });
    }
  });

  // Get current launch mode status for UI badge
  app.get("/api/launch-mode", isAuthenticated, async (req, res) => {
    try {
      const launchMode = await storage.getSystemConfig("LAUNCH_MODE");
      return res.json({ mode: launchMode || "soft_launch" });
    } catch (error) {
      return res.json({ mode: "soft_launch" });
    }
  });

  // =============================================
  // PHASE 3: RATINGS, BEHAVIOR SIGNALS & TRUST SCORING ENDPOINTS
  // =============================================

  // Submit a rating for a completed trip
  app.post("/api/ratings/submit", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const { tripId, rateeId, score, ratingRole } = req.body;

      if (!tripId || !rateeId || !score || !ratingRole) {
        return res.status(400).json({ message: "Missing required fields: tripId, rateeId, score, ratingRole" });
      }

      const trip = await storage.getTripById(tripId);
      if (!trip) {
        return res.status(404).json({ message: "Trip not found" });
      }

      if (trip.status !== "completed") {
        return res.status(400).json({ message: "Can only rate completed trips" });
      }

      if (ratingRole === "rider_to_driver" && trip.riderId !== userId) {
        return res.status(403).json({ message: "Only the rider can rate the driver" });
      }
      if (ratingRole === "driver_to_rider" && trip.driverId !== userId) {
        return res.status(403).json({ message: "Only the driver can rate the rider" });
      }

      const { submitRating } = await import("./trust-guards");
      const result = await submitRating(
        tripId,
        userId,
        rateeId,
        score,
        ratingRole,
        new Date(trip.completedAt)
      );

      if (!result.success) {
        return res.status(400).json({ message: result.error, code: result.code });
      }

      return res.json({
        success: true,
        ratingId: result.ratingId,
        message: "Rating submitted successfully",
      });
    } catch (error) {
      console.error("Error submitting rating:", error);
      return res.status(500).json({ message: "Failed to submit rating" });
    }
  });

  // Get ratings for a specific trip
  app.get("/api/ratings/trip/:tripId", isAuthenticated, async (req, res) => {
    try {
      const ratings = await storage.getTrustTripRatings(req.params.tripId);
      return res.json(ratings);
    } catch (error) {
      console.error("Error getting trip ratings:", error);
      return res.status(500).json({ message: "Failed to get ratings" });
    }
  });

  // Check if user can rate a trip
  app.get("/api/ratings/can-rate/:tripId", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const { tripId } = req.params;

      const trip = await storage.getTripById(tripId);
      if (!trip) {
        return res.status(404).json({ canRate: false, reason: "Trip not found" });
      }

      if (trip.status !== "completed") {
        return res.json({ canRate: false, reason: "Trip not completed" });
      }

      const existingRating = await storage.getTripRatingByRater(tripId, userId);
      if (existingRating) {
        return res.json({ canRate: false, reason: "Already rated" });
      }

      const { isRatingWindowOpen } = await import("@shared/trust-config");
      if (!isRatingWindowOpen(new Date(trip.completedAt))) {
        return res.json({ canRate: false, reason: "Rating window expired" });
      }

      let ratingRole: "rider_to_driver" | "driver_to_rider" | null = null;
      let rateeId: string | null = null;

      if (trip.riderId === userId && trip.driverId) {
        ratingRole = "rider_to_driver";
        rateeId = trip.driverId;
      } else if (trip.driverId === userId) {
        ratingRole = "driver_to_rider";
        rateeId = trip.riderId;
      }

      if (!ratingRole || !rateeId) {
        return res.json({ canRate: false, reason: "Not a participant of this trip" });
      }

      return res.json({ canRate: true, ratingRole, rateeId });
    } catch (error) {
      console.error("Error checking rating eligibility:", error);
      return res.status(500).json({ message: "Failed to check rating eligibility" });
    }
  });

  // Admin: Get all trust profiles (read-only)
  app.get("/api/admin/trust/profiles", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const { getAllTrustProfiles } = await import("./trust-guards");
      const profiles = await getAllTrustProfiles();
      return res.json(profiles);
    } catch (error) {
      console.error("Error getting trust profiles:", error);
      return res.status(500).json({ message: "Failed to get trust profiles" });
    }
  });

  // Admin: Get trust details for a specific user (read-only)
  app.get("/api/admin/trust/user/:userId", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const { getAdminTrustView } = await import("./trust-guards");
      const details = await getAdminTrustView(req.params.userId);
      return res.json(details);
    } catch (error) {
      console.error("Error getting user trust details:", error);
      return res.status(500).json({ message: "Failed to get user trust details" });
    }
  });

  // Admin: Get all trust audit logs (read-only)
  app.get("/api/admin/trust/audit-logs", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const { getAllTrustAuditLogs } = await import("./trust-guards");
      const logs = await getAllTrustAuditLogs();
      return res.json(logs);
    } catch (error) {
      console.error("Error getting trust audit logs:", error);
      return res.status(500).json({ message: "Failed to get audit logs" });
    }
  });

  // Admin: Get trust score thresholds (for future enforcement)
  app.get("/api/admin/trust/thresholds", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const { trustScoreThresholdLow, trustScoreThresholdHigh } = await import("./trust-guards");
      return res.json({
        low: trustScoreThresholdLow(),
        high: trustScoreThresholdHigh(),
      });
    } catch (error) {
      console.error("Error getting trust thresholds:", error);
      return res.status(500).json({ message: "Failed to get thresholds" });
    }
  });

  // =============================================
  // SUPER ADMIN RATING CONTROL ENDPOINTS
  // =============================================

  // Super Admin: Adjust user rating
  app.post("/api/admin/trust/adjust-rating", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminEmail = req.user.claims.email;
      const adminUserId = req.user.claims.sub;
      const { targetUserId, newRating, reason, adminNote, resetRatingCount } = req.body;

      if (!targetUserId || newRating === undefined || !reason) {
        return res.status(400).json({ message: "Target user ID, new rating, and reason are required" });
      }

      const ratingValue = parseFloat(newRating);
      if (isNaN(ratingValue) || ratingValue < 0 || ratingValue > 5) {
        return res.status(400).json({ message: "Rating must be between 0 and 5" });
      }

      // Get current user trust profile
      const profile = await storage.getUserTrustProfile(targetUserId);
      if (!profile) {
        return res.status(404).json({ message: "User trust profile not found" });
      }

      const oldRating = parseFloat(profile.averageRating || "5.00");
      const oldRatingCount = profile.totalRatingsReceived;

      // Update the user's rating
      await storage.updateUserTrustProfile(targetUserId, {
        averageRating: ratingValue.toFixed(2),
        totalRatingsReceived: resetRatingCount ? 0 : profile.totalRatingsReceived,
      });

      // Create audit log entry
      await storage.createAdminRatingAudit({
        adminEmail,
        adminUserId,
        targetUserId,
        oldRating: String(oldRating.toFixed(2)),
        newRating: String(ratingValue.toFixed(2)),
        oldRatingCount,
        newRatingCount: resetRatingCount ? 0 : oldRatingCount,
        reason,
        adminNote: adminNote || null,
      });

      return res.json({ 
        success: true, 
        message: "Rating adjusted successfully",
        oldRating: oldRating.toFixed(2),
        newRating: ratingValue.toFixed(2),
      });
    } catch (error) {
      console.error("Error adjusting user rating:", error);
      return res.status(500).json({ message: "Failed to adjust rating" });
    }
  });

  // Super Admin: Get rating audit history for a user
  app.get("/api/admin/trust/rating-audit/:userId", isAuthenticated, requireRole(["super_admin"]), async (req, res) => {
    try {
      const audits = await storage.getAdminRatingAuditForUser(req.params.userId);
      return res.json(audits);
    } catch (error) {
      console.error("Error getting rating audit history:", error);
      return res.status(500).json({ message: "Failed to get rating audit history" });
    }
  });

  // Super Admin: Get all rating audits
  app.get("/api/admin/trust/rating-audits", isAuthenticated, requireRole(["super_admin"]), async (req, res) => {
    try {
      const audits = await storage.getAllAdminRatingAudits();
      return res.json(audits);
    } catch (error) {
      console.error("Error getting all rating audits:", error);
      return res.status(500).json({ message: "Failed to get rating audits" });
    }
  });

  // =============================================
  // PAIRING BLOCK MANAGEMENT ENDPOINTS
  // =============================================

  // Admin: Get all pairing blocks
  app.get("/api/admin/pairing-blocks", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const blocks = await storage.getAllPairingBlocks();
      return res.json(blocks);
    } catch (error) {
      console.error("Error getting pairing blocks:", error);
      return res.status(500).json({ message: "Failed to get pairing blocks" });
    }
  });

  // Admin: Get pairing blocks for a specific user
  app.get("/api/admin/pairing-blocks/user/:userId", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const blocks = await storage.getPairingBlocksByUser(req.params.userId);
      return res.json(blocks);
    } catch (error) {
      console.error("Error getting user pairing blocks:", error);
      return res.status(500).json({ message: "Failed to get user pairing blocks" });
    }
  });

  // Super Admin: Remove pairing block (override)
  app.post("/api/admin/pairing-blocks/remove", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { riderId, driverId, reason } = req.body;

      if (!riderId || !driverId || !reason) {
        return res.status(400).json({ message: "Rider ID, driver ID, and reason are required" });
      }

      const removedBlock = await storage.removePairingBlock(riderId, driverId, adminId, reason);
      
      if (!removedBlock) {
        return res.status(404).json({ message: "No active pairing block found between these users" });
      }

      return res.json({ 
        success: true, 
        message: "Pairing block removed successfully",
        block: removedBlock,
      });
    } catch (error) {
      console.error("Error removing pairing block:", error);
      return res.status(500).json({ message: "Failed to remove pairing block" });
    }
  });

  // Driver matching: Check if driver is blocked for rider
  app.get("/api/matching/blocked-drivers/:riderId", isAuthenticated, async (req, res) => {
    try {
      const blockedDrivers = await storage.getBlockedDriversForRider(req.params.riderId);
      return res.json({ blockedDrivers });
    } catch (error) {
      console.error("Error getting blocked drivers:", error);
      return res.status(500).json({ message: "Failed to get blocked drivers" });
    }
  });

  // =============================================
  // PHASE 4: SAFETY & INCIDENT INTELLIGENCE ENDPOINTS
  // =============================================

  // SOS Trigger - available during active trips
  app.post("/api/safety/sos", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const { tripId, isSilentMode, latitude, longitude, speed, routePolyline } = req.body;

      if (!tripId) {
        return res.status(400).json({ message: "Trip ID is required" });
      }

      const trip = await storage.getTripById(tripId);
      if (!trip) {
        return res.status(404).json({ message: "Trip not found" });
      }

      let role: "RIDER" | "DRIVER";
      if (trip.riderId === userId) {
        role = "RIDER";
      } else if (trip.driverId === userId) {
        role = "DRIVER";
      } else {
        return res.status(403).json({ message: "You are not part of this trip" });
      }

      const { triggerSos } = await import("./safety-guards");
      const result = await triggerSos(tripId, userId, role, isSilentMode || false, {
        latitude: latitude?.toString(),
        longitude: longitude?.toString(),
        speed: speed?.toString(),
        routePolyline,
      });

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({
        success: true,
        triggerId: result.triggerId,
        message: "SOS triggered successfully",
      });
    } catch (error) {
      console.error("Error triggering SOS:", error);
      return res.status(500).json({ message: "Failed to trigger SOS" });
    }
  });

  // Report an incident
  app.post("/api/safety/incident", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const { tripId, accusedUserId, incidentType, severity, description, evidenceMetadata } = req.body;

      if (!tripId || !accusedUserId || !incidentType || !severity || !description) {
        return res.status(400).json({ 
          message: "Missing required fields: tripId, accusedUserId, incidentType, severity, description" 
        });
      }

      const trip = await storage.getTripById(tripId);
      if (!trip) {
        return res.status(404).json({ message: "Trip not found" });
      }

      let role: "RIDER" | "DRIVER";
      if (trip.riderId === userId) {
        role = "RIDER";
      } else if (trip.driverId === userId) {
        role = "DRIVER";
      } else {
        return res.status(403).json({ message: "You are not part of this trip" });
      }

      const { reportIncident } = await import("./safety-guards");
      const result = await reportIncident(
        tripId,
        userId,
        role,
        accusedUserId,
        incidentType,
        severity,
        description,
        evidenceMetadata,
        trip.countryCode || undefined
      );

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({
        success: true,
        incidentId: result.incidentId,
        autoSuspended: result.autoSuspended,
        message: "Incident reported successfully",
      });
    } catch (error) {
      console.error("Error reporting incident:", error);
      return res.status(500).json({ message: "Failed to report incident" });
    }
  });

  // Get user's reported incidents
  app.get("/api/safety/my-incidents", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const incidents = await storage.getIncidentsByUser(userId);
      return res.json(incidents);
    } catch (error) {
      console.error("Error getting incidents:", error);
      return res.status(500).json({ message: "Failed to get incidents" });
    }
  });

  // Check if user is suspended
  app.get("/api/safety/suspension-status", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const isSuspended = await storage.isUserSuspended(userId);
      const activeSuspension = isSuspended ? await storage.getActiveSuspensionForUser(userId) : null;
      
      return res.json({
        isSuspended,
        suspension: activeSuspension ? {
          reason: activeSuspension.reason,
          type: activeSuspension.suspensionType,
          expiresAt: activeSuspension.expiresAt,
        } : null,
      });
    } catch (error) {
      console.error("Error checking suspension status:", error);
      return res.status(500).json({ message: "Failed to check suspension status" });
    }
  });

  // Admin: Get incident queue
  app.get("/api/admin/safety/incidents", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const { getIncidentQueue } = await import("./safety-guards");
      const incidents = await getIncidentQueue();
      return res.json(incidents);
    } catch (error) {
      console.error("Error getting incident queue:", error);
      return res.status(500).json({ message: "Failed to get incidents" });
    }
  });

  // Admin: Get all incidents by status
  app.get("/api/admin/safety/incidents/:status", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const incidents = await storage.getIncidentsByStatus(req.params.status);
      return res.json(incidents);
    } catch (error) {
      console.error("Error getting incidents by status:", error);
      return res.status(500).json({ message: "Failed to get incidents" });
    }
  });

  // Admin: Get single incident details
  app.get("/api/admin/safety/incident/:incidentId", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const incident = await storage.getIncident(req.params.incidentId);
      if (!incident) {
        return res.status(404).json({ message: "Incident not found" });
      }
      
      const auditLogs = await storage.getSafetyAuditLogsForIncident(req.params.incidentId);
      return res.json({ incident, auditLogs });
    } catch (error) {
      console.error("Error getting incident:", error);
      return res.status(500).json({ message: "Failed to get incident" });
    }
  });

  // Admin: Review incident (assign to self)
  app.post("/api/admin/safety/incident/:incidentId/review", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { adminReviewIncident } = await import("./safety-guards");
      const result = await adminReviewIncident(req.params.incidentId, adminId);

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true, message: "Incident under review" });
    } catch (error) {
      console.error("Error reviewing incident:", error);
      return res.status(500).json({ message: "Failed to review incident" });
    }
  });

  // Admin: Approve incident (resolve)
  app.post("/api/admin/safety/incident/:incidentId/approve", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { notes, suspendUser, isPermanentBan } = req.body;

      if (!notes) {
        return res.status(400).json({ message: "Notes are required" });
      }

      const { adminApproveIncident } = await import("./safety-guards");
      const result = await adminApproveIncident(
        req.params.incidentId,
        adminId,
        notes,
        suspendUser || false,
        isPermanentBan || false
      );

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true, message: "Incident approved and resolved" });
    } catch (error) {
      console.error("Error approving incident:", error);
      return res.status(500).json({ message: "Failed to approve incident" });
    }
  });

  // Admin: Dismiss incident
  app.post("/api/admin/safety/incident/:incidentId/dismiss", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { reason } = req.body;

      if (!reason) {
        return res.status(400).json({ message: "Dismissal reason is required" });
      }

      const { adminDismissIncident } = await import("./safety-guards");
      const result = await adminDismissIncident(req.params.incidentId, adminId, reason);

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true, message: "Incident dismissed" });
    } catch (error) {
      console.error("Error dismissing incident:", error);
      return res.status(500).json({ message: "Failed to dismiss incident" });
    }
  });

  // Admin: Escalate incident
  app.post("/api/admin/safety/incident/:incidentId/escalate", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { reason } = req.body;

      if (!reason) {
        return res.status(400).json({ message: "Escalation reason is required" });
      }

      const { adminEscalateIncident } = await import("./safety-guards");
      const result = await adminEscalateIncident(req.params.incidentId, adminId, reason);

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true, message: "Incident escalated" });
    } catch (error) {
      console.error("Error escalating incident:", error);
      return res.status(500).json({ message: "Failed to escalate incident" });
    }
  });

  // Admin: Get all active suspensions
  app.get("/api/admin/safety/suspensions", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const { getAllSuspensions } = await import("./safety-guards");
      const suspensions = await getAllSuspensions();
      return res.json(suspensions);
    } catch (error) {
      console.error("Error getting suspensions:", error);
      return res.status(500).json({ message: "Failed to get suspensions" });
    }
  });

  // Admin: Ban user permanently
  app.post("/api/admin/safety/ban/:userId", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { reason, relatedIncidentId } = req.body;

      if (!reason) {
        return res.status(400).json({ message: "Ban reason is required" });
      }

      const { adminBanUser } = await import("./safety-guards");
      const result = await adminBanUser(req.params.userId, adminId, reason, relatedIncidentId);

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true, suspensionId: result.suspensionId, message: "User permanently banned" });
    } catch (error) {
      console.error("Error banning user:", error);
      return res.status(500).json({ message: "Failed to ban user" });
    }
  });

  // Admin: Lift suspension
  app.post("/api/admin/safety/suspension/:suspensionId/lift", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { reason } = req.body;

      if (!reason) {
        return res.status(400).json({ message: "Lift reason is required" });
      }

      const { liftUserSuspension } = await import("./safety-guards");
      const result = await liftUserSuspension(req.params.suspensionId, adminId, reason);

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true, message: "Suspension lifted" });
    } catch (error) {
      console.error("Error lifting suspension:", error);
      return res.status(500).json({ message: "Failed to lift suspension" });
    }
  });

  // Admin: Get user safety profile
  app.get("/api/admin/safety/user/:userId", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const { getUserSafetyProfile } = await import("./safety-guards");
      const profile = await getUserSafetyProfile(req.params.userId);
      return res.json(profile);
    } catch (error) {
      console.error("Error getting user safety profile:", error);
      return res.status(500).json({ message: "Failed to get user safety profile" });
    }
  });

  // Admin: Get all safety audit logs
  app.get("/api/admin/safety/audit-logs", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const { getSafetyAuditLogs } = await import("./safety-guards");
      const logs = await getSafetyAuditLogs();
      return res.json(logs);
    } catch (error) {
      console.error("Error getting safety audit logs:", error);
      return res.status(500).json({ message: "Failed to get audit logs" });
    }
  });

  // Admin: Get SOS triggers for a trip
  app.get("/api/admin/safety/sos/trip/:tripId", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const triggers = await storage.getSosTriggersByTrip(req.params.tripId);
      return res.json(triggers);
    } catch (error) {
      console.error("Error getting SOS triggers:", error);
      return res.status(500).json({ message: "Failed to get SOS triggers" });
    }
  });

  // =============================================
  // LOST ITEM REPORTS
  // =============================================

  // Rider: Report a lost item
  app.post("/api/lost-items", isAuthenticated, async (req, res) => {
    try {
      const riderId = req.user!.claims.sub;
      const { tripId, itemDescription, itemCategory, lastSeenLocation, contactPhone, photoUrls } = req.body;

      if (!tripId || !itemDescription) {
        return res.status(400).json({ message: "Trip ID and item description are required" });
      }

      const trip = await storage.getTripById(tripId);
      if (!trip) {
        return res.status(404).json({ message: "Trip not found" });
      }

      const report = await storage.createLostItemReport({
        tripId,
        riderId,
        driverId: trip.driverId || "",
        itemDescription,
        itemType: itemCategory || "other",
        status: "reported",
      });

      // Auto-generate fraud detection signals
      try {
        const previousReports = await storage.getLostItemReportsByRider(riderId);
        const recentReports = previousReports.filter(r => {
          const created = new Date(r.createdAt || 0);
          const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
          return created > thirtyDaysAgo;
        });

        // Frequent reporter: 3+ reports in 30 days
        if (recentReports.length >= 3) {
          await storage.createLostItemFraudSignal({
            userId: riderId,
            userRole: "rider",
            relatedReportId: report.id,
            signalType: "frequent_reporter",
            severity: recentReports.length >= 5 ? "high" : "medium",
            riskScore: Math.min(recentReports.length * 15, 100),
            description: `${recentReports.length} lost item reports in the last 30 days`,
          });
        }

        // Same item type: 2+ reports with the same item type in 30 days
        const sameTypeReports = recentReports.filter(r => r.itemType === (itemCategory || "other"));
        if (sameTypeReports.length >= 2) {
          await storage.createLostItemFraudSignal({
            userId: riderId,
            userRole: "rider",
            relatedReportId: report.id,
            signalType: "same_item_type",
            severity: sameTypeReports.length >= 3 ? "high" : "medium",
            riskScore: Math.min(sameTypeReports.length * 20, 100),
            description: `${sameTypeReports.length} reports for "${itemCategory || "other"}" items in the last 30 days`,
          });
        }

        // No proof: report with no photos
        if (!photoUrls || (Array.isArray(photoUrls) && photoUrls.length === 0)) {
          await storage.createLostItemFraudSignal({
            userId: riderId,
            userRole: "rider",
            relatedReportId: report.id,
            signalType: "no_proof",
            severity: "low",
            riskScore: 10,
            description: "Lost item report submitted without photo evidence",
          });
        }

        // Frequent accused: check if this driver has been accused often
        const allReports = await storage.getAllLostItemReports();
        const driverAccusations = allReports.filter(r => 
          r.driverId === (trip.driverId || "") && 
          new Date(r.createdAt || 0) > new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
        );
        if (driverAccusations.length >= 3) {
          await storage.createLostItemFraudSignal({
            userId: trip.driverId || "",
            userRole: "driver",
            relatedReportId: report.id,
            signalType: "frequent_accused",
            severity: driverAccusations.length >= 5 ? "high" : "medium",
            riskScore: Math.min(driverAccusations.length * 15, 100),
            description: `Driver accused in ${driverAccusations.length} lost item reports in the last 30 days`,
          });
        }
      } catch (fraudError) {
        console.error("Fraud signal generation failed (non-blocking):", fraudError);
      }

      return res.status(201).json(report);
    } catch (error) {
      console.error("Error creating lost item report:", error);
      return res.status(500).json({ message: "Failed to create report" });
    }
  });

  // Rider: Get my lost item reports
  app.get("/api/lost-items/my-reports", isAuthenticated, async (req, res) => {
    try {
      const riderId = req.user!.claims.sub;
      const reports = await storage.getLostItemReportsByRider(riderId);
      return res.json(reports);
    } catch (error) {
      console.error("Error getting lost item reports:", error);
      return res.status(500).json({ message: "Failed to get reports" });
    }
  });

  // Driver: Get lost item reports assigned to me
  app.get("/api/lost-items/driver-reports", isAuthenticated, async (req, res) => {
    try {
      const driverId = req.user!.claims.sub;
      const reports = await storage.getLostItemReportsByDriver(driverId);
      return res.json(reports);
    } catch (error) {
      console.error("Error getting driver lost item reports:", error);
      return res.status(500).json({ message: "Failed to get reports" });
    }
  });

  // Get single lost item report
  app.get("/api/lost-items/:id", isAuthenticated, async (req, res) => {
    try {
      const report = await storage.getLostItemReport(req.params.id);
      if (!report) {
        return res.status(404).json({ message: "Report not found" });
      }
      return res.json(report);
    } catch (error) {
      console.error("Error getting lost item report:", error);
      return res.status(500).json({ message: "Failed to get report" });
    }
  });

  // Driver: Confirm or deny lost item
  app.patch("/api/lost-items/:id/driver-response", isAuthenticated, async (req, res) => {
    try {
      const driverId = req.user!.claims.sub;
      const { response, driverNotes } = req.body;

      if (!response || !["driver_confirmed", "driver_denied"].includes(response)) {
        return res.status(400).json({ message: "Response must be 'driver_confirmed' or 'driver_denied'" });
      }

      const report = await storage.getLostItemReport(req.params.id);
      if (!report) {
        return res.status(404).json({ message: "Report not found" });
      }
      if (report.driverId !== driverId) {
        return res.status(403).json({ message: "Not authorized" });
      }

      const updateData: any = {
        status: response === "driver_confirmed" ? "found" : "driver_denied",
        driverHasItem: response === "driver_confirmed",
        driverConfirmedAt: new Date(),
      };
      if (driverNotes) updateData.adminNotes = driverNotes;

      // When driver confirms item found: unlock communication + make rider phone visible to driver
      if (response === "driver_confirmed") {
        updateData.communicationUnlocked = true;
        updateData.communicationUnlockedAt = new Date();
        updateData.riderPhoneVisible = true;
      }

      const updated = await storage.updateLostItemReport(req.params.id, updateData);

      // Create system message in chat
      if (response === "driver_confirmed") {
        await storage.createLostItemMessage({
          lostItemReportId: req.params.id,
          senderId: "system",
          senderRole: "system",
          message: "Driver confirmed the item was found. Chat is now unlocked for coordinating the return.",
          isSystemMessage: true,
        });
      }

      // Capture trust signal for driver response
      try {
        const { captureBehaviorSignal } = await import("./trust-guards");
        if (response === "driver_confirmed") {
          await captureBehaviorSignal(driverId, "LOST_ITEM_RETURNED", "driver", report.tripId, { lostItemId: req.params.id });
        } else if (response === "driver_denied") {
          await captureBehaviorSignal(driverId, "LOST_ITEM_DENIED", "driver", report.tripId, { lostItemId: req.params.id });
        }
      } catch (signalErr) {
        console.error("Trust signal capture failed (non-blocking):", signalErr);
      }

      return res.json(updated);
    } catch (error) {
      console.error("Error updating lost item report:", error);
      return res.status(500).json({ message: "Failed to update report" });
    }
  });

  // Update lost item status (return in progress, returned, disputed, resolved_by_admin)
  app.patch("/api/lost-items/:id/status", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const { status, returnFee, driverShare, platformFee, returnLocation, returnNotes, disputeReason } = req.body;

      if (!status) {
        return res.status(400).json({ message: "Status is required" });
      }

      const validStatuses = ["reported", "found", "en_route_to_hub", "at_hub", "returned", "disputed", "resolved_by_admin", "driver_denied", "closed"];
      if (!validStatuses.includes(status)) {
        return res.status(400).json({ message: `Invalid status. Must be one of: ${validStatuses.join(", ")}` });
      }

      const report = await storage.getLostItemReport(req.params.id);
      if (!report) {
        return res.status(404).json({ message: "Report not found" });
      }

      const updateData: any = { status };
      if (returnFee !== undefined) updateData.returnFeeAmount = returnFee;
      if (driverShare !== undefined) updateData.driverPayout = driverShare;
      if (platformFee !== undefined) updateData.platformFee = platformFee;
      if (returnLocation) updateData.meetupLocation = returnLocation;

      if (status === "returned") {
        updateData.returnCompletedAt = new Date();
        updateData.driverPhoneVisible = true;

        // Apply return fee from config if not provided
        if (!returnFee && report.driverId) {
          try {
            const feeConfig = await storage.getLostItemFeeConfig("NG");
            if (feeConfig) {
              const fee = report.urgency === "urgent" ? parseFloat(feeConfig.urgentFee || "0") : parseFloat(feeConfig.standardFee || "0");
              const driverPct = feeConfig.driverSharePercent || 75;
              updateData.returnFeeAmount = fee.toFixed(2);
              updateData.driverPayout = (fee * driverPct / 100).toFixed(2);
              updateData.platformFee = (fee * (100 - driverPct) / 100).toFixed(2);
              updateData.feeCollected = true;
            }
          } catch (feeErr) {
            console.error("Fee calculation failed (non-blocking):", feeErr);
          }
        }

        // System message
        await storage.createLostItemMessage({
          lostItemReportId: req.params.id,
          senderId: "system",
          senderRole: "system",
          message: "Item has been returned successfully. Driver phone number is now visible to the rider.",
          isSystemMessage: true,
        });
      }

      if (status === "disputed") {
        updateData.disputeReason = disputeReason || "No reason provided";
        await storage.createLostItemMessage({
          lostItemReportId: req.params.id,
          senderId: "system",
          senderRole: "system",
          message: "This case has been disputed and escalated for admin review.",
          isSystemMessage: true,
        });
      }

      if (status === "resolved_by_admin") {
        updateData.resolvedByAdminId = userId;
        updateData.resolvedAt = new Date();
        await storage.createLostItemMessage({
          lostItemReportId: req.params.id,
          senderId: "system",
          senderRole: "system",
          message: "This case has been resolved by an administrator.",
          isSystemMessage: true,
        });
      }

      const updated = await storage.updateLostItemReport(req.params.id, updateData);

      // Log analytics on terminal states
      if (["returned", "disputed", "resolved_by_admin", "closed"].includes(status)) {
        try {
          const messages = await storage.getLostItemMessages(req.params.id);
          const fraudSignals = await storage.getLostItemFraudSignalsByUser(report.riderId);
          const riderReports = await storage.getLostItemReportsByRider(report.riderId);
          const driverReports = report.driverId ? await storage.getLostItemReportsByDriver(report.driverId) : [];
          const driverReturns = driverReports.filter(r => r.status === "returned").length;
          const driverDenials = driverReports.filter(r => r.status === "driver_denied").length;

          const createdAt = new Date(report.createdAt);
          const resolvedAt = new Date();
          const resolutionHours = (resolvedAt.getTime() - createdAt.getTime()) / (1000 * 60 * 60);

          await storage.createLostItemAnalytics({
            lostItemReportId: req.params.id,
            riderId: report.riderId,
            driverId: report.driverId || undefined,
            tripId: report.tripId,
            itemCategory: report.itemType,
            outcome: status,
            reportToResolutionHours: resolutionHours.toFixed(2),
            returnFeeApplied: updated?.returnFeeAmount || undefined,
            driverEarnings: updated?.driverPayout || undefined,
            riderLostItemCount: riderReports.length,
            driverReturnCount: driverReturns,
            driverDenialCount: driverDenials,
            chatMessageCount: messages.filter(m => !m.isSystemMessage).length,
            fraudSignalCount: fraudSignals.filter(s => s.lostItemReportId === req.params.id).length,
          });
        } catch (analyticsErr) {
          console.error("Analytics logging failed (non-blocking):", analyticsErr);
        }
      }

      // Capture trust signal for status transitions
      try {
        const { captureBehaviorSignal } = await import("./trust-guards");
        if (status === "returned" && report.riderId) {
          await captureBehaviorSignal(report.riderId, "LOST_ITEM_RESOLVED", "rider", report.tripId, { lostItemId: req.params.id });
        }
      } catch (signalErr) {
        console.error("Trust signal capture failed (non-blocking):", signalErr);
      }

      return res.json(updated);
    } catch (error) {
      console.error("Error updating lost item status:", error);
      return res.status(500).json({ message: "Failed to update status" });
    }
  });

  // Admin: Get all lost item reports
  app.get("/api/admin/lost-items", isAuthenticated, requireRole(["super_admin", "admin", "support_agent"]), async (req, res) => {
    try {
      const { status } = req.query;
      const reports = status 
        ? await storage.getLostItemReportsByStatus(status as string)
        : await storage.getAllLostItemReports();
      return res.json(reports);
    } catch (error) {
      console.error("Error getting all lost item reports:", error);
      return res.status(500).json({ message: "Failed to get reports" });
    }
  });

  // Admin: Get/update lost item fee config
  app.get("/api/admin/lost-item-fees", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const configs = await storage.getAllLostItemFeeConfigs();
      return res.json(configs);
    } catch (error) {
      console.error("Error getting lost item fee configs:", error);
      return res.status(500).json({ message: "Failed to get configs" });
    }
  });

  app.post("/api/admin/lost-item-fees", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const { countryCode, standardFee, urgentFee, driverSharePercent, platformSharePercent } = req.body;
      if (!countryCode) {
        return res.status(400).json({ message: "Country code is required" });
      }
      const config = await storage.upsertLostItemFeeConfig({
        countryCode,
        standardFee: standardFee || "500.00",
        urgentFee: urgentFee || "1000.00",
        driverSharePercent: driverSharePercent || 75,
        platformSharePercent: platformSharePercent || 25,
      });
      return res.json(config);
    } catch (error) {
      console.error("Error updating lost item fee config:", error);
      return res.status(500).json({ message: "Failed to update config" });
    }
  });

  // =============================================
  // LOST ITEM CHAT & COMMUNICATION
  // =============================================

  // Get chat messages for a lost item report
  app.get("/api/lost-items/:id/messages", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const report = await storage.getLostItemReport(req.params.id);
      if (!report) {
        return res.status(404).json({ message: "Report not found" });
      }
      if (report.riderId !== userId && report.driverId !== userId) {
        const role = await storage.getUserRole(userId);
        if (!role || !["super_admin", "admin", "support_agent"].includes(role.role)) {
          return res.status(403).json({ message: "Not authorized" });
        }
      }
      if (!report.communicationUnlocked) {
        return res.json([]);
      }
      await storage.markLostItemMessagesRead(req.params.id, userId);
      const messages = await storage.getLostItemMessages(req.params.id);
      return res.json(messages);
    } catch (error) {
      console.error("Error getting lost item messages:", error);
      return res.status(500).json({ message: "Failed to get messages" });
    }
  });

  // Send a chat message for a lost item report
  app.post("/api/lost-items/:id/messages", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const { message } = req.body;
      if (!message || !message.trim()) {
        return res.status(400).json({ message: "Message is required" });
      }
      const report = await storage.getLostItemReport(req.params.id);
      if (!report) {
        return res.status(404).json({ message: "Report not found" });
      }
      if (report.riderId !== userId && report.driverId !== userId) {
        return res.status(403).json({ message: "Only the rider or driver can send messages" });
      }
      if (!report.communicationUnlocked) {
        return res.status(403).json({ message: "Communication is not yet unlocked for this report" });
      }
      const senderRole = report.riderId === userId ? "rider" : "driver";
      const msg = await storage.createLostItemMessage({
        lostItemReportId: req.params.id,
        senderId: userId,
        senderRole,
        message: message.trim(),
        isSystemMessage: false,
      });
      return res.status(201).json(msg);
    } catch (error) {
      console.error("Error sending lost item message:", error);
      return res.status(500).json({ message: "Failed to send message" });
    }
  });

  // Get phone number for a lost item (privacy-controlled)
  app.get("/api/lost-items/:id/phone", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const report = await storage.getLostItemReport(req.params.id);
      if (!report) {
        return res.status(404).json({ message: "Report not found" });
      }

      const isRider = report.riderId === userId;
      const isDriver = report.driverId === userId;
      if (!isRider && !isDriver) {
        return res.status(403).json({ message: "Not authorized" });
      }

      // Rider wants driver phone: only after item is returned
      if (isRider && report.driverPhoneVisible && report.driverId) {
        const driverProfile = await storage.getDriverProfile(report.driverId);
        return res.json({ phone: driverProfile?.phone || null, role: "driver" });
      }

      // Driver wants rider phone: only after driver confirms found
      if (isDriver && report.riderPhoneVisible) {
        const riderUser = await storage.getUser(report.riderId);
        return res.json({ phone: riderUser?.phone || null, role: "rider" });
      }

      return res.json({ phone: null, message: "Phone not yet available" });
    } catch (error) {
      console.error("Error getting phone for lost item:", error);
      return res.status(500).json({ message: "Failed to get phone" });
    }
  });

  // Admin: Unlock or revoke communication for a lost item
  app.patch("/api/admin/lost-items/:id/communication", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { unlock, riderPhoneVisible, driverPhoneVisible } = req.body;

      const report = await storage.getLostItemReport(req.params.id);
      if (!report) {
        return res.status(404).json({ message: "Report not found" });
      }

      const updateData: any = {};
      if (unlock !== undefined) {
        updateData.communicationUnlocked = unlock;
        updateData.communicationUnlockedBy = adminId;
        updateData.communicationUnlockedAt = new Date();
      }
      if (riderPhoneVisible !== undefined) updateData.riderPhoneVisible = riderPhoneVisible;
      if (driverPhoneVisible !== undefined) updateData.driverPhoneVisible = driverPhoneVisible;

      const updated = await storage.updateLostItemReport(req.params.id, updateData);

      const action = unlock ? "unlocked" : "revoked";
      await storage.createLostItemMessage({
        lostItemReportId: req.params.id,
        senderId: "system",
        senderRole: "system",
        message: `Admin has ${action} communication for this case.`,
        isSystemMessage: true,
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error updating communication:", error);
      return res.status(500).json({ message: "Failed to update communication" });
    }
  });

  // Admin: Resolve a disputed lost item case
  app.patch("/api/admin/lost-items/:id/resolve", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { resolution, adminNotes } = req.body;

      const report = await storage.getLostItemReport(req.params.id);
      if (!report) {
        return res.status(404).json({ message: "Report not found" });
      }

      const updated = await storage.updateLostItemReport(req.params.id, {
        status: "resolved_by_admin",
        resolvedByAdminId: adminId,
        resolvedAt: new Date(),
        adminNotes: adminNotes || resolution || null,
      });

      await storage.createLostItemMessage({
        lostItemReportId: req.params.id,
        senderId: "system",
        senderRole: "system",
        message: `Case resolved by admin. ${adminNotes || ""}`.trim(),
        isSystemMessage: true,
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error resolving lost item:", error);
      return res.status(500).json({ message: "Failed to resolve" });
    }
  });

  // Admin: Get lost item analytics summary
  app.get("/api/admin/lost-item-analytics", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const summary = await storage.getLostItemAnalyticsSummary();
      return res.json(summary);
    } catch (error) {
      console.error("Error getting lost item analytics:", error);
      return res.status(500).json({ message: "Failed to get analytics" });
    }
  });

  // Admin: Get all lost item analytics records
  app.get("/api/admin/lost-item-analytics/records", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const records = await storage.getAllLostItemAnalytics();
      return res.json(records);
    } catch (error) {
      console.error("Error getting analytics records:", error);
      return res.status(500).json({ message: "Failed to get records" });
    }
  });

  // =============================================
  // SAFE RETURN HUB SYSTEM
  // =============================================

  // Admin: Create a new Safe Return Hub
  app.post("/api/admin/safe-return-hubs", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { name, type, address, city, countryCode, latitude, longitude, operatingHoursStart, operatingHoursEnd, contactPerson, contactPhone, hasCctv, hubServiceFee, driverBonusReward } = req.body;
      if (!name || !address || !city) {
        return res.status(400).json({ message: "Name, address, and city are required" });
      }
      const hub = await storage.createSafeReturnHub({
        name, type: type || "partner_station", address, city,
        countryCode: countryCode || "NG",
        latitude: latitude || null, longitude: longitude || null,
        operatingHoursStart: operatingHoursStart || "08:00",
        operatingHoursEnd: operatingHoursEnd || "20:00",
        contactPerson: contactPerson || null, contactPhone: contactPhone || null,
        hasCctv: hasCctv || false, isActive: true,
        hubServiceFee: hubServiceFee || "0.00",
        driverBonusReward: driverBonusReward || "200.00",
        createdBy: adminId,
      });
      return res.status(201).json(hub);
    } catch (error) {
      console.error("Error creating safe return hub:", error);
      return res.status(500).json({ message: "Failed to create hub" });
    }
  });

  // Admin: Get all Safe Return Hubs
  app.get("/api/admin/safe-return-hubs", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const hubs = await storage.getAllSafeReturnHubs();
      return res.json(hubs);
    } catch (error) {
      console.error("Error getting safe return hubs:", error);
      return res.status(500).json({ message: "Failed to get hubs" });
    }
  });

  // Admin: Update a Safe Return Hub
  app.patch("/api/admin/safe-return-hubs/:id", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const hub = await storage.getSafeReturnHub(req.params.id);
      if (!hub) {
        return res.status(404).json({ message: "Hub not found" });
      }
      const updated = await storage.updateSafeReturnHub(req.params.id, req.body);
      return res.json(updated);
    } catch (error) {
      console.error("Error updating safe return hub:", error);
      return res.status(500).json({ message: "Failed to update hub" });
    }
  });

  // Admin: Delete a Safe Return Hub
  app.delete("/api/admin/safe-return-hubs/:id", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const deleted = await storage.deleteSafeReturnHub(req.params.id);
      if (!deleted) {
        return res.status(404).json({ message: "Hub not found" });
      }
      return res.json({ message: "Hub deleted successfully" });
    } catch (error) {
      console.error("Error deleting safe return hub:", error);
      return res.status(500).json({ message: "Failed to delete hub" });
    }
  });

  // Driver: Get active Safe Return Hubs (for selecting drop-off point)
  app.get("/api/safe-return-hubs", isAuthenticated, async (req, res) => {
    try {
      const { countryCode } = req.query;
      const hubs = await storage.getActiveSafeReturnHubs(countryCode as string | undefined);
      return res.json(hubs);
    } catch (error) {
      console.error("Error getting active hubs:", error);
      return res.status(500).json({ message: "Failed to get hubs" });
    }
  });

  // Driver: Select return method and hub for a lost item
  app.patch("/api/lost-items/:id/return-method", isAuthenticated, async (req, res) => {
    try {
      const driverId = req.user!.claims.sub;
      const { returnMethod, hubId, expectedDropOffTime } = req.body;
      if (!returnMethod || !["direct", "hub"].includes(returnMethod)) {
        return res.status(400).json({ message: "Return method must be 'direct' or 'hub'" });
      }
      const report = await storage.getLostItemReport(req.params.id);
      if (!report) {
        return res.status(404).json({ message: "Report not found" });
      }
      if (report.driverId !== driverId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      if (report.status !== "found") {
        return res.status(400).json({ message: "Item must be in 'found' status to select return method" });
      }
      const updateData: any = { returnMethod };
      if (returnMethod === "hub") {
        if (!hubId) {
          return res.status(400).json({ message: "Hub ID is required for hub return method" });
        }
        const hub = await storage.getSafeReturnHub(hubId);
        if (!hub || !hub.isActive) {
          return res.status(404).json({ message: "Hub not found or inactive" });
        }
        updateData.hubId = hubId;
        updateData.status = "en_route_to_hub";
        updateData.driverHubBonus = hub.driverBonusReward;
        updateData.hubServiceFee = hub.hubServiceFee;
        if (expectedDropOffTime) {
          updateData.expectedDropOffTime = new Date(expectedDropOffTime);
        }
        await storage.createLostItemMessage({
          lostItemReportId: req.params.id,
          senderId: "system",
          senderRole: "system",
          message: `Driver is delivering the item to Safe Return Hub: ${hub.name} (${hub.address}). You will be notified when the item arrives.`,
          isSystemMessage: true,
        });
        try {
          await storage.createNotification({
            userId: report.riderId,
            type: "safety",
            title: "Item Being Delivered to Hub",
            message: `Your lost item is being delivered to a Safe Return Hub. You'll be notified when it arrives.`,
          });
        } catch (notifErr) {
          console.error("Notification failed (non-blocking):", notifErr);
        }
      } else {
        updateData.status = "found";
        await storage.createLostItemMessage({
          lostItemReportId: req.params.id,
          senderId: "system",
          senderRole: "system",
          message: "Driver will return the item directly. Please coordinate via chat.",
          isSystemMessage: true,
        });
      }
      const updated = await storage.updateLostItemReport(req.params.id, updateData);
      return res.json(updated);
    } catch (error) {
      console.error("Error setting return method:", error);
      return res.status(500).json({ message: "Failed to set return method" });
    }
  });

  // Driver: Confirm drop-off at hub
  app.patch("/api/lost-items/:id/hub-dropoff", isAuthenticated, async (req, res) => {
    try {
      const driverId = req.user!.claims.sub;
      const { photoUrl } = req.body;
      const report = await storage.getLostItemReport(req.params.id);
      if (!report) {
        return res.status(404).json({ message: "Report not found" });
      }
      if (report.driverId !== driverId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      if (report.status !== "en_route_to_hub") {
        return res.status(400).json({ message: "Item must be en route to hub" });
      }
      const updateData: any = {
        status: "at_hub",
        hubConfirmedAt: new Date(),
      };
      if (photoUrl) {
        updateData.hubDropOffPhotoUrl = photoUrl;
      }
      const updated = await storage.updateLostItemReport(req.params.id, updateData);
      const hub = report.hubId ? await storage.getSafeReturnHub(report.hubId) : null;
      await storage.createLostItemMessage({
        lostItemReportId: req.params.id,
        senderId: "system",
        senderRole: "system",
        message: `Item has been dropped off at ${hub?.name || "the Safe Return Hub"}. ${hub ? `Address: ${hub.address}. Operating hours: ${hub.operatingHoursStart}-${hub.operatingHoursEnd}.` : ""} Please visit the hub to pick up your item.`,
        isSystemMessage: true,
      });
      try {
        await storage.createNotification({
          userId: report.riderId,
          type: "safety",
          title: "Item Ready for Pickup",
          message: `Your lost item has been dropped off at ${hub?.name || "a Safe Return Hub"}. Please visit the hub to pick it up.`,
        });
      } catch (notifErr) {
        console.error("Notification failed (non-blocking):", notifErr);
      }
      // Capture trust signal for hub drop-off
      try {
        const { captureBehaviorSignal } = await import("./trust-guards");
        await captureBehaviorSignal(driverId, "LOST_ITEM_HUB_DROPOFF", "driver", report.tripId, { lostItemId: req.params.id, hubId: report.hubId });
      } catch (signalErr) {
        console.error("Trust signal capture failed (non-blocking):", signalErr);
      }
      return res.json(updated);
    } catch (error) {
      console.error("Error confirming hub drop-off:", error);
      return res.status(500).json({ message: "Failed to confirm drop-off" });
    }
  });

  // Rider: Confirm pickup from hub
  app.patch("/api/lost-items/:id/hub-pickup", isAuthenticated, async (req, res) => {
    try {
      const riderId = req.user!.claims.sub;
      const report = await storage.getLostItemReport(req.params.id);
      if (!report) {
        return res.status(404).json({ message: "Report not found" });
      }
      if (report.riderId !== riderId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      if (report.status !== "at_hub") {
        return res.status(400).json({ message: "Item must be at the hub to confirm pickup" });
      }
      const updated = await storage.updateLostItemReport(req.params.id, {
        status: "returned",
        hubPickedUpAt: new Date(),
        returnCompletedAt: new Date(),
      });
      await storage.createLostItemMessage({
        lostItemReportId: req.params.id,
        senderId: "system",
        senderRole: "system",
        message: "Rider has picked up the item from the hub. Case resolved successfully.",
        isSystemMessage: true,
      });
      try {
        if (report.driverId) {
          await storage.createNotification({
            userId: report.driverId,
            type: "safety",
            title: "Item Pickup Confirmed",
            message: "The rider has picked up their item from the hub. Thank you for using the Safe Return Hub!",
          });
        }
      } catch (notifErr) {
        console.error("Notification failed (non-blocking):", notifErr);
      }
      // Apply driver bonus for hub usage
      if (report.driverId && report.driverHubBonus) {
        try {
          const bonus = parseFloat(report.driverHubBonus);
          if (bonus > 0) {
            const wallet = await storage.getWallet(report.driverId);
            if (wallet) {
              await storage.updateWallet(report.driverId, {
                balance: (parseFloat(wallet.balance || "0") + bonus).toFixed(2),
              });
              await storage.createLostItemMessage({
                lostItemReportId: req.params.id,
                senderId: "system",
                senderRole: "system",
                message: `Driver bonus of ${bonus.toFixed(2)} credited for using Safe Return Hub.`,
                isSystemMessage: true,
              });
            }
          }
        } catch (bonusErr) {
          console.error("Driver hub bonus failed (non-blocking):", bonusErr);
        }
      }
      // Log analytics
      try {
        const messages = await storage.getLostItemMessages(req.params.id);
        const riderReports = await storage.getLostItemReportsByRider(report.riderId);
        const driverReports = report.driverId ? await storage.getLostItemReportsByDriver(report.driverId) : [];
        const driverReturns = driverReports.filter(r => r.status === "returned").length;
        const createdAt = new Date(report.createdAt);
        const resolutionHours = (Date.now() - createdAt.getTime()) / (1000 * 60 * 60);
        await storage.createLostItemAnalytics({
          lostItemReportId: req.params.id,
          riderId: report.riderId,
          driverId: report.driverId || undefined,
          tripId: report.tripId,
          itemCategory: report.itemType,
          outcome: "returned_via_hub",
          reportToResolutionHours: resolutionHours.toFixed(2),
          returnFeeApplied: report.returnFeeAmount || undefined,
          driverEarnings: report.driverHubBonus || undefined,
          riderLostItemCount: riderReports.length,
          driverReturnCount: driverReturns,
          chatMessageCount: messages.filter(m => !m.isSystemMessage).length,
        });
      } catch (analyticsErr) {
        console.error("Analytics logging failed (non-blocking):", analyticsErr);
      }
      // Trust signal
      try {
        const { captureBehaviorSignal } = await import("./trust-guards");
        await captureBehaviorSignal(report.riderId, "LOST_ITEM_RESOLVED", "rider", report.tripId, { lostItemId: req.params.id, viaHub: true });
      } catch (signalErr) {
        console.error("Trust signal capture failed (non-blocking):", signalErr);
      }
      return res.json(updated);
    } catch (error) {
      console.error("Error confirming hub pickup:", error);
      return res.status(500).json({ message: "Failed to confirm pickup" });
    }
  });

  // =============================================
  // ACCIDENT REPORTS
  // =============================================

  // Report an accident
  app.post("/api/accident-reports", isAuthenticated, async (req, res) => {
    try {
      const reportedBy = req.user!.claims.sub;
      const { 
        tripId, incidentId, reporterRole, accidentType, severity,
        description, isSafe, injuriesReported, emergencyServicesNeeded,
        emergencyServicesContacted, gpsLat, gpsLng, photoUrls,
        voiceNoteUrl, vehicleDamageDescription
      } = req.body;

      if (!tripId || !description || !accidentType) {
        return res.status(400).json({ message: "Trip ID, description, and accident type are required" });
      }

      const report = await storage.createAccidentReport({
        tripId,
        incidentId: incidentId || "",
        reporterId: reportedBy,
        reporterRole: reporterRole || "rider",
        accidentSeverity: severity || accidentType || "minor",
        isSafe: isSafe !== undefined ? isSafe : true,
        emergencyServicesNeeded: emergencyServicesNeeded || false,
        emergencyServicesContacted: emergencyServicesContacted || false,
        photoEvidence: photoUrls || null,
        voiceNoteUrl: voiceNoteUrl || null,
        gpsLatitude: gpsLat || null,
        gpsLongitude: gpsLng || null,
        adminReviewStatus: "pending",
      });

      // Capture trust signals for accident reporting and safety cooperation
      try {
        const { captureBehaviorSignal } = await import("./trust-guards");
        const role = reporterRole || "rider";
        const signalCategory = role === "driver" ? "driver" : "rider";

        // Reward filing an accident report (transparency)
        if (signalCategory === "rider") {
          await captureBehaviorSignal(reportedBy, "ACCIDENT_REPORT_FILED", "rider", tripId, { accidentReportId: report.id });
        }

        // Safety check: isSafe response and emergency services cooperation
        if (isSafe === true) {
          if (signalCategory === "driver") {
            await captureBehaviorSignal(reportedBy, "ACCIDENT_SAFETY_CHECK_PASSED", "driver", tripId, { accidentReportId: report.id });
          } else {
            await captureBehaviorSignal(reportedBy, "ACCIDENT_SAFETY_COOPERATION", "rider", tripId, { accidentReportId: report.id });
          }
        }
      } catch (signalErr) {
        console.error("Trust signal capture failed (non-blocking):", signalErr);
      }

      return res.status(201).json(report);
    } catch (error) {
      console.error("Error creating accident report:", error);
      return res.status(500).json({ message: "Failed to create report" });
    }
  });

  // Get my accident reports
  app.get("/api/accident-reports/my-reports", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const allReports = await storage.getAllAccidentReports();
      const myReports = allReports.filter(r => r.reporterId === userId);
      return res.json(myReports);
    } catch (error) {
      console.error("Error getting accident reports:", error);
      return res.status(500).json({ message: "Failed to get reports" });
    }
  });

  // Get single accident report
  app.get("/api/accident-reports/:id", isAuthenticated, async (req, res) => {
    try {
      const report = await storage.getAccidentReport(req.params.id);
      if (!report) {
        return res.status(404).json({ message: "Report not found" });
      }
      return res.json(report);
    } catch (error) {
      console.error("Error getting accident report:", error);
      return res.status(500).json({ message: "Failed to get report" });
    }
  });

  // Admin: Get all accident reports
  app.get("/api/admin/accident-reports", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const { status } = req.query;
      const reports = status
        ? await storage.getAccidentReportsByStatus(status as string)
        : await storage.getAllAccidentReports();
      return res.json(reports);
    } catch (error) {
      console.error("Error getting accident reports:", error);
      return res.status(500).json({ message: "Failed to get reports" });
    }
  });

  // Admin: Review accident report
  app.patch("/api/admin/accident-reports/:id/review", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { adminReviewStatus, adminNotes, insuranceClaimRef } = req.body;

      if (!adminReviewStatus) {
        return res.status(400).json({ message: "Review status is required" });
      }

      const updated = await storage.updateAccidentReport(req.params.id, {
        adminReviewStatus,
        adminNotes: adminNotes || null,
        insuranceClaimRef: insuranceClaimRef || null,
        reviewedBy: adminId,
        reviewedAt: new Date(),
      });

      if (!updated) {
        return res.status(404).json({ message: "Report not found" });
      }

      return res.json(updated);
    } catch (error) {
      console.error("Error reviewing accident report:", error);
      return res.status(500).json({ message: "Failed to review report" });
    }
  });

  // =============================================
  // INSURANCE PARTNERS
  // =============================================

  // Admin: Get all insurance partners
  app.get("/api/admin/insurance-partners", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const partners = await storage.getAllInsurancePartners();
      return res.json(partners);
    } catch (error) {
      console.error("Error getting insurance partners:", error);
      return res.status(500).json({ message: "Failed to get insurance partners" });
    }
  });

  // Admin: Get active insurance partners
  app.get("/api/insurance-partners/active", isAuthenticated, async (req, res) => {
    try {
      const partners = await storage.getActiveInsurancePartners();
      return res.json(partners);
    } catch (error) {
      console.error("Error getting active insurance partners:", error);
      return res.status(500).json({ message: "Failed to get partners" });
    }
  });

  // Admin: Create insurance partner
  app.post("/api/admin/insurance-partners", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const { companyName, coverageType, contactEmail, contactPhone, claimUrl, apiEndpoint, activeRegions, notes } = req.body;
      if (!companyName || !coverageType) {
        return res.status(400).json({ message: "Company name and coverage type are required" });
      }
      const partner = await storage.createInsurancePartner({
        companyName,
        coverageType,
        contactEmail: contactEmail || null,
        contactPhone: contactPhone || null,
        claimUrl: claimUrl || null,
        apiEndpoint: apiEndpoint || null,
        activeRegions: activeRegions || null,
        notes: notes || null,
        isActive: true,
      });
      return res.status(201).json(partner);
    } catch (error) {
      console.error("Error creating insurance partner:", error);
      return res.status(500).json({ message: "Failed to create partner" });
    }
  });

  // Admin: Update insurance partner
  app.patch("/api/admin/insurance-partners/:id", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const updated = await storage.updateInsurancePartner(req.params.id, { ...req.body, updatedAt: new Date() });
      if (!updated) return res.status(404).json({ message: "Partner not found" });
      return res.json(updated);
    } catch (error) {
      console.error("Error updating insurance partner:", error);
      return res.status(500).json({ message: "Failed to update partner" });
    }
  });

  // Get insurance referrals for an accident report
  app.get("/api/insurance-referrals/:accidentReportId", isAuthenticated, async (req, res) => {
    try {
      const referrals = await storage.getInsuranceReferralsByAccident(req.params.accidentReportId);
      return res.json(referrals);
    } catch (error) {
      console.error("Error getting insurance referrals:", error);
      return res.status(500).json({ message: "Failed to get referrals" });
    }
  });

  // User opt-in to insurance referral
  app.post("/api/insurance-referrals", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const { accidentReportId, insurancePartnerId, referredUserRole } = req.body;
      if (!accidentReportId || !insurancePartnerId) {
        return res.status(400).json({ message: "Accident report ID and insurance partner ID are required" });
      }
      const referral = await storage.createInsuranceReferral({
        accidentReportId,
        insurancePartnerId,
        referredBy: userId,
        referredUserId: userId,
        referredUserRole: referredUserRole || "rider",
        status: "referred",
        userOptedIn: true,
      });
      return res.status(201).json(referral);
    } catch (error) {
      console.error("Error creating insurance referral:", error);
      return res.status(500).json({ message: "Failed to create referral" });
    }
  });

  // =============================================
  // DRIVER RELIEF FUND
  // =============================================

  // Admin: Get relief fund config
  app.get("/api/admin/relief-fund/config", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const config = await storage.getReliefFundConfig();
      return res.json(config || { totalPool: "0.00", cancellationFeePercent: 10, lostItemFeePercent: 5, currency: "NGN", isActive: true, minTrustScoreRequired: 50, maxPayoutPerClaim: "50000.00" });
    } catch (error) {
      console.error("Error getting relief fund config:", error);
      return res.status(500).json({ message: "Failed to get config" });
    }
  });

  // Admin: Update relief fund config
  app.post("/api/admin/relief-fund/config", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const config = await storage.upsertReliefFundConfig({ ...req.body, updatedBy: adminId });
      return res.json(config);
    } catch (error) {
      console.error("Error updating relief fund config:", error);
      return res.status(500).json({ message: "Failed to update config" });
    }
  });

  // Admin: Add manual contribution to relief fund
  app.post("/api/admin/relief-fund/contribute", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { amount, notes, currency } = req.body;
      if (!amount) return res.status(400).json({ message: "Amount is required" });
      const contribution = await storage.createReliefFundContribution({
        source: "admin_topup",
        amount,
        currency: currency || "NGN",
        contributedBy: adminId,
        notes: notes || null,
      });
      const config = await storage.getReliefFundConfig();
      if (config) {
        const newPool = (parseFloat(config.totalPool || "0") + parseFloat(amount)).toFixed(2);
        await storage.upsertReliefFundConfig({ ...config, totalPool: newPool, updatedBy: adminId });
      }
      return res.status(201).json(contribution);
    } catch (error) {
      console.error("Error contributing to relief fund:", error);
      return res.status(500).json({ message: "Failed to contribute" });
    }
  });

  // Admin: Get all contributions
  app.get("/api/admin/relief-fund/contributions", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const contributions = await storage.getAllReliefFundContributions();
      return res.json(contributions);
    } catch (error) {
      console.error("Error getting contributions:", error);
      return res.status(500).json({ message: "Failed to get contributions" });
    }
  });

  // Admin: Get all relief fund claims
  app.get("/api/admin/relief-fund/claims", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const { status } = req.query;
      const claims = status
        ? await storage.getReliefFundClaimsByStatus(status as string)
        : await storage.getAllReliefFundClaims();
      return res.json(claims);
    } catch (error) {
      console.error("Error getting relief fund claims:", error);
      return res.status(500).json({ message: "Failed to get claims" });
    }
  });

  // Admin: Review relief fund claim
  app.patch("/api/admin/relief-fund/claims/:id", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { status, approvedAmount, reviewNotes, expectedPayoutDate, faultDetermination } = req.body;
      const updated = await storage.updateReliefFundClaim(req.params.id, {
        status,
        approvedAmount: approvedAmount || null,
        reviewedBy: adminId,
        reviewNotes: reviewNotes || null,
        expectedPayoutDate: expectedPayoutDate ? new Date(expectedPayoutDate) : null,
        faultDetermination: faultDetermination || null,
        updatedAt: new Date(),
      });
      if (!updated) return res.status(404).json({ message: "Claim not found" });
      return res.json(updated);
    } catch (error) {
      console.error("Error reviewing relief fund claim:", error);
      return res.status(500).json({ message: "Failed to review claim" });
    }
  });

  // Driver: Get my relief fund claims
  app.get("/api/relief-fund/my-claims", isAuthenticated, async (req, res) => {
    try {
      const driverId = req.user!.claims.sub;
      const claims = await storage.getReliefFundClaimsByDriver(driverId);
      return res.json(claims);
    } catch (error) {
      console.error("Error getting driver relief claims:", error);
      return res.status(500).json({ message: "Failed to get claims" });
    }
  });

  // Driver: Submit relief fund claim
  app.post("/api/relief-fund/claims", isAuthenticated, async (req, res) => {
    try {
      const driverId = req.user!.claims.sub;
      const { accidentReportId, requestedAmount } = req.body;
      if (!accidentReportId || !requestedAmount) {
        return res.status(400).json({ message: "Accident report ID and requested amount are required" });
      }
      const trustProfile = await storage.getUserTrustProfile(driverId);
      const claim = await storage.createReliefFundClaim({
        driverId,
        accidentReportId,
        requestedAmount,
        status: "pending",
        driverTrustScoreAtTime: trustProfile?.trustScore || 75,
      });
      return res.status(201).json(claim);
    } catch (error) {
      console.error("Error submitting relief fund claim:", error);
      return res.status(500).json({ message: "Failed to submit claim" });
    }
  });

  // =============================================
  // LOST ITEM FRAUD DETECTION
  // =============================================

  // Admin: Get all fraud signals
  app.get("/api/admin/lost-item-fraud", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const signals = await storage.getAllLostItemFraudSignals();
      return res.json(signals);
    } catch (error) {
      console.error("Error getting fraud signals:", error);
      return res.status(500).json({ message: "Failed to get fraud signals" });
    }
  });

  // Admin: Get fraud signals for a user
  app.get("/api/admin/lost-item-fraud/user/:userId", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const signals = await storage.getLostItemFraudSignalsByUser(req.params.userId);
      const riskScore = await storage.getUserLostItemRiskScore(req.params.userId);
      return res.json({ signals, riskScore });
    } catch (error) {
      console.error("Error getting user fraud signals:", error);
      return res.status(500).json({ message: "Failed to get fraud signals" });
    }
  });

  // Admin: Review fraud signal
  app.patch("/api/admin/lost-item-fraud/:id", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { adminNotes, autoResolved } = req.body;
      const updated = await storage.updateLostItemFraudSignal(req.params.id, {
        adminReviewed: true,
        adminReviewedBy: adminId,
        adminNotes: adminNotes || null,
        autoResolved: autoResolved || false,
      });
      if (!updated) return res.status(404).json({ message: "Signal not found" });
      return res.json(updated);
    } catch (error) {
      console.error("Error reviewing fraud signal:", error);
      return res.status(500).json({ message: "Failed to review signal" });
    }
  });

  // =============================================
  // PHASE 5: DISPUTES, REFUNDS & LEGAL RESOLUTION
  // =============================================

  // Check dispute eligibility for a trip
  app.get("/api/disputes/eligibility/:tripId", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const role = await storage.getUserRole(userId);
      const initiatorRole = role?.role === "driver" ? "DRIVER" : "RIDER";

      const { checkDisputeEligibility } = await import("./dispute-guards");
      const result = await checkDisputeEligibility(req.params.tripId, userId, initiatorRole);

      return res.json(result);
    } catch (error) {
      console.error("Error checking dispute eligibility:", error);
      return res.status(500).json({ message: "Failed to check eligibility" });
    }
  });

  // File a dispute
  app.post("/api/disputes", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const { tripId, accusedUserId, disputeType, description, evidenceMetadata } = req.body;

      if (!tripId || !accusedUserId || !disputeType || !description) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      const role = await storage.getUserRole(userId);
      const initiatorRole = role?.role === "driver" ? "DRIVER" : "RIDER";

      const { createDispute } = await import("./dispute-guards");
      const result = await createDispute(
        tripId,
        userId,
        initiatorRole,
        accusedUserId,
        disputeType,
        description,
        evidenceMetadata
      );

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({
        success: true,
        disputeId: result.disputeId,
        autoFlagged: result.autoFlagged,
        message: "Dispute filed successfully",
      });
    } catch (error) {
      console.error("Error creating dispute:", error);
      return res.status(500).json({ message: "Failed to file dispute" });
    }
  });

  // Get my disputes (as initiator)
  app.get("/api/disputes/my", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const disputes = await storage.getPhase5DisputesByUser(userId);
      return res.json(disputes);
    } catch (error) {
      console.error("Error getting disputes:", error);
      return res.status(500).json({ message: "Failed to get disputes" });
    }
  });

  // Get disputes against me
  app.get("/api/disputes/against-me", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const disputes = await storage.getPhase5DisputesByAccused(userId);
      return res.json(disputes);
    } catch (error) {
      console.error("Error getting disputes:", error);
      return res.status(500).json({ message: "Failed to get disputes" });
    }
  });

  // Get dispute details
  app.get("/api/disputes/:disputeId", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const dispute = await storage.getPhase5Dispute(req.params.disputeId);

      if (!dispute) {
        return res.status(404).json({ message: "Dispute not found" });
      }

      const isParty = dispute.initiatorUserId === userId || dispute.accusedUserId === userId;
      const role = await storage.getUserRole(userId);
      const isAdmin = role?.role === "admin" || role?.role === "super_admin";

      if (!isParty && !isAdmin) {
        return res.status(403).json({ message: "Not authorized to view this dispute" });
      }

      return res.json(dispute);
    } catch (error) {
      console.error("Error getting dispute:", error);
      return res.status(500).json({ message: "Failed to get dispute" });
    }
  });

  // Get disputes for a trip
  app.get("/api/disputes/trip/:tripId", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const trip = await storage.getTripById(req.params.tripId);

      if (!trip) {
        return res.status(404).json({ message: "Trip not found" });
      }

      const isParty = trip.riderId === userId || trip.driverId === userId;
      const role = await storage.getUserRole(userId);
      const isAdmin = role?.role === "admin" || role?.role === "super_admin";

      if (!isParty && !isAdmin) {
        return res.status(403).json({ message: "Not authorized" });
      }

      const disputes = await storage.getPhase5DisputesByTrip(req.params.tripId);
      return res.json(disputes);
    } catch (error) {
      console.error("Error getting trip disputes:", error);
      return res.status(500).json({ message: "Failed to get disputes" });
    }
  });

  // Admin: Get open dispute queue
  app.get("/api/admin/disputes/queue", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const { getDisputeQueue } = await import("./dispute-guards");
      const disputes = await getDisputeQueue();
      return res.json(disputes);
    } catch (error) {
      console.error("Error getting dispute queue:", error);
      return res.status(500).json({ message: "Failed to get dispute queue" });
    }
  });

  // Admin: Get disputes by status
  app.get("/api/admin/disputes/status/:status", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const disputes = await storage.getPhase5DisputesByStatus(req.params.status);
      return res.json(disputes);
    } catch (error) {
      console.error("Error getting disputes by status:", error);
      return res.status(500).json({ message: "Failed to get disputes" });
    }
  });

  // Admin: Review a dispute (assign to self)
  app.post("/api/admin/disputes/:disputeId/review", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;

      const { adminReviewDispute } = await import("./dispute-guards");
      const result = await adminReviewDispute(req.params.disputeId, adminId);

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true, message: "Dispute is now under review" });
    } catch (error) {
      console.error("Error reviewing dispute:", error);
      return res.status(500).json({ message: "Failed to review dispute" });
    }
  });

  // Admin: Approve a dispute
  app.post("/api/admin/disputes/:disputeId/approve", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { notes, refundType, refundAmount } = req.body;

      if (!notes) {
        return res.status(400).json({ message: "Admin notes required" });
      }

      const { adminApproveDispute } = await import("./dispute-guards");
      const result = await adminApproveDispute(req.params.disputeId, adminId, notes, refundType, refundAmount);

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true, message: "Dispute resolved" });
    } catch (error) {
      console.error("Error approving dispute:", error);
      return res.status(500).json({ message: "Failed to approve dispute" });
    }
  });

  // Admin: Reject a dispute
  app.post("/api/admin/disputes/:disputeId/reject", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { reason } = req.body;

      if (!reason) {
        return res.status(400).json({ message: "Rejection reason required" });
      }

      const { adminRejectDispute } = await import("./dispute-guards");
      const result = await adminRejectDispute(req.params.disputeId, adminId, reason);

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true, message: "Dispute rejected" });
    } catch (error) {
      console.error("Error rejecting dispute:", error);
      return res.status(500).json({ message: "Failed to reject dispute" });
    }
  });

  // Admin: Escalate a dispute to safety incident
  app.post("/api/admin/disputes/:disputeId/escalate", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { reason } = req.body;

      if (!reason) {
        return res.status(400).json({ message: "Escalation reason required" });
      }

      const { adminEscalateDispute } = await import("./dispute-guards");
      const result = await adminEscalateDispute(req.params.disputeId, adminId, reason);

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true, message: "Dispute escalated to safety incident" });
    } catch (error) {
      console.error("Error escalating dispute:", error);
      return res.status(500).json({ message: "Failed to escalate dispute" });
    }
  });

  // Admin: Report a chargeback
  app.post("/api/admin/disputes/chargeback", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { userId, chargebackId } = req.body;

      if (!userId || !chargebackId) {
        return res.status(400).json({ message: "User ID and chargeback ID required" });
      }

      const { reportChargeback } = await import("./dispute-guards");
      const result = await reportChargeback(userId, chargebackId, adminId);

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true, message: "Chargeback reported" });
    } catch (error) {
      console.error("Error reporting chargeback:", error);
      return res.status(500).json({ message: "Failed to report chargeback" });
    }
  });

  // Admin: Get user dispute profile
  app.get("/api/admin/disputes/user/:userId", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const { getUserDisputeProfile } = await import("./dispute-guards");
      const profile = await getUserDisputeProfile(req.params.userId);
      return res.json(profile);
    } catch (error) {
      console.error("Error getting user dispute profile:", error);
      return res.status(500).json({ message: "Failed to get user dispute profile" });
    }
  });

  // Admin: Get dispute audit logs
  app.get("/api/admin/disputes/audit-logs", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const { getDisputeAuditLogs } = await import("./dispute-guards");
      const logs = await getDisputeAuditLogs();
      return res.json(logs);
    } catch (error) {
      console.error("Error getting dispute audit logs:", error);
      return res.status(500).json({ message: "Failed to get audit logs" });
    }
  });

  // Admin: Get dispute audit logs for specific dispute
  app.get("/api/admin/disputes/:disputeId/audit-logs", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const logs = await storage.getDisputeAuditLogsForDispute(req.params.disputeId);
      return res.json(logs);
    } catch (error) {
      console.error("Error getting dispute audit logs:", error);
      return res.status(500).json({ message: "Failed to get audit logs" });
    }
  });

  // Admin: Get refunds for a dispute
  app.get("/api/admin/disputes/:disputeId/refunds", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const refunds = await storage.getPhase5RefundsByDispute(req.params.disputeId);
      return res.json(refunds);
    } catch (error) {
      console.error("Error getting refunds:", error);
      return res.status(500).json({ message: "Failed to get refunds" });
    }
  });

  // Admin: Process a pending refund
  app.post("/api/admin/disputes/refund/:refundId/process", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;

      const refund = await storage.getPhase5RefundOutcome(req.params.refundId);
      if (!refund) {
        return res.status(404).json({ message: "Refund not found" });
      }

      await storage.updatePhase5RefundStatus(req.params.refundId, "APPROVED", adminId);

      const { processRefund } = await import("./dispute-guards");
      const result = await processRefund(req.params.refundId, adminId);

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true, message: "Refund processed" });
    } catch (error) {
      console.error("Error processing refund:", error);
      return res.status(500).json({ message: "Failed to process refund" });
    }
  });

  // Check if user is locked for chargebacks
  app.get("/api/disputes/chargeback-status", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const isLocked = await storage.isUserLockedForChargebacks(userId);
      return res.json({ isLocked });
    } catch (error) {
      console.error("Error checking chargeback status:", error);
      return res.status(500).json({ message: "Failed to check status" });
    }
  });

  // =============================================
  // COMPLIANCE & STORE READINESS ENDPOINTS
  // =============================================

  // Public: Get active legal documents (pre-signup accessible)
  app.get("/api/legal", async (req, res) => {
    try {
      const docs = await storage.getActiveLegalDocuments();
      return res.json(docs);
    } catch (error) {
      console.error("Error getting legal documents:", error);
      return res.status(500).json({ message: "Failed to get legal documents" });
    }
  });

  // Public: Get specific legal document by type
  app.get("/api/legal/:documentType", async (req, res) => {
    try {
      const doc = await storage.getActiveLegalDocumentByType(req.params.documentType);
      if (!doc) {
        return res.status(404).json({ message: "Document not found" });
      }
      return res.json(doc);
    } catch (error) {
      console.error("Error getting legal document:", error);
      return res.status(500).json({ message: "Failed to get legal document" });
    }
  });

  // User: Get my consents
  app.get("/api/consents/my", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const consents = await storage.getUserConsents(userId);
      return res.json(consents);
    } catch (error) {
      console.error("Error getting consents:", error);
      return res.status(500).json({ message: "Failed to get consents" });
    }
  });

  // User: Check required consents status
  app.get("/api/consents/status", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const role = await storage.getUserRole(userId);
      const { checkRequiredConsents } = await import("./compliance-guards");
      const status = await checkRequiredConsents(userId, role?.role || "rider");
      return res.json(status);
    } catch (error) {
      console.error("Error checking consent status:", error);
      return res.status(500).json({ message: "Failed to check consent status" });
    }
  });

  // User: Grant consent
  app.post("/api/consents/grant", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const { consentType } = req.body;
      const ipAddress = req.ip;
      const userAgent = req.get("User-Agent");

      if (!consentType) {
        return res.status(400).json({ message: "Consent type is required" });
      }

      const { grantConsent } = await import("./compliance-guards");
      const result = await grantConsent(userId, consentType, ipAddress, userAgent);

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true, consentId: result.consentId });
    } catch (error) {
      console.error("Error granting consent:", error);
      return res.status(500).json({ message: "Failed to grant consent" });
    }
  });

  // User: Grant all required consents
  app.post("/api/consents/grant-all", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const ipAddress = req.ip;
      const userAgent = req.get("User-Agent");
      const role = await storage.getUserRole(userId);

      const { grantAllRequiredConsents } = await import("./compliance-guards");
      const result = await grantAllRequiredConsents(userId, role?.role || "rider", ipAddress, userAgent);

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true, message: "All required consents granted" });
    } catch (error) {
      console.error("Error granting all consents:", error);
      return res.status(500).json({ message: "Failed to grant consents" });
    }
  });

  // User: Revoke consent
  app.post("/api/consents/revoke", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const { consentType } = req.body;
      const ipAddress = req.ip;

      if (!consentType) {
        return res.status(400).json({ message: "Consent type is required" });
      }

      const { revokeConsent } = await import("./compliance-guards");
      const result = await revokeConsent(userId, consentType, ipAddress);

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true, message: "Consent revoked" });
    } catch (error) {
      console.error("Error revoking consent:", error);
      return res.status(500).json({ message: "Failed to revoke consent" });
    }
  });

  // User: Confirm first use compliance
  app.post("/api/compliance/first-use", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const ipAddress = req.ip;
      const { deviceInfo } = req.body;

      const { confirmFirstUseCompliance } = await import("./compliance-guards");
      const result = await confirmFirstUseCompliance(userId, ipAddress, deviceInfo);

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true, message: "First use confirmed" });
    } catch (error) {
      console.error("Error confirming first use:", error);
      return res.status(500).json({ message: "Failed to confirm first use" });
    }
  });

  // Public: Get store metadata (for app store submission)
  app.get("/api/compliance/store-metadata", async (req, res) => {
    try {
      const { getStoreMetadata } = await import("./compliance-guards");
      return res.json(getStoreMetadata());
    } catch (error) {
      console.error("Error getting store metadata:", error);
      return res.status(500).json({ message: "Failed to get store metadata" });
    }
  });

  // Public: Get readiness summary
  app.get("/api/compliance/readiness", async (req, res) => {
    try {
      const { getFullReadinessSummary } = await import("./compliance-guards");
      return res.json(getFullReadinessSummary());
    } catch (error) {
      console.error("Error getting readiness summary:", error);
      return res.status(500).json({ message: "Failed to get readiness summary" });
    }
  });

  // SUPER_ADMIN: Get full system readiness report
  app.get("/api/admin/compliance/readiness-report", isAuthenticated, requireRole(["super_admin"]), async (req, res) => {
    try {
      const { getSystemReadinessReport } = await import("./compliance-guards");
      const report = await getSystemReadinessReport();
      return res.json(report);
    } catch (error) {
      console.error("Error getting readiness report:", error);
      return res.status(500).json({ message: "Failed to get readiness report" });
    }
  });

  // SUPER_ADMIN: Toggle launch mode
  app.post("/api/admin/compliance/launch-mode", isAuthenticated, requireRole(["super_admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { mode, value } = req.body;

      if (!mode || typeof value !== "boolean") {
        return res.status(400).json({ message: "Mode and boolean value are required" });
      }

      const { toggleLaunchMode } = await import("./compliance-guards");
      const result = await toggleLaunchMode(mode, value, adminId);

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true, message: `${mode} set to ${value}` });
    } catch (error) {
      console.error("Error toggling launch mode:", error);
      return res.status(500).json({ message: "Failed to toggle launch mode" });
    }
  });

  // SUPER_ADMIN: Get all kill switch states
  app.get("/api/admin/compliance/kill-switches", isAuthenticated, requireRole(["super_admin"]), async (req, res) => {
    try {
      const states = await storage.getAllKillSwitchStates();
      return res.json(states);
    } catch (error) {
      console.error("Error getting kill switch states:", error);
      return res.status(500).json({ message: "Failed to get kill switch states" });
    }
  });

  // SUPER_ADMIN: Activate kill switch
  app.post("/api/admin/compliance/kill-switch/activate", isAuthenticated, requireRole(["super_admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { switchName, reason } = req.body;

      if (!switchName || !reason) {
        return res.status(400).json({ message: "Switch name and reason are required" });
      }

      const { activateKillSwitch } = await import("./compliance-guards");
      const result = await activateKillSwitch(switchName, reason, adminId);

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true, message: `Kill switch ${switchName} activated` });
    } catch (error) {
      console.error("Error activating kill switch:", error);
      return res.status(500).json({ message: "Failed to activate kill switch" });
    }
  });

  // SUPER_ADMIN: Deactivate kill switch
  app.post("/api/admin/compliance/kill-switch/deactivate", isAuthenticated, requireRole(["super_admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { switchName } = req.body;

      if (!switchName) {
        return res.status(400).json({ message: "Switch name is required" });
      }

      const { deactivateKillSwitch } = await import("./compliance-guards");
      const result = await deactivateKillSwitch(switchName, adminId);

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true, message: `Kill switch ${switchName} deactivated` });
    } catch (error) {
      console.error("Error deactivating kill switch:", error);
      return res.status(500).json({ message: "Failed to deactivate kill switch" });
    }
  });

  // SUPER_ADMIN: Get all test users
  app.get("/api/admin/compliance/test-users", isAuthenticated, requireRole(["super_admin"]), async (req, res) => {
    try {
      const testUsers = await storage.getAllTestUsers();
      return res.json(testUsers);
    } catch (error) {
      console.error("Error getting test users:", error);
      return res.status(500).json({ message: "Failed to get test users" });
    }
  });

  // SUPER_ADMIN: Mark user as test user
  app.post("/api/admin/compliance/test-user/mark", isAuthenticated, requireRole(["super_admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { userId } = req.body;

      if (!userId) {
        return res.status(400).json({ message: "User ID is required" });
      }

      const { markAsTestUser } = await import("./compliance-guards");
      const result = await markAsTestUser(userId, adminId);

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true, message: "User marked as test user" });
    } catch (error) {
      console.error("Error marking test user:", error);
      return res.status(500).json({ message: "Failed to mark test user" });
    }
  });

  // SUPER_ADMIN: Unmark user as test user
  app.post("/api/admin/compliance/test-user/unmark", isAuthenticated, requireRole(["super_admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { userId } = req.body;

      if (!userId) {
        return res.status(400).json({ message: "User ID is required" });
      }

      const { unmarkAsTestUser } = await import("./compliance-guards");
      const result = await unmarkAsTestUser(userId, adminId);

      if (!result.success) {
        return res.status(400).json({ message: result.error });
      }

      return res.json({ success: true, message: "User unmarked as test user" });
    } catch (error) {
      console.error("Error unmarking test user:", error);
      return res.status(500).json({ message: "Failed to unmark test user" });
    }
  });

  // SUPER_ADMIN: Get compliance audit logs
  app.get("/api/admin/compliance/audit-logs", isAuthenticated, requireRole(["super_admin", "admin"]), async (req, res) => {
    try {
      const { category, limit } = req.query;
      const { getComplianceAuditLogsForExport } = await import("./compliance-guards");
      const logs = await getComplianceAuditLogsForExport({
        category: category as string | undefined,
        limit: limit ? parseInt(limit as string) : undefined,
      });
      return res.json(logs);
    } catch (error) {
      console.error("Error getting compliance audit logs:", error);
      return res.status(500).json({ message: "Failed to get audit logs" });
    }
  });

  // SUPER_ADMIN: Export audit logs (for regulators)
  app.get("/api/admin/compliance/audit-logs/export", isAuthenticated, requireRole(["super_admin"]), async (req, res) => {
    try {
      const { category, format } = req.query;
      const { getComplianceAuditLogsForExport } = await import("./compliance-guards");
      const logs = await getComplianceAuditLogsForExport({
        category: category as string | undefined,
      });

      if (format === "csv") {
        const headers = "ID,Category,User ID,Action By,Event Type,Created At\n";
        const rows = logs.map(l => 
          `${l.id},${l.category},${l.userId || ""},${l.actionBy || ""},${l.eventType},${l.createdAt}`
        ).join("\n");
        res.setHeader("Content-Type", "text/csv");
        res.setHeader("Content-Disposition", `attachment; filename="compliance_audit_${new Date().toISOString().split("T")[0]}.csv"`);
        return res.send(headers + rows);
      }

      return res.json({ data: logs, exportedAt: new Date().toISOString() });
    } catch (error) {
      console.error("Error exporting audit logs:", error);
      return res.status(500).json({ message: "Failed to export audit logs" });
    }
  });

  // SUPER_ADMIN: Create legal document
  app.post("/api/admin/compliance/legal-documents", isAuthenticated, requireRole(["super_admin"]), async (req, res) => {
    try {
      const adminId = req.user!.claims.sub;
      const { documentType, version, title, content, effectiveDate } = req.body;

      if (!documentType || !version || !title || !content || !effectiveDate) {
        return res.status(400).json({ message: "All fields are required" });
      }

      const doc = await storage.createLegalDocument({
        documentType,
        version,
        title,
        content,
        effectiveDate: new Date(effectiveDate),
        createdBy: adminId,
      });

      await storage.createComplianceAuditLog({
        category: "ADMIN_ACTION",
        actionBy: adminId,
        actionByRole: "super_admin",
        eventType: "LEGAL_DOCUMENT_CREATED",
        eventData: JSON.stringify({ documentType, version }),
      });

      return res.json({ success: true, document: doc });
    } catch (error) {
      console.error("Error creating legal document:", error);
      return res.status(500).json({ message: "Failed to create legal document" });
    }
  });

  // Legal acknowledgement logging
  app.post("/api/legal/acknowledge", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { acknowledgementType, countryCode, metadata } = req.body;
      if (!acknowledgementType) return res.status(400).json({ message: "acknowledgementType is required" });

      const result = await storage.logLegalAcknowledgement({
        userId,
        acknowledgementType,
        countryCode: countryCode || null,
        metadata: metadata ? JSON.stringify(metadata) : null,
        ipAddress: req.ip || null,
        userAgent: req.headers["user-agent"]?.substring(0, 500) || null,
      });
      res.json(result);
    } catch (error) {
      console.error("Error logging legal acknowledgement:", error);
      return res.status(500).json({ message: "Failed to log legal acknowledgement" });
    }
  });

  // Admin: view legal acknowledgements
  app.get("/api/admin/legal-acknowledgements", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const { userId, type } = req.query;
      const results = await storage.getLegalAcknowledgements(
        userId as string | undefined,
        type as string | undefined,
      );
      res.json(results);
    } catch (error) {
      console.error("Error fetching legal acknowledgements:", error);
      return res.status(500).json({ message: "Failed to fetch legal acknowledgements" });
    }
  });

  // Support interaction logging
  app.post("/api/support/log-interaction", async (req, res) => {
    try {
      const userId = req.isAuthenticated() ? (req.user as any).id || (req.user as any)?.claims?.sub : null;
      const { userMessage, supportResponse, userRole, currentScreen } = req.body;
      if (!userMessage || !supportResponse) return res.status(400).json({ message: "Missing required fields" });
      
      const templateMatch = matchTemplate(userMessage, userRole || "rider");

      await storage.logSupportInteraction({
        userId: userId || "anonymous",
        userRole: userRole || "unknown",
        currentScreen: currentScreen || null,
        userMessage: userMessage.substring(0, 1000),
        supportResponse: supportResponse.substring(0, 1000),
        matchedTemplateId: templateMatch?.id || null,
        matchedCategory: templateMatch?.category || null,
      });
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to log interaction" });
    }
  });

  // ==========================================
  // ZIBA SUPPORT CHAT (Phase 4 - ZIBRA)
  // ==========================================

  app.post("/api/support/chat", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ message: "Unauthorized" });
      }

      const { message, conversationId, currentScreen, userLanguage: rawUserLanguage } = req.body;
      const userLanguage = rawUserLanguage || "en";
      if (!message || typeof message !== "string") {
        return res.status(400).json({ message: "Message is required" });
      }

      // Check if conversation already escalated
      if (conversationId) {
        const isEscalated = await storage.isConversationEscalated(conversationId);
        if (isEscalated) {
          return res.json({
            response: "A support agent will review this as soon as possible.",
            conversationId,
            role: "rider",
            escalated: true,
          });
        }
      }

      const allRoles = await storage.getAllUserRoles(userId);
      const roleList = allRoles.map(r => r.role);
      let detectedRole = "rider";
      if (roleList.includes("super_admin")) detectedRole = "super_admin";
      else if (roleList.includes("admin")) detectedRole = "admin";
      else if (roleList.includes("director")) detectedRole = "director";
      else if (roleList.includes("driver")) detectedRole = "driver";
      else if (roleList.includes("rider")) detectedRole = "rider";

      const isPrivileged = detectedRole === "admin" || detectedRole === "super_admin" || detectedRole === "director";

      // Check if ZIBRA is enabled globally
      const zibraEnabled = await storage.getZibraConfig("zibra_enabled");
      if (zibraEnabled && zibraEnabled.value === "false") {
        return res.json({
          response: "Support is currently in maintenance mode. Please submit a support ticket through the Help Center for assistance.",
          conversationId,
          role: detectedRole,
        });
      }

      // Check if ZIBRA is enabled for this role
      const roleEnabled = await storage.getZibraConfig(`zibra_role_${detectedRole}_enabled`);
      if (roleEnabled && roleEnabled.value === "false") {
        return res.json({
          response: "Support is currently in maintenance mode. Please submit a support ticket through the Help Center for assistance.",
          conversationId,
          role: detectedRole,
        });
      }

      // Check safe mode - only allow FAQ responses
      const safeMode = await storage.getZibraConfig("zibra_safe_mode");

      // Check phrase blacklist
      const blacklistConfig = await storage.getZibraConfig("zibra_blacklist_phrases");
      const blacklistPhrases = blacklistConfig ? blacklistConfig.value.split(",").map((p: string) => p.trim().toLowerCase()) : [];

      // LEGAL RISK SCAN: Check for legal/safety risk keywords before generating response
      const legalScan = scanForLegalRisks(message);
      if (legalScan.level === "escalate" || legalScan.level === "monitor") {
        if (legalScan.shouldLog) {
          try {
            await storage.logSupportInteraction({
              userId: parseInt(userId),
              userMessage: message,
              supportResponse: legalScan.response,
              userRole: detectedRole,
              currentScreen: currentScreen || "unknown",
              escalated: legalScan.shouldNotifyAdmin,
              conversationId: conversationId || `conv-${Date.now()}`,
            });
          } catch {}
        }
        if (legalScan.level === "escalate") {
          let convId = conversationId;
          if (!convId) {
            const conv = await storage.createSupportConversation({
              userId,
              userRole: detectedRole,
              currentScreen: currentScreen || null,
            });
            convId = conv.id;
          }
          await storage.addSupportMessage(convId, "user", message);
          await storage.addSupportMessage(convId, "support", legalScan.response);
          return res.json({
            response: legalScan.response,
            conversationId: convId,
            escalated: legalScan.shouldNotifyAdmin,
          });
        }
      }

      let response = generateSupportResponse(message, detectedRole, isPrivileged);

      // In safe mode, restrict to FAQ-only responses
      if (safeMode && safeMode.value === "true") {
        const match = matchTemplate(message, detectedRole);
        if (!match || (match.priority !== undefined && match.priority < 70)) {
          response = "For detailed assistance, please submit a support ticket through the Help Center. A support agent will review your request.";
        }
      }

      // Filter blacklisted phrases
      if (blacklistPhrases.length > 0) {
        let filtered = response;
        for (const phrase of blacklistPhrases) {
          if (phrase && filtered.toLowerCase().includes(phrase)) {
            filtered = filtered.replace(new RegExp(phrase, "gi"), "[redacted]");
          }
        }
        response = filtered;
      }

      const languageToTone: Record<string, ToneStyle> = {
        "en": "neutral",
        "fr": "formal",
        "ar": "formal",
        "ha": "friendly",
        "ig": "friendly",
        "yo": "friendly",
        "sw": "neutral",
        "zu": "neutral",
        "xh": "neutral",
        "af": "neutral",
        "pt": "neutral",
        "es": "neutral",
      };
      const toneStyle = languageToTone[userLanguage] || "neutral";
      response = applyTone(response, toneStyle);

      let convId = conversationId;
      if (!convId) {
        const conv = await storage.createSupportConversation({
          userId,
          userRole: detectedRole,
          currentScreen: currentScreen || null,
        });
        convId = conv.id;
      }

      await storage.addSupportMessage(convId, "user", message);
      await storage.addSupportMessage(convId, "support", response);

      return res.json({
        response,
        conversationId: convId,
        role: detectedRole,
        userLanguage,
      });
    } catch (error) {
      console.error("Error in support chat:", error);
      return res.status(500).json({ message: "Support is temporarily unavailable. Please try again later." });
    }
  });

  // Admin: view support interactions
  app.get("/api/admin/support-interactions", isAuthenticated, async (req, res) => {
    try {
      const user = req.user as any;
      const roles = user.roles || [];
      if (!roles.includes("admin") && !roles.includes("super_admin")) {
        return res.status(403).json({ message: "Admin access required" });
      }
      const { userId, role } = req.query;
      const results = await storage.getSupportInteractions(
        userId as string | undefined,
        role as string | undefined,
      );
      res.json(results);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch interactions" });
    }
  });

  app.get("/api/admin/user-languages", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userRole = await storage.getUserRole(userId);
      if (!userRole || !["admin", "super_admin"].includes(userRole.role)) {
        return res.status(403).json({ message: "Admin access required" });
      }
      
      const result = await db.select({
        language: users.language,
        count: sql`count(*)::int`
      }).from(users).groupBy(users.language);
      
      res.json(result);
    } catch (error) {
      console.error("Error fetching user languages:", error);
      res.status(500).json({ message: "Failed to fetch language stats" });
    }
  });

  // ==========================================
  // ZIBRA INSIGHTS - Analytics (Phase G)
  // ==========================================

  app.get("/api/admin/zibra/analytics", isAuthenticated, async (req: any, res) => {
    try {
      const user = req.user as any;
      const roles = user.roles || [];
      if (!roles.includes("admin") && !roles.includes("super_admin")) {
        return res.status(403).json({ message: "Admin access required" });
      }
      const { startDate, endDate, role, country } = req.query;
      const analytics = await storage.getZibraAnalytics({
        startDate: startDate as string | undefined,
        endDate: endDate as string | undefined,
        role: role as string | undefined,
        country: country as string | undefined,
      });
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching ZIBRA analytics:", error);
      res.status(500).json({ message: "Failed to fetch analytics" });
    }
  });

  app.get("/api/admin/zibra/analytics/export", isAuthenticated, async (req: any, res) => {
    try {
      const user = req.user as any;
      const roles = user.roles || [];
      if (!roles.includes("admin") && !roles.includes("super_admin")) {
        return res.status(403).json({ message: "Admin access required" });
      }
      const { startDate, endDate, role, country } = req.query;
      const analytics = await storage.getZibraAnalytics({
        startDate: startDate as string | undefined,
        endDate: endDate as string | undefined,
        role: role as string | undefined,
        country: country as string | undefined,
      });
      
      const csvRows = [
        "Metric,Value",
        `Total Conversations,${analytics.totalConversations}`,
        `Escalated,${analytics.escalatedCount}`,
        `Resolved Without Human,${analytics.resolvedWithoutHumanCount}`,
        `Resolution Rate (%),${analytics.resolvedWithoutHumanPercent}`,
        `Abuse - Lost Items,${analytics.abuseFlags.lostItem}`,
        `Abuse - Payment Disputes,${analytics.abuseFlags.paymentDispute}`,
        `Abuse - Threats,${analytics.abuseFlags.threats}`,
        "",
        "Role,Conversations",
        ...Object.entries(analytics.conversationsByRole).map(([r, c]) => `${r},${c}`),
        "",
        "Category,Count",
        ...analytics.topCategories.map((c: any) => `${c.category},${c.count}`),
      ];
      
      res.setHeader("Content-Type", "text/csv");
      res.setHeader("Content-Disposition", "attachment; filename=zibra-analytics.csv");
      res.send(csvRows.join("\n"));
    } catch (error) {
      console.error("Error exporting ZIBRA analytics:", error);
      res.status(500).json({ message: "Failed to export analytics" });
    }
  });

  // ==========================================
  // ZIBRA GOVERNANCE - Controls (Phase H)
  // ==========================================

  app.get("/api/admin/zibra/config", isAuthenticated, async (req: any, res) => {
    try {
      const user = req.user as any;
      const roles = user.roles || [];
      if (!roles.includes("super_admin")) {
        return res.status(403).json({ message: "Super admin access required" });
      }
      const configs = await storage.getAllZibraConfigs();
      res.json(configs);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch ZIBRA config" });
    }
  });

  app.post("/api/admin/zibra/config", isAuthenticated, async (req: any, res) => {
    try {
      const user = req.user as any;
      const roles = user.roles || [];
      if (!roles.includes("super_admin")) {
        return res.status(403).json({ message: "Super admin access required" });
      }
      const userId = user.claims?.sub;
      const { key, value, description, reason } = req.body;
      if (!key || value === undefined) {
        return res.status(400).json({ message: "Key and value are required" });
      }

      const existing = await storage.getZibraConfig(key);
      const oldValue = existing?.value || null;

      const config = await storage.setZibraConfig(key, String(value), userId, description);

      await storage.logZibraConfigChange({
        configKey: key,
        oldValue,
        newValue: String(value),
        changedBy: userId,
        reason: reason || null,
      });

      res.json(config);
    } catch (error) {
      console.error("Error updating ZIBRA config:", error);
      res.status(500).json({ message: "Failed to update config" });
    }
  });

  app.get("/api/admin/zibra/config/audit", isAuthenticated, async (req: any, res) => {
    try {
      const user = req.user as any;
      const roles = user.roles || [];
      if (!roles.includes("super_admin")) {
        return res.status(403).json({ message: "Super admin access required" });
      }
      const { configKey } = req.query;
      const logs = await storage.getZibraConfigAuditLogs(configKey as string | undefined);
      res.json(logs);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch audit logs" });
    }
  });

  // ==========================================
  // ZIBRA PROACTIVE SIGNALS, COACHING, TRUST, VOICE & METRICS
  // ==========================================

  app.get("/api/zibra/proactive-signals", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ message: "Unauthorized" });
      const allRoles = await storage.getAllUserRoles(userId);
      const roleList = allRoles.map((r: any) => r.role);
      const primaryRole = roleList.includes("super_admin") ? "super_admin"
        : roleList.includes("admin") ? "admin"
        : roleList.includes("director") ? "director"
        : roleList.includes("driver") ? "driver"
        : "rider";
      const signals = await storage.getProactiveSignals(userId, primaryRole);
      res.json(signals);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch proactive signals" });
    }
  });

  app.post("/api/zibra/proactive-signals/dismiss", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ message: "Unauthorized" });
      const { signalId } = req.body;
      if (!signalId) return res.status(400).json({ message: "Signal ID required" });
      await storage.dismissProactiveSignal(signalId, userId);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to dismiss signal" });
    }
  });

  app.get("/api/zibra/voice-config", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ message: "Unauthorized" });
      const config = await storage.getVoiceConfig(userId);
      res.json(config || { enabled: false, language: "en", autoSpeak: false, requireConsent: true, speed: 1.0, pitch: 1.0 });
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch voice config" });
    }
  });

  app.post("/api/zibra/voice-config", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ message: "Unauthorized" });
      const { enabled, language, speed, pitch } = req.body;
      await storage.setVoiceConfig(userId, { enabled: enabled ?? false, language: language || "en", autoSpeak: false, requireConsent: true, speed: speed ?? 1.0, pitch: pitch ?? 1.0 });
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to save voice config" });
    }
  });

  app.get("/api/zibra/coaching", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ message: "Unauthorized" });
      const allRoles = await storage.getAllUserRoles(userId);
      const roleList = allRoles.map((r: any) => r.role);
      if (!roleList.includes("director")) {
        return res.status(403).json({ message: "Director access required" });
      }
      const insights = await storage.getCoachingInsights(userId);
      res.json(insights);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch coaching insights" });
    }
  });

  app.get("/api/zibra/trust-explanation", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ message: "Unauthorized" });
      const explanations = await storage.getTrustExplanations(userId);
      res.json(explanations);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch trust explanations" });
    }
  });

  app.get("/api/admin/zibra/insights", isAuthenticated, async (req: any, res) => {
    try {
      const user = req.user as any;
      const allRoles = await storage.getAllUserRoles(user.claims?.sub);
      const roleList = allRoles.map((r: any) => r.role);
      if (!roleList.includes("admin") && !roleList.includes("super_admin")) {
        return res.status(403).json({ message: "Admin access required" });
      }
      const { period } = req.query;
      const metrics = await storage.getZibraMetrics(period as string || "7d");
      res.json(metrics);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch ZIBRA insights" });
    }
  });

  app.get("/api/admin/zibra/resolution-stats", isAuthenticated, async (req: any, res) => {
    try {
      const user = req.user as any;
      const allRoles = await storage.getAllUserRoles(user.claims?.sub);
      const roleList = allRoles.map((r: any) => r.role);
      if (!roleList.includes("admin") && !roleList.includes("super_admin")) {
        return res.status(403).json({ message: "Admin access required" });
      }
      const stats = await storage.getResolutionStats();
      res.json(stats);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch resolution stats" });
    }
  });

  // ==========================================
  // ZIBRA ESCALATION PIPELINE (Phase I)
  // ==========================================

  app.post("/api/support/escalate", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ message: "Unauthorized" });
      }

      const { conversationId, currentScreen } = req.body;
      if (!conversationId) {
        return res.status(400).json({ message: "Conversation ID is required" });
      }

      const already = await storage.isConversationEscalated(conversationId);
      if (already) {
        return res.json({ message: "This conversation has already been escalated.", alreadyEscalated: true });
      }

      const allRoles = await storage.getAllUserRoles(userId);
      const roleList = allRoles.map(r => r.role);
      let detectedRole = "rider";
      if (roleList.includes("super_admin")) detectedRole = "super_admin";
      else if (roleList.includes("admin")) detectedRole = "admin";
      else if (roleList.includes("driver")) detectedRole = "driver";

      const recentMessages = await storage.getConversationMessages(conversationId, 10);

      const transcript = recentMessages.reverse().map((m: any) => 
        `[${m.role === "user" ? "User" : "ZIBA Support"}]: ${m.content}`
      ).join("\n\n");

      const ticket = await storage.createSupportTicket({
        createdByUserId: userId,
        createdByRole: detectedRole as any,
        subject: "ZIBA Support Escalation",
        description: `Escalated from ZIBA Support conversation.\n\nRoute context: ${currentScreen || "Unknown"}\nUser role: ${detectedRole}\n\n--- Last 10 Messages ---\n${transcript}`,
        status: "open",
        priority: "medium",
      });

      await storage.escalateSupportConversation(conversationId, ticket.id);

      await storage.addSupportMessage(conversationId, "support", 
        "A support agent will review this as soon as possible. You will be notified when there is an update.");

      res.json({ 
        success: true, 
        ticketId: ticket.id,
        message: "A support agent will review this as soon as possible."
      });
    } catch (error) {
      console.error("Error escalating conversation:", error);
      res.status(500).json({ message: "Failed to escalate. Please try again." });
    }
  });

  // Check if user is a test user
  app.get("/api/compliance/test-mode", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user!.claims.sub;
      const { isTestUser } = await import("./compliance-guards");
      const isTest = await isTestUser(userId);
      return res.json({ isTestUser: isTest });
    } catch (error) {
      console.error("Error checking test mode:", error);
      return res.status(500).json({ message: "Failed to check test mode" });
    }
  });

  // =============================================
  // PHASE 3: ADMIN OVERRIDE CONTROL & SUPPORT SAFETY
  // =============================================

  const VALID_OVERRIDE_ACTIONS = [
    "FORCE_LOGOUT", "RESET_SESSION", "RESTORE_AUTO_LOGIN",
    "ENABLE_DRIVER_ONLINE", "DISABLE_DRIVER_ONLINE",
    "CLEAR_CANCELLATION_FLAGS", "RESTORE_DRIVER_ACCESS",
    "CLEAR_RIDER_CANCELLATION_WARNING", "RESTORE_RIDE_ACCESS"
  ];

  app.post("/api/admin/override/apply", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { targetUserId, actionType, overrideReason, overrideExpiresAt } = req.body;

      if (!targetUserId || !actionType || !overrideReason) {
        return res.status(400).json({ message: "targetUserId, actionType, and overrideReason are required" });
      }

      if (!VALID_OVERRIDE_ACTIONS.includes(actionType)) {
        return res.status(400).json({ message: `Invalid actionType. Allowed: ${VALID_OVERRIDE_ACTIONS.join(", ")}` });
      }

      let previousState: string | null = null;
      let newState: string | null = null;

      switch (actionType) {
        case "FORCE_LOGOUT": {
          previousState = JSON.stringify({ action: "FORCE_LOGOUT", note: "Session override recorded" });
          newState = JSON.stringify({ action: "FORCE_LOGOUT", status: "active" });
          break;
        }
        case "RESET_SESSION": {
          previousState = JSON.stringify({ action: "RESET_SESSION", note: "Session reset override recorded" });
          newState = JSON.stringify({ action: "RESET_SESSION", status: "active" });
          break;
        }
        case "RESTORE_AUTO_LOGIN": {
          previousState = JSON.stringify({ action: "RESTORE_AUTO_LOGIN", note: "Auto-login restore recorded" });
          newState = JSON.stringify({ action: "RESTORE_AUTO_LOGIN", status: "active" });
          break;
        }
        case "ENABLE_DRIVER_ONLINE": {
          const driverProfile = await storage.getDriverProfile(targetUserId);
          previousState = JSON.stringify({ isOnline: driverProfile?.isOnline ?? false });
          await storage.updateDriverOnlineStatus(targetUserId, true);
          newState = JSON.stringify({ isOnline: true });
          break;
        }
        case "DISABLE_DRIVER_ONLINE": {
          const driverProfile = await storage.getDriverProfile(targetUserId);
          previousState = JSON.stringify({ isOnline: driverProfile?.isOnline ?? true });
          await storage.updateDriverOnlineStatus(targetUserId, false);
          newState = JSON.stringify({ isOnline: false });
          break;
        }
        case "CLEAR_CANCELLATION_FLAGS": {
          previousState = JSON.stringify({ action: "CLEAR_CANCELLATION_FLAGS", note: "Cancellation flags cleared" });
          newState = JSON.stringify({ action: "CLEAR_CANCELLATION_FLAGS", status: "active" });
          break;
        }
        case "RESTORE_DRIVER_ACCESS": {
          const suspension = await storage.getActiveSuspensionForUser(targetUserId);
          previousState = JSON.stringify({ suspensionId: suspension?.id ?? null, suspended: !!suspension });
          if (suspension) {
            await storage.liftSuspension(suspension.id, adminId, `Admin override: ${overrideReason}`);
          }
          newState = JSON.stringify({ suspended: false, liftedSuspensionId: suspension?.id ?? null });
          break;
        }
        case "CLEAR_RIDER_CANCELLATION_WARNING": {
          previousState = JSON.stringify({ action: "CLEAR_RIDER_CANCELLATION_WARNING", note: "Rider cancellation warning suppressed" });
          newState = JSON.stringify({ action: "CLEAR_RIDER_CANCELLATION_WARNING", status: "active" });
          break;
        }
        case "RESTORE_RIDE_ACCESS": {
          const rideSuspension = await storage.getActiveSuspensionForUser(targetUserId);
          previousState = JSON.stringify({ suspensionId: rideSuspension?.id ?? null, suspended: !!rideSuspension });
          if (rideSuspension) {
            await storage.liftSuspension(rideSuspension.id, adminId, `Admin override: ${overrideReason}`);
          }
          newState = JSON.stringify({ suspended: false, liftedSuspensionId: rideSuspension?.id ?? null });
          break;
        }
      }

      const override = await storage.createAdminOverride({
        targetUserId,
        adminActorId: adminId,
        actionType,
        overrideReason,
        overrideExpiresAt: overrideExpiresAt ? new Date(overrideExpiresAt) : undefined,
        previousState,
        newState,
      });

      await storage.createAdminOverrideAuditLog({
        overrideId: override.id,
        adminActorId: adminId,
        affectedUserId: targetUserId,
        actionType,
        overrideReason,
        previousState,
        newState,
        metadata: JSON.stringify({ expiresAt: overrideExpiresAt || null }),
      });

      console.log(`[ADMIN OVERRIDE] ${actionType} applied to user ${targetUserId} by admin ${adminId}`);
      return res.json({ success: true, override });
    } catch (error) {
      console.error("Error applying admin override:", error);
      return res.status(500).json({ message: "Failed to apply admin override" });
    }
  });

  app.get("/api/admin/overrides/active", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const overrides = await storage.getAllActiveOverrides();
      return res.json(overrides);
    } catch (error) {
      console.error("Error fetching active overrides:", error);
      return res.status(500).json({ message: "Failed to fetch active overrides" });
    }
  });

  app.get("/api/admin/overrides/user/:userId", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const overrides = await storage.getOverrideHistory(userId);
      return res.json(overrides);
    } catch (error) {
      console.error("Error fetching user override history:", error);
      return res.status(500).json({ message: "Failed to fetch override history" });
    }
  });

  app.post("/api/admin/override/:overrideId/revert", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { overrideId } = req.params;
      const { reason } = req.body;

      if (!reason) {
        return res.status(400).json({ message: "Revert reason is required" });
      }

      const existing = await storage.getAdminOverride(overrideId);
      if (!existing) {
        return res.status(404).json({ message: "Override not found" });
      }
      if (existing.status !== "active") {
        return res.status(400).json({ message: `Cannot revert override with status: ${existing.status}` });
      }

      let revertNewState: string | null = null;

      switch (existing.actionType) {
        case "ENABLE_DRIVER_ONLINE": {
          const prev = existing.previousState ? JSON.parse(existing.previousState) : {};
          await storage.updateDriverOnlineStatus(existing.targetUserId, prev.isOnline ?? false);
          revertNewState = JSON.stringify({ isOnline: prev.isOnline ?? false, reverted: true });
          break;
        }
        case "DISABLE_DRIVER_ONLINE": {
          const prev = existing.previousState ? JSON.parse(existing.previousState) : {};
          await storage.updateDriverOnlineStatus(existing.targetUserId, prev.isOnline ?? true);
          revertNewState = JSON.stringify({ isOnline: prev.isOnline ?? true, reverted: true });
          break;
        }
        default: {
          revertNewState = JSON.stringify({ reverted: true, note: "Override flag removed" });
          break;
        }
      }

      const reverted = await storage.revertAdminOverride(overrideId, adminId, reason);

      await storage.createAdminOverrideAuditLog({
        overrideId,
        adminActorId: adminId,
        affectedUserId: existing.targetUserId,
        actionType: existing.actionType,
        overrideReason: `REVERT: ${reason}`,
        previousState: existing.newState,
        newState: revertNewState,
        metadata: JSON.stringify({ revertedAt: new Date().toISOString() }),
      });

      console.log(`[ADMIN OVERRIDE] Override ${overrideId} reverted by admin ${adminId}`);
      return res.json({ success: true, override: reverted });
    } catch (error) {
      console.error("Error reverting admin override:", error);
      return res.status(500).json({ message: "Failed to revert admin override" });
    }
  });

  app.get("/api/admin/overrides/audit-log", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const logs = await storage.getAdminOverrideAuditLogs();
      return res.json(logs);
    } catch (error) {
      console.error("Error fetching override audit logs:", error);
      return res.status(500).json({ message: "Failed to fetch override audit logs" });
    }
  });

  app.get("/api/admin/overrides/audit-log/:userId", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const logs = await storage.getAdminOverrideAuditLogs(userId);
      return res.json(logs);
    } catch (error) {
      console.error("Error fetching user override audit logs:", error);
      return res.status(500).json({ message: "Failed to fetch user override audit logs" });
    }
  });

  // Phase 4 - User Analytics: Session heartbeat + Growth Analytics API
  app.post("/api/analytics/session-heartbeat", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) return res.status(401).json({ message: "Not authenticated" });
      const roles = await storage.getAllUserRoles(userId);
      for (const userRole of roles) {
        await storage.updateUserSession(userId, userRole.role);
      }
      return res.json({ ok: true });
    } catch (error) {
      console.error("Error recording session heartbeat:", error);
      return res.status(500).json({ message: "Failed to record session" });
    }
  });

  app.get("/api/analytics/user-growth", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const data = await storage.getUserGrowthAnalytics();
      return res.json(data);
    } catch (error) {
      console.error("Error fetching user growth analytics:", error);
      return res.status(500).json({ message: "Failed to fetch user growth analytics" });
    }
  });

  // Admin Override Auto-Expiration Scheduler
  setInterval(async () => {
    try {
      const expiredCount = await storage.expireOverrides();
      if (expiredCount > 0) {
        console.log(`[OVERRIDE SCHEDULER] Expired ${expiredCount} admin overrides`);
      }
    } catch (error) {
      console.error("[OVERRIDE SCHEDULER] Error expiring overrides:", error);
    }
  }, 60000);
  console.log("[OVERRIDE SCHEDULER] Started  polling every 60s for expired overrides");

  // =============================================
  // PHASE 6: LAUNCH READINESS & SAFETY KILL-SWITCHES
  // =============================================

  // Get launch readiness status
  app.get("/api/admin/launch/readiness", isAuthenticated, requireRole(["super_admin", "admin", "director"]), async (req: any, res) => {
    try {
      const { getLaunchReadinessStatus } = await import("./launch-control");
      const countryCode = (req.query.countryCode as string) || "NG";
      const status = await getLaunchReadinessStatus(countryCode);
      return res.json(status);
    } catch (error) {
      console.error("Error getting launch readiness:", error);
      return res.status(500).json({ message: "Failed to get launch readiness status" });
    }
  });

  // Get state launch configs for a country
  app.get("/api/admin/launch/states", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const countryCode = (req.query.countryCode as string) || "NG";
      const states = await storage.getStateLaunchConfigsByCountry(countryCode);
      return res.json(states);
    } catch (error) {
      console.error("Error getting state configs:", error);
      return res.status(500).json({ message: "Failed to get state configs" });
    }
  });

  // Toggle state enabled/disabled
  app.post("/api/admin/launch/state/toggle", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { stateCode, countryCode, enabled } = req.body;
      if (!stateCode) return res.status(400).json({ message: "stateCode is required" });

      const cc = countryCode || "NG";
      const updated = await storage.updateStateLaunchConfig(stateCode, cc, {
        stateEnabled: enabled,
        lastUpdatedBy: adminId,
      });

      if (!updated) {
        return res.status(404).json({ message: "State config not found" });
      }

      await storage.createComplianceAuditLog({
        category: "LAUNCH_MODE_CHANGE",
        actionBy: adminId,
        eventType: `STATE_${enabled ? "ENABLED" : "DISABLED"}`,
        eventData: JSON.stringify({ stateCode, countryCode: cc }),
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error toggling state:", error);
      return res.status(500).json({ message: "Failed to toggle state" });
    }
  });

  // Update state launch config (thresholds, wait times, etc.)
  app.patch("/api/admin/launch/state/:stateCode", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { stateCode } = req.params;
      const countryCode = req.body.countryCode || "NG";
      const { minOnlineDriversCar, minOnlineDriversBike, minOnlineDriversKeke, maxPickupWaitMinutes, autoDisableOnWaitExceed } = req.body;

      const updateData: any = { lastUpdatedBy: adminId };
      if (minOnlineDriversCar !== undefined) updateData.minOnlineDriversCar = minOnlineDriversCar;
      if (minOnlineDriversBike !== undefined) updateData.minOnlineDriversBike = minOnlineDriversBike;
      if (minOnlineDriversKeke !== undefined) updateData.minOnlineDriversKeke = minOnlineDriversKeke;
      if (maxPickupWaitMinutes !== undefined) updateData.maxPickupWaitMinutes = maxPickupWaitMinutes;
      if (autoDisableOnWaitExceed !== undefined) updateData.autoDisableOnWaitExceed = autoDisableOnWaitExceed;

      const updated = await storage.updateStateLaunchConfig(stateCode, countryCode, updateData);
      if (!updated) return res.status(404).json({ message: "State config not found" });

      return res.json(updated);
    } catch (error) {
      console.error("Error updating state config:", error);
      return res.status(500).json({ message: "Failed to update state config" });
    }
  });

  // Toggle country enabled/disabled
  app.post("/api/admin/launch/country/toggle", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { countryCode, enabled } = req.body;
      if (!countryCode) return res.status(400).json({ message: "countryCode is required" });

      const country = await storage.getCountryByCode(countryCode);
      if (!country) return res.status(404).json({ message: "Country not found" });

      await storage.updateCountry(country.id, { countryEnabled: enabled });

      await storage.createComplianceAuditLog({
        category: "LAUNCH_MODE_CHANGE",
        actionBy: adminId,
        eventType: `COUNTRY_${enabled ? "ENABLED" : "DISABLED"}`,
        eventData: JSON.stringify({ countryCode }),
      });

      return res.json({ success: true, countryCode, enabled });
    } catch (error) {
      console.error("Error toggling country:", error);
      return res.status(500).json({ message: "Failed to toggle country" });
    }
  });

  // Get all countries for launch control
  app.get("/api/admin/launch/countries", isAuthenticated, requireRole(["super_admin", "admin", "director"]), async (req: any, res) => {
    try {
      const countries = await storage.getCountriesForLaunch();
      return res.json(countries);
    } catch (error) {
      console.error("Error getting countries:", error);
      return res.status(500).json({ message: "Failed to get countries" });
    }
  });

  app.post("/api/admin/launch/country/create", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { name, isoCode, currency, timezone, subregionType, subregions } = req.body;

      if (!name || !isoCode || !currency || !timezone) {
        return res.status(400).json({ message: "Name, ISO code, currency, and timezone are required" });
      }

      if (isoCode.length < 2 || isoCode.length > 3) {
        return res.status(400).json({ message: "ISO code must be 2-3 characters" });
      }

      const existing = await storage.getCountryByCode(isoCode.toUpperCase());
      if (existing) {
        return res.status(409).json({ message: `Country with code ${isoCode.toUpperCase()} already exists` });
      }

      const country = await storage.createCountry({
        name,
        isoCode: isoCode.toUpperCase(),
        currency: currency.toUpperCase(),
        timezone,
        active: true,
        countryEnabled: false,
        defaultSystemMode: "NORMAL",
        paymentsEnabled: false,
      } as any);

      if (subregions && Array.isArray(subregions) && subregions.length > 0) {
        const srType = subregionType || "state";
        for (const sub of subregions) {
          if (sub.code && sub.name) {
            await storage.createStateLaunchConfig({
              countryCode: isoCode.toUpperCase(),
              stateCode: sub.code.toUpperCase(),
              stateName: sub.name,
              subregionType: srType,
              stateEnabled: false,
              minOnlineDriversCar: 3,
              minOnlineDriversBike: 2,
              minOnlineDriversKeke: 1,
              maxPickupWaitMinutes: 15,
              autoDisableOnWaitExceed: true,
            });
          }
        }
      }

      await storage.createComplianceAuditLog({
        category: "LAUNCH_MODE_CHANGE",
        actionBy: adminId,
        eventType: "COUNTRY_CREATED",
        eventData: JSON.stringify({ isoCode: isoCode.toUpperCase(), name, subregionCount: subregions?.length || 0 }),
      });

      return res.json({ success: true, country });
    } catch (error: any) {
      console.error("Error creating country:", error);
      return res.status(500).json({ message: error.message || "Failed to create country" });
    }
  });

  app.post("/api/admin/launch/country/add-subregion", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const { countryCode, stateCode, stateName, subregionType } = req.body;
      if (!countryCode || !stateCode || !stateName) {
        return res.status(400).json({ message: "countryCode, stateCode, and stateName are required" });
      }

      const existing = await storage.getStateLaunchConfig(stateCode.toUpperCase(), countryCode.toUpperCase());
      if (existing) {
        return res.status(409).json({ message: `Subregion ${stateCode} already exists for ${countryCode}` });
      }

      const config = await storage.createStateLaunchConfig({
        countryCode: countryCode.toUpperCase(),
        stateCode: stateCode.toUpperCase(),
        stateName,
        subregionType: subregionType || "state",
        stateEnabled: false,
        minOnlineDriversCar: 3,
        minOnlineDriversBike: 2,
        minOnlineDriversKeke: 1,
        maxPickupWaitMinutes: 15,
        autoDisableOnWaitExceed: true,
      });

      return res.json({ success: true, config });
    } catch (error: any) {
      console.error("Error adding subregion:", error);
      return res.status(500).json({ message: error.message || "Failed to add subregion" });
    }
  });

  // Set country-specific system mode
  app.post("/api/admin/launch/country/system-mode", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { countryCode, mode, reason } = req.body;
      if (!countryCode || !mode) return res.status(400).json({ message: "countryCode and mode are required" });
      if (!["NORMAL", "LIMITED", "EMERGENCY"].includes(mode)) {
        return res.status(400).json({ message: "Valid mode (NORMAL, LIMITED, EMERGENCY) is required" });
      }

      const result = await storage.setCountrySystemMode(countryCode, mode, reason || "", adminId);
      if (!result) return res.status(404).json({ message: "Country not found" });

      await storage.createComplianceAuditLog({
        category: "LAUNCH_MODE_CHANGE",
        actionBy: adminId,
        eventType: "COUNTRY_SYSTEM_MODE_CHANGE",
        eventData: JSON.stringify({ countryCode, mode, reason }),
      });

      return res.json(result);
    } catch (error) {
      console.error("Error setting country system mode:", error);
      return res.status(500).json({ message: "Failed to set country system mode" });
    }
  });

  // Get/Set system mode
  app.get("/api/admin/launch/system-mode", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const mode = await storage.getCurrentSystemMode();
      return res.json(mode || { currentMode: "NORMAL", reason: null });
    } catch (error) {
      console.error("Error getting system mode:", error);
      return res.status(500).json({ message: "Failed to get system mode" });
    }
  });

  app.post("/api/admin/launch/system-mode", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { mode, reason } = req.body;
      if (!mode || !["NORMAL", "LIMITED", "EMERGENCY"].includes(mode)) {
        return res.status(400).json({ message: "Valid mode (NORMAL, LIMITED, EMERGENCY) is required" });
      }

      const result = await storage.setSystemMode(mode, reason || "", adminId);

      await storage.createComplianceAuditLog({
        category: "LAUNCH_MODE_CHANGE",
        actionBy: adminId,
        eventType: "SYSTEM_MODE_CHANGE",
        eventData: JSON.stringify({ mode, reason }),
      });

      return res.json(result);
    } catch (error) {
      console.error("Error setting system mode:", error);
      return res.status(500).json({ message: "Failed to set system mode" });
    }
  });

  // Enhanced kill switch routes (Phase 6 additions)
  app.get("/api/admin/launch/kill-switches", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const states = await storage.getAllKillSwitchStates();
      return res.json(states);
    } catch (error) {
      console.error("Error getting kill switches:", error);
      return res.status(500).json({ message: "Failed to get kill switches" });
    }
  });

  app.post("/api/admin/launch/kill-switch/toggle", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { switchName, activate, reason, scope, countryCode, subregionCode } = req.body;
      if (!switchName) return res.status(400).json({ message: "switchName is required" });

      const switchScope = scope || "GLOBAL";
      let result;
      if (activate) {
        result = await storage.activateScopedKillSwitch(
          switchName, switchScope, reason || "Activated via Launch Control", adminId,
          countryCode || undefined, subregionCode || undefined
        );
      } else {
        result = await storage.deactivateScopedKillSwitch(
          switchName, switchScope, adminId,
          countryCode || undefined, subregionCode || undefined
        );
      }

      await storage.createComplianceAuditLog({
        category: "KILL_SWITCH_TOGGLE",
        actionBy: adminId,
        eventType: activate ? "KILL_SWITCH_ACTIVATED" : "KILL_SWITCH_DEACTIVATED",
        eventData: JSON.stringify({ switchName, reason, scope: switchScope, countryCode, subregionCode }),
      });

      return res.json({ success: true, state: result });
    } catch (error) {
      console.error("Error toggling kill switch:", error);
      return res.status(500).json({ message: "Failed to toggle kill switch" });
    }
  });

  // Seed all countries, subregions, and kill switches on startup
  (async () => {
    try {
      const { seedCountryLaunch } = await import("./launch-control");
      await seedCountryLaunch();
      console.log("[LAUNCH CONTROL] Seeded countries, subregions, and kill switches for all markets");
    } catch (error) {
      console.error("[LAUNCH CONTROL] Error seeding launch data:", error);
    }
  })();

  (async () => {
    try {
      await storage.seedDefaultCountryTaxConfigs();
      console.log("[TAX COMPLIANCE] Seeded default country tax configurations");
    } catch (error) {
      console.error("[TAX COMPLIANCE] Error seeding tax configs:", error);
    }
  })();

  // Public endpoint - check if service available in area
  app.get("/api/launch/check", async (req, res) => {
    try {
      const { checkTripRequestAllowed } = await import("./launch-control");
      const countryCode = (req.query.countryCode as string) || "NG";
      const stateCode = req.query.stateCode as string;
      const result = await checkTripRequestAllowed(countryCode, stateCode);
      return res.json(result);
    } catch (error) {
      console.error("Error checking launch status:", error);
      return res.json({ allowed: false, reason: "Unable to verify service availability." });
    }
  });

  // =============================================
  // PHASE 8: ROLLOUT MANAGEMENT ENDPOINTS
  // =============================================

  const ROLLOUT_ORDER = ["PLANNED", "PREP", "PILOT", "LIMITED_LIVE", "FULL_LIVE"] as const;

  app.post("/api/admin/rollout/promote", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { countryCode, reason } = req.body;
      if (!countryCode) return res.status(400).json({ message: "countryCode is required" });

      const country = await storage.getCountryByCode(countryCode);
      if (!country) return res.status(404).json({ message: "Country not found" });

      const currentStatus = country.rolloutStatus || "PLANNED";
      const currentIdx = ROLLOUT_ORDER.indexOf(currentStatus as any);
      if (currentIdx === -1 || currentStatus === "PAUSED") {
        return res.status(400).json({ message: `Cannot promote from status: ${currentStatus}. Unpause first.` });
      }
      if (currentIdx >= ROLLOUT_ORDER.length - 1) {
        return res.status(400).json({ message: "Country is already at FULL_LIVE stage" });
      }

      const nextStatus = ROLLOUT_ORDER[currentIdx + 1];

      if (nextStatus === "PILOT") {
        if (!country.currency) {
          return res.status(400).json({ message: "Gate check failed: Country must have a currency configured" });
        }
        const subregions = await storage.getStateLaunchConfigsByCountry(countryCode);
        if (!subregions || subregions.length === 0) {
          return res.status(400).json({ message: "Gate check failed: At least 1 subregion must be configured" });
        }
        const { isScopedKillSwitchActive } = await import("./launch-control");
        const killActive = await isScopedKillSwitchActive("KILL_TRIP_REQUESTS", countryCode);
        if (killActive) {
          return res.status(400).json({ message: "Gate check failed: Kill switches must not be active for the country" });
        }
      }

      if (nextStatus === "LIMITED_LIVE") {
        const tripStats = await db.select({
          total: count(),
          completed: sql<number>`count(*) filter (where ${trips.status} = 'completed')`,
          cancelled: sql<number>`count(*) filter (where ${trips.status} = 'cancelled')`,
        }).from(trips).where(eq(trips.countryId, country.id));

        const stats = tripStats[0];
        const totalTrips = Number(stats?.total || 0);
        if (totalTrips > 0) {
          const completionRate = (Number(stats.completed) / totalTrips) * 100;
          const cancellationRate = (Number(stats.cancelled) / totalTrips) * 100;
          if (completionRate < (country.minTripCompletionRate || 80)) {
            return res.status(400).json({ message: `Gate check failed: Trip completion rate ${completionRate.toFixed(1)}% is below threshold ${country.minTripCompletionRate}%` });
          }
          if (cancellationRate > (country.maxCancellationRate || 20)) {
            return res.status(400).json({ message: `Gate check failed: Cancellation rate ${cancellationRate.toFixed(1)}% exceeds threshold ${country.maxCancellationRate}%` });
          }
        }

        if (country.lastIncidentAt) {
          const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
          if (new Date(country.lastIncidentAt) > sevenDaysAgo) {
            return res.status(400).json({ message: "Gate check failed: An incident occurred within the last 7 days" });
          }
        }
      }

      if (nextStatus === "FULL_LIVE") {
        if (country.lastIncidentAt) {
          const fourteenDaysAgo = new Date(Date.now() - 14 * 24 * 60 * 60 * 1000);
          if (new Date(country.lastIncidentAt) > fourteenDaysAgo) {
            return res.status(400).json({ message: "Gate check failed: An incident occurred within the last 14 days" });
          }
        }
      }

      const updateData: any = {
        rolloutStatus: nextStatus,
        rolloutStatusChangedBy: adminId,
        rolloutStatusChangedAt: new Date(),
      };
      if (["PILOT", "LIMITED_LIVE", "FULL_LIVE"].includes(nextStatus)) {
        updateData.countryEnabled = true;
      }

      const updated = await storage.updateCountry(country.id, updateData);

      await storage.createComplianceAuditLog({
        category: "LAUNCH_MODE_CHANGE",
        actionBy: adminId,
        eventType: "ROLLOUT_PROMOTED",
        eventData: JSON.stringify({ countryCode, from: currentStatus, to: nextStatus, reason }),
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error promoting rollout:", error);
      return res.status(500).json({ message: "Failed to promote rollout stage" });
    }
  });

  app.post("/api/admin/rollout/demote", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { countryCode, reason, targetStatus } = req.body;
      if (!countryCode || !targetStatus) return res.status(400).json({ message: "countryCode and targetStatus are required" });

      const validStatuses = ["PLANNED", "PREP", "PILOT", "LIMITED_LIVE", "FULL_LIVE", "PAUSED"];
      if (!validStatuses.includes(targetStatus)) {
        return res.status(400).json({ message: `Invalid targetStatus. Must be one of: ${validStatuses.join(", ")}` });
      }

      const country = await storage.getCountryByCode(countryCode);
      if (!country) return res.status(404).json({ message: "Country not found" });

      const currentStatus = country.rolloutStatus || "PLANNED";
      if (targetStatus !== "PAUSED") {
        const currentIdx = ROLLOUT_ORDER.indexOf(currentStatus as any);
        const targetIdx = ROLLOUT_ORDER.indexOf(targetStatus as any);
        if (targetIdx >= currentIdx) {
          return res.status(400).json({ message: "Target status must be an earlier stage than current status" });
        }
      }

      const updateData: any = {
        rolloutStatus: targetStatus,
        rolloutStatusChangedBy: adminId,
        rolloutStatusChangedAt: new Date(),
      };
      if (targetStatus === "PLANNED" || targetStatus === "PREP" || targetStatus === "PAUSED") {
        updateData.countryEnabled = false;
      }

      const updated = await storage.updateCountry(country.id, updateData);

      await storage.createComplianceAuditLog({
        category: "LAUNCH_MODE_CHANGE",
        actionBy: adminId,
        eventType: "ROLLOUT_DEMOTED",
        eventData: JSON.stringify({ countryCode, from: currentStatus, to: targetStatus, reason }),
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error demoting rollout:", error);
      return res.status(500).json({ message: "Failed to demote rollout stage" });
    }
  });

  app.post("/api/admin/rollout/config", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const { countryCode, pilotMaxDailyTrips, pilotMaxConcurrentDrivers, pilotSurgeEnabled, maxAvgPickupMinutes, minTripCompletionRate, maxCancellationRate } = req.body;
      if (!countryCode) return res.status(400).json({ message: "countryCode is required" });

      const country = await storage.getCountryByCode(countryCode);
      if (!country) return res.status(404).json({ message: "Country not found" });

      const updateData: any = {};
      if (pilotMaxDailyTrips !== undefined) updateData.pilotMaxDailyTrips = pilotMaxDailyTrips;
      if (pilotMaxConcurrentDrivers !== undefined) updateData.pilotMaxConcurrentDrivers = pilotMaxConcurrentDrivers;
      if (pilotSurgeEnabled !== undefined) updateData.pilotSurgeEnabled = pilotSurgeEnabled;
      if (maxAvgPickupMinutes !== undefined) updateData.maxAvgPickupMinutes = maxAvgPickupMinutes;
      if (minTripCompletionRate !== undefined) updateData.minTripCompletionRate = minTripCompletionRate;
      if (maxCancellationRate !== undefined) updateData.maxCancellationRate = maxCancellationRate;

      const updated = await storage.updateCountry(country.id, updateData);
      return res.json(updated);
    } catch (error) {
      console.error("Error updating rollout config:", error);
      return res.status(500).json({ message: "Failed to update rollout config" });
    }
  });

  app.get("/api/admin/rollout/dashboard", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const countryCode = req.query.countryCode as string;
      if (!countryCode) return res.status(400).json({ message: "countryCode query param is required" });

      const country = await storage.getCountryByCode(countryCode);
      if (!country) return res.status(404).json({ message: "Country not found" });

      const hasCurrency = !!country.currency;
      const subregions = await storage.getStateLaunchConfigsByCountry(countryCode);
      const hasSubregions = subregions && subregions.length > 0;

      const pricingCheck = await db.select({ count: count() }).from(countryPricingRules).where(eq(countryPricingRules.countryId, country.id));
      const hasPricing = Number(pricingCheck[0]?.count || 0) > 0;

      const prepChecklist = {
        hasCurrency,
        hasSubregions,
        hasPricing,
      };

      const tripStats = await db.select({
        total: count(),
        completed: sql<number>`count(*) filter (where ${trips.status} = 'completed')`,
        cancelled: sql<number>`count(*) filter (where ${trips.status} = 'cancelled')`,
      }).from(trips).where(eq(trips.countryId, country.id));

      const stats = tripStats[0];
      const totalTrips = Number(stats?.total || 0);
      const metrics = {
        totalTrips,
        completedTrips: Number(stats?.completed || 0),
        cancelledTrips: Number(stats?.cancelled || 0),
        completionRate: totalTrips > 0 ? ((Number(stats.completed) / totalTrips) * 100).toFixed(1) : "0.0",
        cancellationRate: totalTrips > 0 ? ((Number(stats.cancelled) / totalTrips) * 100).toFixed(1) : "0.0",
      };

      const activeSubregions = subregions ? subregions.filter(s => s.stateEnabled).length : 0;

      const liveDriversResult = await db.select({ count: count() }).from(stateLaunchConfigs)
        .where(and(
          eq(stateLaunchConfigs.countryCode, countryCode),
          sql`(${stateLaunchConfigs.currentOnlineDriversCar} + ${stateLaunchConfigs.currentOnlineDriversBike} + ${stateLaunchConfigs.currentOnlineDriversKeke}) > 0`
        ));
      const liveDriversCount = Number(liveDriversResult[0]?.count || 0);

      const killSwitchResult = await db.select({ count: count() }).from(killSwitchStates)
        .where(and(
          eq(killSwitchStates.isActive, true),
          eq(killSwitchStates.scope, "COUNTRY"),
          eq(killSwitchStates.scopeCountryCode, countryCode)
        ));
      const activeKillSwitches = Number(killSwitchResult[0]?.count || 0);

      return res.json({
        country,
        prepChecklist,
        metrics,
        activeSubregions,
        liveDriversCount,
        activeKillSwitches,
      });
    } catch (error) {
      console.error("Error fetching rollout dashboard:", error);
      return res.status(500).json({ message: "Failed to fetch rollout dashboard" });
    }
  });

  // =============================================
  // PHASE 9: DRIVER ACQUISITION AUTOMATION
  // =============================================

  // Get acquisition analytics
  app.get("/api/admin/acquisition/analytics", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const countryCode = req.query.countryCode as string | undefined;
      const analytics = await storage.getDriverAcquisitionAnalytics(countryCode);
      return res.json(analytics);
    } catch (error) {
      console.error("Error fetching acquisition analytics:", error);
      return res.status(500).json({ message: "Failed to fetch acquisition analytics" });
    }
  });

  // Get onboarding pipeline
  app.get("/api/admin/acquisition/pipeline", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const countryCode = req.query.countryCode as string | undefined;
      const pipeline = await storage.getOnboardingPipeline(countryCode);
      return res.json(pipeline);
    } catch (error) {
      console.error("Error fetching onboarding pipeline:", error);
      return res.status(500).json({ message: "Failed to fetch onboarding pipeline" });
    }
  });

  // Get driver acquisitions by channel
  app.get("/api/admin/acquisition/drivers", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const { channel, countryCode } = req.query;
      const drivers = await storage.getDriverAcquisitionsByChannel(channel as string, countryCode as string);
      return res.json(drivers);
    } catch (error) {
      console.error("Error fetching driver acquisitions:", error);
      return res.status(500).json({ message: "Failed to fetch driver acquisitions" });
    }
  });

  // Track driver acquisition on signup
  app.post("/api/acquisition/track-signup", isAuthenticated, async (req: any, res) => {
    try {
      const { channel, referralCode, fleetOwnerId, countryCode, stateCode } = req.body;
      const userId = req.user.id;
      
      const existing = await storage.getDriverAcquisition(userId);
      if (existing) return res.status(400).json({ message: "Acquisition already tracked" });

      const zoneControl = await storage.getAcquisitionZoneControl(countryCode || "NG", stateCode);
      if (zoneControl?.status === "PAUSED") {
        return res.status(403).json({ message: "Driver acquisition is paused in this zone" });
      }

      const data: any = {
        driverUserId: userId,
        channel: channel || "PUBLIC_SIGNUP",
        countryCode: countryCode || "NG",
        stateCode,
        onboardingStage: "SIGNUP",
      };

      if (channel === "REFERRAL" && referralCode) {
        const code = await storage.getReferralCodeByCode(referralCode);
        if (code && code.active) {
          if (code.ownerUserId === userId) {
            return res.status(400).json({ message: "Cannot use your own referral code" });
          }
          data.referralCodeId = code.id;
          data.referredByUserId = code.ownerUserId;
          await storage.updateReferralCodeUsage(code.id);

          const country = await storage.getCountryByCode(countryCode || "NG");
          const reward = await storage.createDriverReferralReward({
            referrerUserId: code.ownerUserId,
            referredDriverUserId: userId,
            referralCodeId: code.id,
            requiredTrips: 5,
            completedTrips: 0,
            requiredWithinDays: 30,
            deadlineAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
            rewardAmount: "500.00",
            currency: country?.currency || "NGN",
            paid: false,
            expired: false,
            fraudFlagged: false,
          });
        }
      }

      if (channel === "FLEET_OWNER" && fleetOwnerId) {
        data.fleetOwnerId = fleetOwnerId;
      }

      if (channel === "ADMIN_INVITED") {
        data.invitedByAdminId = req.user.id;
      }

      const acquisition = await storage.createDriverAcquisition(data);

      await storage.createDriverAutoMessage({
        driverUserId: userId,
        messageType: "WELCOME",
        title: "Welcome to ZIBA!",
        message: "Thanks for signing up as a driver. Complete your profile and upload your documents to get started.",
        countryCode: countryCode || "NG",
        stateCode,
      });

      return res.json(acquisition);
    } catch (error) {
      console.error("Error tracking acquisition:", error);
      return res.status(500).json({ message: "Failed to track acquisition" });
    }
  });

  // Update onboarding stage
  app.post("/api/acquisition/update-stage", isAuthenticated, async (req: any, res) => {
    try {
      const { stage } = req.body;
      const userId = req.user.id;
      
      const validStages = ["SIGNUP", "DOCUMENTS", "REVIEW", "FIRST_TRIP", "ACTIVE"];
      if (!validStages.includes(stage)) {
        return res.status(400).json({ message: "Invalid onboarding stage" });
      }

      const timestamps: any = {};
      if (stage === "DOCUMENTS") timestamps.documentsUploadedAt = new Date();
      if (stage === "REVIEW") timestamps.reviewStartedAt = new Date();
      if (stage === "FIRST_TRIP") timestamps.approvedAt = new Date();
      if (stage === "ACTIVE") timestamps.activatedAt = new Date();

      const updated = await storage.updateDriverOnboardingStage(userId, stage, timestamps);
      if (!updated) return res.status(404).json({ message: "No acquisition record found" });

      const messageMap: Record<string, { type: string; title: string; msg: string }> = {
        DOCUMENTS: { type: "DOCS_UPLOADED", title: "Documents Received", msg: "Your documents have been uploaded. They are now under review." },
        REVIEW: { type: "UNDER_REVIEW", title: "Under Review", msg: "Your application is being reviewed. You'll be notified once approved." },
        FIRST_TRIP: { type: "APPROVED", title: "You're Approved!", msg: "Congratulations! You're now approved to drive. Complete your first trip to become fully active." },
        ACTIVE: { type: "ACTIVATED", title: "Fully Active", msg: "You've completed your first trip and are now a fully active ZIBA driver!" },
      };

      if (messageMap[stage]) {
        const m = messageMap[stage];
        await storage.createDriverAutoMessage({
          driverUserId: userId,
          messageType: m.type,
          title: m.title,
          message: m.msg,
        });
      }

      return res.json(updated);
    } catch (error) {
      console.error("Error updating onboarding stage:", error);
      return res.status(500).json({ message: "Failed to update onboarding stage" });
    }
  });

  // Admin approve driver (moves to FIRST_TRIP stage)
  app.post("/api/admin/acquisition/approve-driver", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const { driverUserId } = req.body;
      if (!driverUserId) return res.status(400).json({ message: "driverUserId is required" });

      const acquisition = await storage.getDriverAcquisition(driverUserId);
      if (!acquisition) return res.status(404).json({ message: "No acquisition record found" });
      if (acquisition.onboardingStage !== "REVIEW") {
        return res.status(400).json({ message: "Driver is not in review stage" });
      }

      const approvedAt = new Date();
      const approvalMinutes = acquisition.reviewStartedAt
        ? Math.round((approvedAt.getTime() - new Date(acquisition.reviewStartedAt).getTime()) / 60000)
        : null;

      const updated = await storage.updateDriverOnboardingStage(driverUserId, "FIRST_TRIP", {
        approvedAt,
        approvalTimeMinutes: approvalMinutes,
      } as any);

      await storage.updateDriverStatus(driverUserId, "approved");

      await storage.createDriverAutoMessage({
        driverUserId,
        messageType: "APPROVED",
        title: "Application Approved",
        message: "Your driver application has been approved. You can now go online and accept trips!",
      });

      try {
        await storage.createDriverInboxMessage({
          userId: driverUserId,
          title: "Account Approved",
          body: "Your driver account has been approved. You can now go online and start accepting rides.",
          type: "approval_update",
        });
      } catch (e) { console.warn("[INBOX] Failed to send driver approval message:", e); }

      return res.json(updated);
    } catch (error) {
      console.error("Error approving driver:", error);
      return res.status(500).json({ message: "Failed to approve driver" });
    }
  });

  // Fleet Owner endpoints
  app.get("/api/admin/fleet-owners", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const fleetOwners = await storage.getAllFleetOwners();
      return res.json(fleetOwners);
    } catch (error) {
      console.error("Error fetching fleet owners:", error);
      return res.status(500).json({ message: "Failed to fetch fleet owners" });
    }
  });

  app.post("/api/admin/fleet-owners/create", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const { userId, companyName, countryCode, maxDrivers, bonusPerActivation } = req.body;
      if (!userId) return res.status(400).json({ message: "userId is required" });

      const existing = await storage.getFleetOwner(userId);
      if (existing) return res.status(400).json({ message: "User is already a fleet owner" });

      const fleetOwner = await storage.createFleetOwner({
        userId,
        companyName: companyName || null,
        countryCode: countryCode || "NG",
        maxDrivers: maxDrivers || 50,
        bonusPerActivation: bonusPerActivation || "0.00",
      });

      return res.json(fleetOwner);
    } catch (error) {
      console.error("Error creating fleet owner:", error);
      return res.status(500).json({ message: "Failed to create fleet owner" });
    }
  });

  app.post("/api/admin/fleet-owners/suspend", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const { userId, reason } = req.body;
      if (!userId || !reason) return res.status(400).json({ message: "userId and reason are required" });

      const suspended = await storage.suspendFleetOwner(userId, reason);
      if (!suspended) return res.status(404).json({ message: "Fleet owner not found" });

      return res.json(suspended);
    } catch (error) {
      console.error("Error suspending fleet owner:", error);
      return res.status(500).json({ message: "Failed to suspend fleet owner" });
    }
  });

  app.post("/api/admin/fleet-owners/update", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const { userId, ...data } = req.body;
      if (!userId) return res.status(400).json({ message: "userId is required" });

      const updated = await storage.updateFleetOwner(userId, data);
      if (!updated) return res.status(404).json({ message: "Fleet owner not found" });

      return res.json(updated);
    } catch (error) {
      console.error("Error updating fleet owner:", error);
      return res.status(500).json({ message: "Failed to update fleet owner" });
    }
  });

  // Supply alerts
  app.get("/api/admin/supply-alerts", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const countryCode = req.query.countryCode as string | undefined;
      const alerts = await storage.getActiveSupplyAlerts(countryCode);
      return res.json(alerts);
    } catch (error) {
      console.error("Error fetching supply alerts:", error);
      return res.status(500).json({ message: "Failed to fetch supply alerts" });
    }
  });

  app.post("/api/admin/supply-alerts/resolve", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const { alertId } = req.body;
      if (!alertId) return res.status(400).json({ message: "alertId is required" });

      const resolved = await storage.resolveSupplyAlert(alertId);
      if (!resolved) return res.status(404).json({ message: "Alert not found" });

      return res.json(resolved);
    } catch (error) {
      console.error("Error resolving supply alert:", error);
      return res.status(500).json({ message: "Failed to resolve supply alert" });
    }
  });

  // Acquisition zone controls
  app.get("/api/admin/acquisition/zone-controls", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const { countryCode, stateCode } = req.query;
      if (!countryCode) return res.status(400).json({ message: "countryCode is required" });

      const control = await storage.getAcquisitionZoneControl(countryCode as string, stateCode as string);
      return res.json(control || { status: "ACTIVE" });
    } catch (error) {
      console.error("Error fetching zone control:", error);
      return res.status(500).json({ message: "Failed to fetch zone control" });
    }
  });

  app.post("/api/admin/acquisition/zone-controls", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const { countryCode, stateCode, status, reason } = req.body;
      if (!countryCode || !status) return res.status(400).json({ message: "countryCode and status are required" });

      const control = await storage.setAcquisitionZoneControl(
        countryCode,
        stateCode || null,
        status,
        req.user.id,
        reason
      );

      return res.json(control);
    } catch (error) {
      console.error("Error setting zone control:", error);
      return res.status(500).json({ message: "Failed to set zone control" });
    }
  });

  // Referral rewards management
  app.get("/api/admin/referral-rewards", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const rewards = await storage.getDriverAcquisitionsByChannel("REFERRAL");
      return res.json(rewards);
    } catch (error) {
      console.error("Error fetching referral rewards:", error);
      return res.status(500).json({ message: "Failed to fetch referral rewards" });
    }
  });

  // Driver auto-messages for current driver
  app.get("/api/driver/messages", isAuthenticated, async (req: any, res) => {
    try {
      const messages = await storage.getDriverAutoMessages(req.user.id);
      return res.json(messages);
    } catch (error) {
      console.error("Error fetching driver messages:", error);
      return res.status(500).json({ message: "Failed to fetch driver messages" });
    }
  });

  // My acquisition status
  app.get("/api/driver/acquisition-status", isAuthenticated, async (req: any, res) => {
    try {
      const acquisition = await storage.getDriverAcquisition(req.user.id);
      return res.json(acquisition || null);
    } catch (error) {
      console.error("Error fetching acquisition status:", error);
      return res.status(500).json({ message: "Failed to fetch acquisition status" });
    }
  });

  // =============================================
  // PHASE 10A: HELP CENTER API ROUTES
  // =============================================

  // Public: Get help categories (audience-filtered)
  app.get("/api/help/categories", async (req: any, res) => {
    try {
      const audience = req.query.audience as string | undefined;
      const categories = await storage.getHelpCategories(audience);
      return res.json(categories);
    } catch (error) {
      console.error("Error fetching help categories:", error);
      return res.status(500).json({ message: "Failed to fetch help categories" });
    }
  });

  // Public: Get published help articles (with filters)
  app.get("/api/help/articles", async (req: any, res) => {
    try {
      const { categoryId, audience, featured, countryCode } = req.query;
      const articles = await storage.getHelpArticles({
        categoryId: categoryId as string,
        audience: audience as string,
        status: "PUBLISHED",
        featured: featured === "true" ? true : undefined,
        countryCode: countryCode as string,
      });
      return res.json(articles);
    } catch (error) {
      console.error("Error fetching help articles:", error);
      return res.status(500).json({ message: "Failed to fetch help articles" });
    }
  });

  // Public: Get most viewed help articles
  app.get("/api/help/articles/most-viewed", async (req: any, res) => {
    try {
      const { audience, limit } = req.query;
      const articles = await storage.getMostViewedHelpArticles(
        audience as string,
        limit ? parseInt(limit as string, 10) : undefined,
      );
      return res.json(articles);
    } catch (error) {
      console.error("Error fetching most viewed help articles:", error);
      return res.status(500).json({ message: "Failed to fetch most viewed help articles" });
    }
  });

  // Public: Get recently updated help articles
  app.get("/api/help/articles/recently-updated", async (req: any, res) => {
    try {
      const { audience, limit } = req.query;
      const articles = await storage.getRecentlyUpdatedHelpArticles(
        audience as string,
        limit ? parseInt(limit as string, 10) : undefined,
      );
      return res.json(articles);
    } catch (error) {
      console.error("Error fetching recently updated help articles:", error);
      return res.status(500).json({ message: "Failed to fetch recently updated help articles" });
    }
  });

  // Public: Get article by slug and increment view
  app.get("/api/help/articles/slug/:slug", async (req: any, res) => {
    try {
      const article = await storage.getHelpArticleBySlug(req.params.slug);
      if (!article || article.status !== "PUBLISHED") {
        return res.status(404).json({ message: "Article not found" });
      }
      await storage.incrementArticleView(article.id);
      return res.json(article);
    } catch (error) {
      console.error("Error fetching help article:", error);
      return res.status(500).json({ message: "Failed to fetch help article" });
    }
  });

  // Public: Search help articles
  app.get("/api/help/search", async (req: any, res) => {
    try {
      const { q, audience } = req.query;
      if (!q || typeof q !== "string" || q.trim().length === 0) {
        return res.json([]);
      }
      const results = await storage.searchHelpArticles(q.trim(), audience as string);
      const userId = req.user?.id;
      await storage.createHelpSearchLog({
        userId: userId || null,
        query: q.trim(),
        resultsCount: results.length,
      });
      return res.json(results);
    } catch (error) {
      console.error("Error searching help articles:", error);
      return res.status(500).json({ message: "Failed to search help articles" });
    }
  });

  // Public: Rate article helpful
  app.post("/api/help/articles/:id/rate", async (req: any, res) => {
    try {
      const { helpful } = req.body;
      if (typeof helpful !== "boolean") {
        return res.status(400).json({ message: "helpful must be a boolean" });
      }
      await storage.rateArticleHelpful(req.params.id, helpful);
      return res.json({ success: true });
    } catch (error) {
      console.error("Error rating help article:", error);
      return res.status(500).json({ message: "Failed to rate article" });
    }
  });

  // Admin: Get all help categories (including inactive)
  app.get("/api/admin/help/categories", isAuthenticated, requireRole(["super_admin", "admin", "support_agent"]), async (req: any, res) => {
    try {
      const categories = await storage.getHelpCategories();
      return res.json(categories);
    } catch (error) {
      console.error("Error fetching admin help categories:", error);
      return res.status(500).json({ message: "Failed to fetch help categories" });
    }
  });

  // Admin: Create help category
  app.post("/api/admin/help/categories", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const category = await storage.createHelpCategory(req.body);
      return res.status(201).json(category);
    } catch (error) {
      console.error("Error creating help category:", error);
      return res.status(500).json({ message: "Failed to create help category" });
    }
  });

  // Admin: Update help category
  app.patch("/api/admin/help/categories/:id", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const category = await storage.updateHelpCategory(req.params.id, req.body);
      if (!category) return res.status(404).json({ message: "Category not found" });
      return res.json(category);
    } catch (error) {
      console.error("Error updating help category:", error);
      return res.status(500).json({ message: "Failed to update help category" });
    }
  });

  // Admin: Delete help category
  app.delete("/api/admin/help/categories/:id", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const deleted = await storage.deleteHelpCategory(req.params.id);
      if (!deleted) return res.status(404).json({ message: "Category not found" });
      return res.json({ success: true });
    } catch (error) {
      console.error("Error deleting help category:", error);
      return res.status(500).json({ message: "Failed to delete help category" });
    }
  });

  // Admin: Get all help articles (all statuses)
  app.get("/api/admin/help/articles", isAuthenticated, requireRole(["super_admin", "admin", "support_agent"]), async (req: any, res) => {
    try {
      const { categoryId, status, audience } = req.query;
      const articles = await storage.getHelpArticles({
        categoryId: categoryId as string,
        audience: audience as string,
        status: status as string,
      });
      return res.json(articles);
    } catch (error) {
      console.error("Error fetching admin help articles:", error);
      return res.status(500).json({ message: "Failed to fetch help articles" });
    }
  });

  // Admin: Create help article
  app.post("/api/admin/help/articles", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const article = await storage.createHelpArticle({
        ...req.body,
        createdBy: req.user.id,
        updatedBy: req.user.id,
      });
      return res.status(201).json(article);
    } catch (error) {
      console.error("Error creating help article:", error);
      return res.status(500).json({ message: "Failed to create help article" });
    }
  });

  // Admin: Update help article
  app.patch("/api/admin/help/articles/:id", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const article = await storage.updateHelpArticle(req.params.id, {
        ...req.body,
        updatedBy: req.user.id,
      });
      if (!article) return res.status(404).json({ message: "Article not found" });
      return res.json(article);
    } catch (error) {
      console.error("Error updating help article:", error);
      return res.status(500).json({ message: "Failed to update help article" });
    }
  });

  // Admin: Delete help article
  app.delete("/api/admin/help/articles/:id", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const deleted = await storage.deleteHelpArticle(req.params.id);
      if (!deleted) return res.status(404).json({ message: "Article not found" });
      return res.json({ success: true });
    } catch (error) {
      console.error("Error deleting help article:", error);
      return res.status(500).json({ message: "Failed to delete help article" });
    }
  });

  // Admin: Get search logs
  app.get("/api/admin/help/search-logs", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 100;
      const logs = await storage.getHelpSearchLogs(limit);
      return res.json(logs);
    } catch (error) {
      console.error("Error fetching search logs:", error);
      return res.status(500).json({ message: "Failed to fetch search logs" });
    }
  });

  // =============================================
  // PHASE 10 - TRUSTED CONTACTS API
  // =============================================

  app.get("/api/trusted-contacts", isAuthenticated, async (req: any, res) => {
    try {
      const contacts = await storage.getTrustedContacts(req.user.id);
      return res.json(contacts);
    } catch (error) {
      console.error("Error fetching trusted contacts:", error);
      return res.status(500).json({ message: "Failed to fetch trusted contacts" });
    }
  });

  app.post("/api/trusted-contacts", isAuthenticated, async (req: any, res) => {
    try {
      const existing = await storage.getTrustedContacts(req.user.id);
      if (existing.length >= 5) {
        return res.status(400).json({ message: "Maximum of 5 trusted contacts allowed" });
      }
      const contact = await storage.createTrustedContact({
        ...req.body,
        userId: req.user.id,
      });
      return res.json(contact);
    } catch (error) {
      console.error("Error creating trusted contact:", error);
      return res.status(500).json({ message: "Failed to create trusted contact" });
    }
  });

  app.patch("/api/trusted-contacts/:id", isAuthenticated, async (req: any, res) => {
    try {
      const contact = await storage.updateTrustedContact(req.params.id, req.user.id, req.body);
      if (!contact) return res.status(404).json({ message: "Contact not found" });
      return res.json(contact);
    } catch (error) {
      console.error("Error updating trusted contact:", error);
      return res.status(500).json({ message: "Failed to update trusted contact" });
    }
  });

  app.delete("/api/trusted-contacts/:id", isAuthenticated, async (req: any, res) => {
    try {
      const deleted = await storage.deleteTrustedContact(req.params.id, req.user.id);
      if (!deleted) return res.status(404).json({ message: "Contact not found" });
      return res.json({ success: true });
    } catch (error) {
      console.error("Error deleting trusted contact:", error);
      return res.status(500).json({ message: "Failed to delete trusted contact" });
    }
  });

  // =============================================
  // PHASE 10 - TRIP SHARE LINKS API
  // =============================================

  app.post("/api/trips/:tripId/share", isAuthenticated, async (req: any, res) => {
    try {
      const { randomBytes } = await import("crypto");
      const shareToken = randomBytes(32).toString("hex");
      const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000);
      
      const link = await storage.createTripShareLink({
        tripId: req.params.tripId,
        sharedBy: req.user.id,
        shareToken,
        recipientPhone: req.body.recipientPhone || null,
        recipientName: req.body.recipientName || null,
        isActive: true,
        expiresAt,
      });
      return res.json(link);
    } catch (error) {
      console.error("Error creating trip share link:", error);
      return res.status(500).json({ message: "Failed to create share link" });
    }
  });

  app.get("/api/trip-share/:token", async (req, res) => {
    try {
      const link = await storage.getTripShareLinkByToken(req.params.token);
      if (!link) return res.status(404).json({ message: "Share link not found or expired" });
      if (new Date() > new Date(link.expiresAt)) {
        return res.status(410).json({ message: "Share link has expired" });
      }
      await storage.incrementShareLinkViewCount(link.id);
      const trip = await storage.getTripById(link.tripId);
      if (!trip) return res.status(404).json({ message: "Trip not found" });
      return res.json({
        trip: {
          id: trip.id,
          status: trip.status,
          pickupLocation: trip.pickupLocation,
          dropoffLocation: trip.dropoffLocation,
          createdAt: trip.createdAt,
        },
        sharedAt: link.createdAt,
        expiresAt: link.expiresAt,
      });
    } catch (error) {
      console.error("Error fetching shared trip:", error);
      return res.status(500).json({ message: "Failed to fetch shared trip" });
    }
  });

  app.get("/api/trips/:tripId/share-links", isAuthenticated, async (req: any, res) => {
    try {
      const links = await storage.getTripShareLinks(req.params.tripId);
      return res.json(links);
    } catch (error) {
      console.error("Error fetching share links:", error);
      return res.status(500).json({ message: "Failed to fetch share links" });
    }
  });

  app.delete("/api/trip-share/:id", isAuthenticated, async (req: any, res) => {
    try {
      const deactivated = await storage.deactivateTripShareLink(req.params.id);
      if (!deactivated) return res.status(404).json({ message: "Share link not found" });
      return res.json({ success: true });
    } catch (error) {
      console.error("Error deactivating share link:", error);
      return res.status(500).json({ message: "Failed to deactivate share link" });
    }
  });

  // =============================================
  // PHASE 10 - COUNTRY EMERGENCY CONFIG API
  // =============================================

  app.get("/api/emergency-config/:countryCode", async (req, res) => {
    try {
      const config = await storage.getCountryEmergencyConfig(req.params.countryCode.toUpperCase());
      if (!config) {
        return res.json({
          countryCode: req.params.countryCode.toUpperCase(),
          emergencyNumber: "911",
          policeNumber: null,
          ambulanceNumber: null,
          fireNumber: null,
          sosInstructions: null,
        });
      }
      return res.json(config);
    } catch (error) {
      console.error("Error fetching emergency config:", error);
      return res.status(500).json({ message: "Failed to fetch emergency config" });
    }
  });

  app.get("/api/admin/emergency-configs", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const configs = await storage.getAllCountryEmergencyConfigs();
      return res.json(configs);
    } catch (error) {
      console.error("Error fetching emergency configs:", error);
      return res.status(500).json({ message: "Failed to fetch emergency configs" });
    }
  });

  app.post("/api/admin/emergency-config", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const config = await storage.upsertCountryEmergencyConfig(req.body);
      return res.json(config);
    } catch (error) {
      console.error("Error saving emergency config:", error);
      return res.status(500).json({ message: "Failed to save emergency config" });
    }
  });

  // Phase 9: Admin Driver Override Routes
  app.post("/api/admin/driver/:driverId/override-trust-score", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const { driverId } = req.params;
      const { trustScore, reason } = req.body;
      if (typeof trustScore !== "number" || trustScore < 0 || trustScore > 100) {
        return res.status(400).json({ message: "Trust score must be between 0 and 100" });
      }
      const level = trustScore >= 80 ? "high" : trustScore >= 60 ? "medium" : "low";
      await db.update(userTrustProfiles)
        .set({ trustScore, trustScoreLevel: level })
        .where(eq(userTrustProfiles.userId, driverId));
      console.log(`[Admin Override] Trust score for driver ${driverId} set to ${trustScore} by ${req.user.claims.sub}. Reason: ${reason}`);
      return res.json({ success: true, trustScore, trustScoreLevel: level, reason });
    } catch (error) {
      console.error("Error overriding trust score:", error);
      return res.status(500).json({ message: "Failed to override trust score" });
    }
  });

  app.post("/api/admin/driver/:driverId/reset-cancellation-metrics", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const { driverId } = req.params;
      const { reason } = req.body;
      console.log(`[Admin Override] Cancellation metrics reset for driver ${driverId} by ${req.user.claims.sub}. Reason: ${reason}`);
      return res.json({ success: true, message: "Cancellation metrics reset logged", driverId, reason });
    } catch (error) {
      console.error("Error resetting cancellation metrics:", error);
      return res.status(500).json({ message: "Failed to reset cancellation metrics" });
    }
  });

  app.post("/api/admin/driver/:driverId/resolve-dispute", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const { driverId } = req.params;
      const { disputeId, resolution } = req.body;
      console.log(`[Admin Override] Dispute ${disputeId} resolved for driver ${driverId} by ${req.user.claims.sub}. Resolution: ${resolution}`);
      return res.json({ success: true, disputeId, resolution });
    } catch (error) {
      console.error("Error resolving dispute:", error);
      return res.status(500).json({ message: "Failed to resolve dispute" });
    }
  });

  app.post("/api/admin/driver/:driverId/remove-pairing-block", isAuthenticated, requireRole(["super_admin", "admin"]), async (req: any, res) => {
    try {
      const { driverId } = req.params;
      const { blockedUserId, reason } = req.body;
      console.log(`[Admin Override] Pairing block removed for driver ${driverId}, blocked user ${blockedUserId} by ${req.user.claims.sub}. Reason: ${reason}`);
      return res.json({ success: true, driverId, blockedUserId, reason });
    } catch (error) {
      console.error("Error removing pairing block:", error);
      return res.status(500).json({ message: "Failed to remove pairing block" });
    }
  });

  // Phase 10: Admin Driver Analytics
  app.get("/api/admin/analytics/drivers", isAuthenticated, requireRole(["super_admin", "admin", "director"]), async (req: any, res) => {
    try {
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      const [newDriversResult] = await db.select({ count: count() })
        .from(driverProfiles)
        .where(gte(driverProfiles.createdAt, thirtyDaysAgo));

      const [totalDriversResult] = await db.select({ count: count() })
        .from(driverProfiles);

      const [activeDriversResult] = await db.select({ count: count() })
        .from(driverProfiles)
        .where(eq(driverProfiles.isOnline, true));

      const [totalTripsResult] = await db.select({ count: count() })
        .from(trips)
        .where(eq(trips.status, "completed"));

      const totalTrips = totalTripsResult?.count || 0;
      const tipFrequency = 0;
      const newDriversCount = newDriversResult?.count || 0;
      const totalDrivers = totalDriversResult?.count || 0;
      const returningDriversCount = totalDrivers - newDriversCount;
      const dailyActiveDrivers = activeDriversResult?.count || 0;

      return res.json({
        newDriversCount,
        returningDriversCount: Math.max(0, returningDriversCount),
        dailyActiveDrivers,
        averageOnlineTime: 0,
        tipFrequency: Math.round(tipFrequency * 100) / 100,
        incentiveEffectiveness: 0,
        totalDrivers,
        totalCompletedTrips: totalTrips,
      });
    } catch (error) {
      console.error("Error fetching driver analytics:", error);
      return res.status(500).json({ message: "Failed to fetch driver analytics" });
    }
  });

  app.get("/api/driver/statements/:year", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const year = parseInt(req.params.year);
      if (isNaN(year)) return res.status(400).json({ message: "Invalid year" });

      const startOfYear = new Date(year, 0, 1);
      const endOfYear = new Date(year + 1, 0, 1);

      const driverTrips = await db.select()
        .from(trips)
        .where(
          and(
            eq(trips.driverId, userId),
            eq(trips.status, "completed"),
            gte(trips.completedAt, startOfYear),
            lt(trips.completedAt, endOfYear)
          )
        );

      const monthMap = new Map<number, { earnings: number; tips: number; commission: number; count: number }>();

      for (const trip of driverTrips) {
        const completedDate = trip.completedAt ? new Date(trip.completedAt) : null;
        if (!completedDate) continue;
        const month = completedDate.getMonth() + 1;

        if (!monthMap.has(month)) {
          monthMap.set(month, { earnings: 0, tips: 0, commission: 0, count: 0 });
        }
        const entry = monthMap.get(month)!;
        entry.earnings += parseFloat(trip.driverPayout || "0");
        entry.commission += parseFloat(trip.commissionAmount || "0");
        entry.count += 1;
      }

      const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

      const statements = Array.from(monthMap.entries()).map(([month, data]) => ({
        month,
        year,
        monthLabel: `${monthNames[month - 1]} ${year}`,
        totalDriverEarnings: Math.round(data.earnings * 100) / 100,
        totalTips: Math.round(data.tips * 100) / 100,
        totalIncentives: 0,
        totalPlatformFee: Math.round(data.commission * 100) / 100,
        netPayout: Math.round((data.earnings + data.tips) * 100) / 100,
        tripCount: data.count,
        onlineHours: 0,
        currency: "NGN",
      })).sort((a, b) => b.month - a.month);

      return res.json(statements);
    } catch (error) {
      console.error("Error fetching monthly statements:", error);
      return res.status(500).json({ message: "Failed to fetch statements" });
    }
  });

  // ============================================================
  // TAX STATEMENT DATA MODEL & QUERIES
  // Tax compliance only. No per-trip breakdowns. No daily exposure.
  // ============================================================

  async function computeTaxYearData(driverUserId: string, year: number) {
    const startOfYear = new Date(year, 0, 1);
    const endOfYear = new Date(year + 1, 0, 1);

    const driverTrips = await db.select()
      .from(trips)
      .where(
        and(
          eq(trips.driverId, driverUserId),
          eq(trips.status, "completed"),
          gte(trips.completedAt, startOfYear),
          lt(trips.completedAt, endOfYear)
        )
      );

    let totalTripEarnings = 0;
    let totalPlatformFees = 0;
    let totalTips = 0;
    let tripCount = 0;
    let currency = "NGN";

    for (const trip of driverTrips) {
      totalTripEarnings += parseFloat(trip.driverPayout || "0");
      totalPlatformFees += parseFloat(trip.commissionAmount || "0");
      if (trip.currencyCode) currency = trip.currencyCode;
      tripCount += 1;
    }

    const totalIncentives = 0;
    const totalGrossEarnings = totalTripEarnings + totalTips + totalIncentives;
    const reportableIncome = totalGrossEarnings;

    const mileageRecord = await storage.getDriverMileageForYear(driverUserId, year);
    const totalMilesDriven = mileageRecord ? parseFloat(mileageRecord.totalMilesOnline) : 0;

    return {
      totalGrossEarnings: Math.round(totalGrossEarnings * 100) / 100,
      totalTips: Math.round(totalTips * 100) / 100,
      totalIncentives: Math.round(totalIncentives * 100) / 100,
      totalPlatformFees: Math.round(totalPlatformFees * 100) / 100,
      totalMilesDriven: Math.round(totalMilesDriven * 100) / 100,
      reportableIncome: Math.round(reportableIncome * 100) / 100,
      currency,
      tripCount,
    };
  }

  // Driver: tax profile management
  app.get("/api/driver/tax/profile", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getDriverTaxProfile(userId);
      if (!profile) return res.json(null);
      return res.json({ ...profile, taxId: profile.taxId ? "****" : null });
    } catch (error) {
      console.error("Error fetching tax profile:", error);
      return res.status(500).json({ message: "Failed to fetch tax profile" });
    }
  });

  app.post("/api/driver/tax/profile", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { legalName, taxId, country, taxClassification } = req.body;
      if (!legalName || !country) {
        return res.status(400).json({ message: "legalName and country are required" });
      }
      const { encryptField } = await import("./crypto");
      const profile = await storage.upsertDriverTaxProfile({
        driverUserId: userId,
        legalName,
        taxId: taxId ? encryptField(taxId) : null,
        country,
        taxClassification: taxClassification || "independent_contractor",
      });
      return res.json({ ...profile, taxId: profile.taxId ? "****" : null });
    } catch (error) {
      console.error("Error saving tax profile:", error);
      return res.status(500).json({ message: "Failed to save tax profile" });
    }
  });

  // Driver: view tax year summary (uses stored summary if exists, else computes live)
  app.get("/api/driver/statements/annual/:year", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const year = parseInt(req.params.year);
      if (isNaN(year)) return res.status(400).json({ message: "Invalid year" });

      const driverProfile = await storage.getDriverProfile(userId);
      const taxProfile = await storage.getDriverTaxProfile(userId);
      const storedSummary = await storage.getDriverTaxYearSummary(userId, year);

      let summaryData;
      if (storedSummary && (storedSummary.status === "finalized" || storedSummary.status === "issued")) {
        summaryData = {
          totalGrossEarnings: parseFloat(storedSummary.totalGrossEarnings),
          totalTips: parseFloat(storedSummary.totalTips),
          totalIncentives: parseFloat(storedSummary.totalIncentives),
          totalPlatformFees: parseFloat(storedSummary.totalPlatformFees),
          totalMilesDriven: parseFloat(storedSummary.totalMilesDriven),
          reportableIncome: parseFloat(storedSummary.reportableIncome),
          currency: storedSummary.currency,
          status: storedSummary.status,
        };
      } else {
        const computed = await computeTaxYearData(userId, year);
        summaryData = { ...computed, status: "draft" };
      }

      return res.json({
        year,
        driverName: taxProfile?.legalName || driverProfile?.fullName || "Driver",
        driverId: userId.substring(0, 8).toUpperCase(),
        totalGrossEarnings: summaryData.totalGrossEarnings,
        totalTips: summaryData.totalTips,
        totalIncentives: summaryData.totalIncentives,
        totalPlatformFee: summaryData.totalPlatformFees,
        reportableIncome: summaryData.reportableIncome,
        totalTrips: 0,
        totalOnlineHours: 0,
        totalMilesDrivenOnline: summaryData.totalMilesDriven,
        currency: summaryData.currency,
        status: summaryData.status,
      });
    } catch (error) {
      console.error("Error fetching annual statement:", error);
      return res.status(500).json({ message: "Failed to fetch annual statement" });
    }
  });

  // Driver: view tax documents
  app.get("/api/driver/tax/documents", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const year = req.query.year ? parseInt(req.query.year as string) : undefined;
      const docs = await storage.getDriverTaxDocuments(userId, year);
      return res.json(docs);
    } catch (error) {
      console.error("Error fetching tax documents:", error);
      return res.status(500).json({ message: "Failed to fetch tax documents" });
    }
  });

  app.get("/api/driver/statements/:year/:month/download", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const year = parseInt(req.params.year);
      const month = parseInt(req.params.month);
      const format = req.query.format || "csv";

      if (isNaN(year) || isNaN(month)) return res.status(400).json({ message: "Invalid parameters" });

      const startOfMonth = new Date(year, month - 1, 1);
      const endOfMonth = new Date(year, month, 1);
      const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

      const driverTrips = await db.select()
        .from(trips)
        .where(
          and(
            eq(trips.driverId, userId),
            eq(trips.status, "completed"),
            gte(trips.completedAt, startOfMonth),
            lt(trips.completedAt, endOfMonth)
          )
        );

      let totalEarnings = 0;
      let totalCommission = 0;
      for (const trip of driverTrips) {
        totalEarnings += parseFloat(trip.driverPayout || "0");
        totalCommission += parseFloat(trip.commissionAmount || "0");
      }

      if (format === "csv") {
        const csvLines = [
          `ZIBA Driver Earnings Statement`,
          `Month,${monthNames[month - 1]} ${year}`,
          `Total Trips,${driverTrips.length}`,
          `Total Earnings,${totalEarnings.toFixed(2)}`,
          `Total Service Fees,${totalCommission.toFixed(2)}`,
          `Net Payout,${totalEarnings.toFixed(2)}`,
          ``,
          `Generated,${new Date().toISOString()}`,
        ];
        res.setHeader("Content-Type", "text/csv");
        res.setHeader("Content-Disposition", `attachment; filename="ziba-statement-${year}-${month}.csv"`);
        return res.send(csvLines.join("\n"));
      }

      return res.json({
        message: "PDF generation is not yet available. Please download CSV.",
        format: "csv",
        downloadUrl: `/api/driver/statements/${year}/${month}/download?format=csv`,
      });
    } catch (error) {
      console.error("Error downloading statement:", error);
      return res.status(500).json({ message: "Failed to download statement" });
    }
  });

  async function getCountryTaxRules(countryCode: string): Promise<CountryTaxRules> {
    const config = await storage.getCountryTaxConfig(countryCode);
    if (config) {
      return {
        documentLabel: config.documentLabel,
        documentType: config.documentType,
        mileageDisclosureEnabled: config.mileageDisclosureEnabled,
        withholdingEnabled: config.withholdingEnabled,
        complianceNotes: config.complianceNotes,
        driverClassificationLabel: config.driverClassificationLabel,
        reportableIncomeIncludesFees: config.reportableIncomeIncludesFees,
      };
    }
    return {
      documentLabel: "Annual Earnings & Tax Summary",
      documentType: "annual_statement",
      mileageDisclosureEnabled: true,
      withholdingEnabled: false,
      complianceNotes: "This document is provided for tax reporting purposes. Driver is responsible for filing applicable taxes.",
      driverClassificationLabel: "Independent Contractor",
      reportableIncomeIncludesFees: false,
    };
  }

  async function buildTaxDocumentData(driverUserId: string, year: number): Promise<TaxDocumentData> {
    const driverProfile = await storage.getDriverProfile(driverUserId);
    const taxProfile = await storage.getDriverTaxProfile(driverUserId);
    const storedSummary = await storage.getDriverTaxYearSummary(driverUserId, year);
    const docs = await storage.getDriverTaxDocuments(driverUserId, year);
    const latestDoc = docs.find(d => d.isLatest);

    let earnings;
    if (storedSummary && (storedSummary.status === "finalized" || storedSummary.status === "issued")) {
      earnings = {
        totalGrossEarnings: parseFloat(storedSummary.totalGrossEarnings),
        totalTips: parseFloat(storedSummary.totalTips),
        totalIncentives: parseFloat(storedSummary.totalIncentives),
        totalPlatformFees: parseFloat(storedSummary.totalPlatformFees),
        totalMilesDriven: parseFloat(storedSummary.totalMilesDriven),
        reportableIncome: parseFloat(storedSummary.reportableIncome),
        currency: storedSummary.currency,
      };
    } else {
      earnings = await computeTaxYearData(driverUserId, year);
    }

    const totalTripEarnings = earnings.totalGrossEarnings - earnings.totalTips - earnings.totalIncentives;
    const { maskTaxId } = await import("./crypto");
    const maskedTaxId = maskTaxId(taxProfile?.taxId || null);

    return {
      driverId: driverUserId,
      legalName: taxProfile?.legalName || driverProfile?.fullName || "Driver",
      country: taxProfile?.country || "NG",
      taxClassification: taxProfile?.taxClassification || "independent_contractor",
      maskedTaxId,
      taxYear: year,
      documentVersion: latestDoc?.version || 1,
      issueDate: new Date().toISOString().split("T")[0],
      totalGrossEarnings: earnings.totalGrossEarnings,
      totalTripEarnings: Math.round(totalTripEarnings * 100) / 100,
      totalTips: earnings.totalTips,
      totalIncentives: earnings.totalIncentives,
      totalPlatformFees: earnings.totalPlatformFees,
      totalMilesDriven: earnings.totalMilesDriven,
      reportableIncome: earnings.reportableIncome,
      currency: earnings.currency,
    };
  }

  app.get("/api/driver/statements/annual/:year/download", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const year = parseInt(req.params.year);
      const format = (req.query.format || "pdf").toLowerCase();

      if (isNaN(year)) return res.status(400).json({ message: "Invalid year" });

      const docData = await buildTaxDocumentData(userId, year);
      const rules = await getCountryTaxRules(docData.country);

      if (format === "csv") {
        const csv = generateTaxCSV(docData);
        res.setHeader("Content-Type", "text/csv; charset=utf-8");
        res.setHeader("Content-Disposition", `attachment; filename="ziba-annual-tax-${year}.csv"`);
        return res.send(csv);
      }

      const pdfDoc = generateTaxPDF(docData, rules.documentType, rules);
      res.setHeader("Content-Type", "application/pdf");
      res.setHeader("Content-Disposition", `attachment; filename="ziba-annual-tax-${year}.pdf"`);
      pdfDoc.pipe(res);
      pdfDoc.end();
    } catch (error) {
      console.error("Error downloading annual statement:", error);
      return res.status(500).json({ message: "Failed to download annual statement" });
    }
  });

  // ============================================================
  // ADMIN TAX MANAGEMENT (read-only views, generate, issue)
  // ============================================================

  // Admin: validate driver data before generation
  app.get("/api/admin/tax/validate/:driverId/:year", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const driverId = req.params.driverId;
      const year = parseInt(req.params.year);
      if (isNaN(year)) return res.status(400).json({ message: "Invalid year" });

      const errors: string[] = [];
      const warnings: string[] = [];

      const taxProfile = await storage.getDriverTaxProfile(driverId);
      if (!taxProfile) {
        errors.push("DriverTaxProfile does not exist");
      } else {
        if (!taxProfile.taxId) warnings.push("Tax ID not provided");
        if (!taxProfile.legalName) errors.push("Legal name missing");
        const countryConfig = await storage.getCountryTaxConfig(taxProfile.country);
        if (countryConfig && !countryConfig.taxDocumentsEnabled) {
          errors.push(`Tax documents are disabled for ${countryConfig.countryName} (${taxProfile.country})`);
        }
      }

      const mileageRecord = await storage.getDriverMileageForYear(driverId, year);
      if (!mileageRecord || parseFloat(mileageRecord.totalMilesOnline) === 0) {
        warnings.push("No mileage data for this year");
      }

      const computed = await computeTaxYearData(driverId, year);
      if (computed.tripCount === 0) {
        errors.push("No completed trips found for this tax year");
      }

      const canGenerate = errors.length === 0;
      return res.json({ canGenerate, errors, warnings, driverId, taxYear: year });
    } catch (error) {
      console.error("Error validating tax data:", error);
      return res.status(500).json({ message: "Failed to validate tax data" });
    }
  });

  // Admin: list all drivers with their tax generation status
  app.get("/api/admin/tax/drivers/:year", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const year = parseInt(req.params.year);
      if (isNaN(year)) return res.status(400).json({ message: "Invalid year" });

      const allDriverProfiles = await db.select().from(driverProfiles);
      const summaries = await storage.getAllTaxYearSummariesForYear(year);
      const summaryMap = new Map(summaries.map(s => [s.driverUserId, s]));

      const drivers = allDriverProfiles.map(dp => {
        const summary = summaryMap.get(dp.userId);
        return {
          driverId: dp.userId,
          driverName: dp.fullName,
          country: dp.countryCode || "NG",
          status: summary?.status || "not_generated",
          totalGrossEarnings: summary ? parseFloat(summary.totalGrossEarnings) : null,
          reportableIncome: summary ? parseFloat(summary.reportableIncome) : null,
          generatedAt: summary?.generatedAt || null,
        };
      });

      return res.json(drivers);
    } catch (error) {
      console.error("Error fetching tax drivers:", error);
      return res.status(500).json({ message: "Failed to fetch driver list" });
    }
  });

  // Admin: generate/regenerate tax summary from source data
  app.post("/api/admin/tax/generate/:driverId/:year", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const driverId = req.params.driverId;
      const year = parseInt(req.params.year);
      if (isNaN(year)) return res.status(400).json({ message: "Invalid year" });

      const existingSummary = await storage.getDriverTaxYearSummary(driverId, year);
      if (existingSummary && (existingSummary.status === "finalized" || existingSummary.status === "issued")) {
        return res.status(400).json({ message: "Cannot regenerate finalized or issued summary. Create a new generation cycle." });
      }

      const computed = await computeTaxYearData(driverId, year);
      const summary = await storage.upsertDriverTaxYearSummary({
        driverUserId: driverId,
        taxYear: year,
        totalGrossEarnings: computed.totalGrossEarnings.toFixed(2),
        totalTips: computed.totalTips.toFixed(2),
        totalIncentives: computed.totalIncentives.toFixed(2),
        totalPlatformFees: computed.totalPlatformFees.toFixed(2),
        totalMilesDriven: computed.totalMilesDriven.toFixed(2),
        reportableIncome: computed.reportableIncome.toFixed(2),
        currency: computed.currency,
        status: "draft",
        generatedBy: adminId,
      });

      await storage.logTaxGenerationEvent(driverId, year, "generated", adminId, `Summary generated from ${computed.tripCount} trips`);
      return res.json(summary);
    } catch (error: any) {
      console.error("Error generating tax summary:", error);
      return res.status(500).json({ message: error.message || "Failed to generate tax summary" });
    }
  });

  // Admin: finalize tax summary (locks it from changes)
  app.post("/api/admin/tax/finalize/:driverId/:year", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const driverId = req.params.driverId;
      const year = parseInt(req.params.year);
      if (isNaN(year)) return res.status(400).json({ message: "Invalid year" });

      const summary = await storage.finalizeTaxYearSummary(driverId, year, adminId);
      await storage.logTaxGenerationEvent(driverId, year, "finalized", adminId);
      return res.json(summary);
    } catch (error: any) {
      console.error("Error finalizing tax summary:", error);
      return res.status(400).json({ message: error.message || "Failed to finalize tax summary" });
    }
  });

  // Admin: issue tax summary to driver
  app.post("/api/admin/tax/issue/:driverId/:year", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const driverId = req.params.driverId;
      const year = parseInt(req.params.year);
      if (isNaN(year)) return res.status(400).json({ message: "Invalid year" });

      const summary = await storage.issueTaxYearSummary(driverId, year, adminId);
      await storage.logTaxGenerationEvent(driverId, year, "issued", adminId);

      const taxProfile = await storage.getDriverTaxProfile(driverId);
      const driverCountry = taxProfile?.country || "NG";
      const countryConfig = await storage.getCountryTaxConfig(driverCountry);
      const docType = (countryConfig?.documentType === "1099" ? "1099" : 
                       countryConfig?.documentType === "country_equivalent" ? "country_equivalent" : "annual_statement") as "1099" | "annual_statement" | "country_equivalent";
      const doc = await storage.createTaxDocument({
        driverUserId: driverId,
        taxYear: year,
        documentType: docType,
        fileUrl: `/api/driver/statements/annual/${year}/download?format=pdf`,
        generatedBy: adminId,
      });

      await storage.logTaxGenerationEvent(driverId, year, "document_created", adminId, `Document ${doc.id} v${doc.version} type=${docType}`);

      try {
        await notificationService.notifyUser(driverId, {
          type: "system",
          title: `Tax Document Available`,
          message: `Your ${year} annual tax statement is now available for download in your Statements section.`,
          role: "driver",
        });
      } catch (notifyErr) {
        console.warn("Failed to notify driver of tax document:", notifyErr);
      }

      return res.json({ summary, document: doc });
    } catch (error: any) {
      console.error("Error issuing tax summary:", error);
      return res.status(400).json({ message: error.message || "Failed to issue tax summary" });
    }
  });

  // Admin: view driver tax summary (read-only)
  app.get("/api/admin/tax/summary/:driverId/:year", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const driverId = req.params.driverId;
      const year = parseInt(req.params.year);
      if (isNaN(year)) return res.status(400).json({ message: "Invalid year" });

      const summary = await storage.getDriverTaxYearSummary(driverId, year);
      const taxProfile = await storage.getDriverTaxProfile(driverId);
      const docs = await storage.getDriverTaxDocuments(driverId, year);
      const auditLogs = await storage.getTaxAuditLogs(driverId, year);

      if (!summary) {
        const computed = await computeTaxYearData(driverId, year);
        return res.json({
          stored: false,
          driverId,
          taxYear: year,
          taxProfile: taxProfile ? { ...taxProfile, taxId: taxProfile.taxId ? "****" : null } : null,
          ...computed,
          status: "not_generated",
          documents: docs,
          auditLogs,
        });
      }

      return res.json({
        stored: true,
        driverId,
        taxYear: year,
        taxProfile: taxProfile ? { ...taxProfile, taxId: taxProfile.taxId ? "****" : null } : null,
        totalGrossEarnings: parseFloat(summary.totalGrossEarnings),
        totalTips: parseFloat(summary.totalTips),
        totalIncentives: parseFloat(summary.totalIncentives),
        totalPlatformFees: parseFloat(summary.totalPlatformFees),
        totalMilesDriven: parseFloat(summary.totalMilesDriven),
        reportableIncome: parseFloat(summary.reportableIncome),
        currency: summary.currency,
        status: summary.status,
        generatedAt: summary.generatedAt,
        generatedBy: summary.generatedBy,
        finalizedAt: summary.finalizedAt,
        finalizedBy: summary.finalizedBy,
        documents: docs,
        auditLogs,
      });
    } catch (error) {
      console.error("Error fetching admin tax summary:", error);
      return res.status(500).json({ message: "Failed to fetch tax summary" });
    }
  });

  // Admin: list all tax summaries for a year (for compliance download)
  app.get("/api/admin/tax/summaries/:year", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const year = parseInt(req.params.year);
      if (isNaN(year)) return res.status(400).json({ message: "Invalid year" });

      const summaries = await storage.getAllTaxYearSummariesForYear(year);
      return res.json(summaries.map(s => ({
        driverUserId: s.driverUserId,
        taxYear: s.taxYear,
        totalGrossEarnings: parseFloat(s.totalGrossEarnings),
        totalPlatformFees: parseFloat(s.totalPlatformFees),
        totalMilesDriven: parseFloat(s.totalMilesDriven),
        reportableIncome: parseFloat(s.reportableIncome),
        currency: s.currency,
        status: s.status,
        generatedAt: s.generatedAt,
      })));
    } catch (error) {
      console.error("Error fetching tax summaries:", error);
      return res.status(500).json({ message: "Failed to fetch tax summaries" });
    }
  });

  // Admin: bulk export tax summaries as CSV (spec-compliant format)
  app.get("/api/admin/tax/export/:year", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const year = parseInt(req.params.year);
      if (isNaN(year)) return res.status(400).json({ message: "Invalid year" });

      const summaries = await storage.getAllTaxYearSummariesForYear(year);
      const rows: TaxDocumentData[] = [];

      for (const s of summaries) {
        const taxProfile = await storage.getDriverTaxProfile(s.driverUserId);
        const driverProfile = await storage.getDriverProfile(s.driverUserId);
        const ge = parseFloat(s.totalGrossEarnings);
        const ti = parseFloat(s.totalTips);
        const inc = parseFloat(s.totalIncentives);
        rows.push({
          driverId: s.driverUserId,
          legalName: taxProfile?.legalName || driverProfile?.fullName || "Driver",
          country: taxProfile?.country || "NG",
          taxClassification: taxProfile?.taxClassification || "independent_contractor",
          maskedTaxId: (await import("./crypto")).maskTaxId(taxProfile?.taxId || null),
          taxYear: s.taxYear,
          documentVersion: 1,
          issueDate: new Date().toISOString().split("T")[0],
          totalGrossEarnings: ge,
          totalTripEarnings: Math.round((ge - ti - inc) * 100) / 100,
          totalTips: ti,
          totalIncentives: inc,
          totalPlatformFees: parseFloat(s.totalPlatformFees),
          totalMilesDriven: parseFloat(s.totalMilesDriven),
          reportableIncome: parseFloat(s.reportableIncome),
          currency: s.currency,
        });
      }

      const csv = generateBulkTaxCSV(rows);
      res.setHeader("Content-Type", "text/csv; charset=utf-8");
      res.setHeader("Content-Disposition", `attachment; filename="ziba-tax-summaries-${year}.csv"`);
      return res.send(csv);
    } catch (error) {
      console.error("Error exporting tax summaries:", error);
      return res.status(500).json({ message: "Failed to export tax summaries" });
    }
  });

  // Admin: download individual driver tax document as PDF or CSV
  app.get("/api/admin/tax/download/:driverId/:year", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const driverId = req.params.driverId;
      const year = parseInt(req.params.year);
      const format = (req.query.format || "pdf").toLowerCase();
      const docType = (req.query.type || "annual_statement") as string;

      if (isNaN(year)) return res.status(400).json({ message: "Invalid year" });

      const docData = await buildTaxDocumentData(driverId, year);
      const rules = await getCountryTaxRules(docData.country);

      if (format === "csv") {
        const csv = generateTaxCSV(docData);
        res.setHeader("Content-Type", "text/csv; charset=utf-8");
        res.setHeader("Content-Disposition", `attachment; filename="ziba-tax-${driverId.substring(0, 8)}-${year}.csv"`);
        return res.send(csv);
      }

      const pdfDoc = generateTaxPDF(docData, rules.documentType, rules);
      res.setHeader("Content-Type", "application/pdf");
      res.setHeader("Content-Disposition", `attachment; filename="ziba-tax-${driverId.substring(0, 8)}-${year}.pdf"`);
      pdfDoc.pipe(res);
      pdfDoc.end();
    } catch (error) {
      console.error("Error downloading admin tax document:", error);
      return res.status(500).json({ message: "Failed to download tax document" });
    }
  });

  // Admin: view audit log for a driver's tax year
  app.get("/api/admin/tax/audit/:driverId/:year", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const driverId = req.params.driverId;
      const year = parseInt(req.params.year);
      if (isNaN(year)) return res.status(400).json({ message: "Invalid year" });

      const logs = await storage.getTaxAuditLogs(driverId, year);
      return res.json(logs);
    } catch (error) {
      console.error("Error fetching tax audit logs:", error);
      return res.status(500).json({ message: "Failed to fetch audit logs" });
    }
  });

  // ============================================================
  // COUNTRY TAX COMPLIANCE CONFIGURATION (Admin)
  // ============================================================

  app.get("/api/admin/tax/country-configs", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const configs = await storage.getAllCountryTaxConfigs();
      return res.json(configs);
    } catch (error) {
      console.error("Error fetching country tax configs:", error);
      return res.status(500).json({ message: "Failed to fetch country tax configurations" });
    }
  });

  app.get("/api/admin/tax/country-configs/:countryCode", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const config = await storage.getCountryTaxConfig(req.params.countryCode);
      if (!config) return res.status(404).json({ message: "No tax configuration found for this country" });
      return res.json(config);
    } catch (error) {
      console.error("Error fetching country tax config:", error);
      return res.status(500).json({ message: "Failed to fetch country tax configuration" });
    }
  });

  app.post("/api/admin/tax/country-configs", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const config = await storage.upsertCountryTaxConfig(req.body);
      return res.json(config);
    } catch (error) {
      console.error("Error saving country tax config:", error);
      return res.status(500).json({ message: "Failed to save country tax configuration" });
    }
  });

  app.delete("/api/admin/tax/country-configs/:countryCode", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      await storage.deleteCountryTaxConfig(req.params.countryCode);
      return res.json({ success: true });
    } catch (error) {
      console.error("Error deleting country tax config:", error);
      return res.status(500).json({ message: "Failed to delete country tax configuration" });
    }
  });

  // ============================================================
  // MILEAGE TRACKING (TAX COMPLIANCE ONLY)
  // Anti-fraud constants
  const MAX_SPEED_MPH = 120;
  const MAX_MILES_PER_UPDATE = 5;
  const MIN_UPDATE_INTERVAL_MS = 5000;
  // ============================================================

  function haversineDistanceMiles(lat1: number, lng1: number, lat2: number, lng2: number): number {
    const R = 3958.8;
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLng = (lng2 - lng1) * Math.PI / 180;
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
      Math.sin(dLng / 2) * Math.sin(dLng / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  app.post("/api/driver/mileage/session/start", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { sessionId, lat, lng } = req.body;

      if (!sessionId || typeof sessionId !== "string") {
        return res.status(400).json({ message: "sessionId is required" });
      }

      const session = await storage.startMileageSession(userId, sessionId, lat, lng);
      return res.json({ sessionId: session.sessionId, status: session.status });
    } catch (error) {
      console.error("Error starting mileage session:", error);
      return res.status(500).json({ message: "Failed to start mileage session" });
    }
  });

  app.post("/api/driver/mileage/session/update", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { sessionId, lat, lng } = req.body;

      if (!sessionId || typeof lat !== "number" || typeof lng !== "number") {
        return res.status(400).json({ message: "sessionId, lat, lng required" });
      }

      if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
        return res.status(400).json({ message: "Invalid GPS coordinates" });
      }

      const activeSession = await storage.getActiveMileageSession(userId);
      if (!activeSession || activeSession.sessionId !== sessionId) {
        return res.status(404).json({ message: "No active session found" });
      }

      let milesDelta = 0;
      if (activeSession.lastLat && activeSession.lastLng) {
        const prevLat = parseFloat(activeSession.lastLat);
        const prevLng = parseFloat(activeSession.lastLng);

        const rawDistance = haversineDistanceMiles(prevLat, prevLng, lat, lng);

        if (rawDistance > MAX_MILES_PER_UPDATE) {
          console.warn(`[MILEAGE ANTI-FRAUD] GPS jump detected for driver ${userId}: ${rawDistance.toFixed(2)} mi, session ${sessionId}`);
          return res.json({ 
            sessionId, 
            totalMilesAccumulated: activeSession.totalMilesAccumulated,
            warning: "GPS jump ignored" 
          });
        }

        if (activeSession.lastUpdateAt) {
          const timeDeltaMs = Date.now() - new Date(activeSession.lastUpdateAt).getTime();
          if (timeDeltaMs < MIN_UPDATE_INTERVAL_MS) {
            return res.json({ 
              sessionId, 
              totalMilesAccumulated: activeSession.totalMilesAccumulated,
              warning: "Update too frequent" 
            });
          }
          const timeDeltaHours = timeDeltaMs / (1000 * 60 * 60);
          if (timeDeltaHours > 0) {
            const speedMph = rawDistance / timeDeltaHours;
            if (speedMph > MAX_SPEED_MPH) {
              console.warn(`[MILEAGE ANTI-FRAUD] Unrealistic speed ${speedMph.toFixed(0)} mph for driver ${userId}, session ${sessionId}`);
              return res.json({ 
                sessionId, 
                totalMilesAccumulated: activeSession.totalMilesAccumulated,
                warning: "Speed threshold exceeded" 
              });
            }
          }
        }

        milesDelta = rawDistance;
      }

      const updated = await storage.updateMileageSession(userId, sessionId, lat, lng, milesDelta);
      return res.json({
        sessionId,
        totalMilesAccumulated: updated?.totalMilesAccumulated || "0.00",
      });
    } catch (error) {
      console.error("Error updating mileage session:", error);
      return res.status(500).json({ message: "Failed to update mileage session" });
    }
  });

  app.post("/api/driver/mileage/session/end", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { sessionId } = req.body;

      if (!sessionId) {
        return res.status(400).json({ message: "sessionId is required" });
      }

      const session = await storage.endMileageSession(userId, sessionId);
      if (!session) {
        return res.status(404).json({ message: "No active session found" });
      }

      return res.json({
        sessionId: session.sessionId,
        totalMilesAccumulated: session.totalMilesAccumulated,
        status: session.status,
      });
    } catch (error) {
      console.error("Error ending mileage session:", error);
      return res.status(500).json({ message: "Failed to end mileage session" });
    }
  });

  app.post("/api/driver/mileage/report", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { miles, source } = req.body;

      if (typeof miles !== "number" || miles <= 0 || miles > 500) {
        return res.status(400).json({ message: "Invalid mileage value" });
      }

      const validSource = source === "enroute" ? "enroute" : "trip";
      const taxYear = new Date().getFullYear();
      const record = await storage.addDriverMileage(userId, taxYear, miles, validSource as "trip" | "enroute");
      return res.json({ totalMilesOnline: record.totalMilesOnline, taxYear });
    } catch (error) {
      console.error("Error reporting driver mileage:", error);
      return res.status(500).json({ message: "Failed to report mileage" });
    }
  });

  app.get("/api/driver/mileage/:year", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const year = parseInt(req.params.year);
      if (isNaN(year)) return res.status(400).json({ message: "Invalid year" });

      const record = await storage.getDriverMileageForYear(userId, year);
      return res.json({
        taxYear: year,
        totalMilesOnline: record ? parseFloat(record.totalMilesOnline) : 0,
        totalTripMiles: record ? parseFloat(record.totalTripMiles) : 0,
        totalEnrouteMiles: record ? parseFloat(record.totalEnrouteMiles) : 0,
        lastUpdatedAt: record?.lastUpdatedAt || null,
      });
    } catch (error) {
      console.error("Error fetching driver mileage:", error);
      return res.status(500).json({ message: "Failed to fetch mileage" });
    }
  });

  // Admin compliance: read-only mileage views
  app.get("/api/admin/mileage/driver/:driverId/:year", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const driverId = req.params.driverId;
      const year = parseInt(req.params.year);
      if (isNaN(year)) return res.status(400).json({ message: "Invalid year" });

      const yearlyRecord = await storage.getDriverMileageForYear(driverId, year);
      const startOfYear = new Date(year, 0, 1);
      const endOfYear = new Date(year + 1, 0, 1);
      const dailyRecords = await storage.getDriverMileageDailyRecords(driverId, startOfYear, endOfYear);

      return res.json({
        driverId,
        taxYear: year,
        totalMilesOnline: yearlyRecord ? parseFloat(yearlyRecord.totalMilesOnline) : 0,
        totalTripMiles: yearlyRecord ? parseFloat(yearlyRecord.totalTripMiles) : 0,
        totalEnrouteMiles: yearlyRecord ? parseFloat(yearlyRecord.totalEnrouteMiles) : 0,
        lastUpdatedAt: yearlyRecord?.lastUpdatedAt || null,
        dailyRecordCount: dailyRecords.length,
        dailyRecords: dailyRecords.map(r => ({
          date: r.date,
          milesDriven: parseFloat(r.milesDriven),
          source: r.source,
        })),
      });
    } catch (error) {
      console.error("Error fetching admin mileage:", error);
      return res.status(500).json({ message: "Failed to fetch mileage data" });
    }
  });

  app.get("/api/admin/mileage/export/:year", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const year = parseInt(req.params.year);
      if (isNaN(year)) return res.status(400).json({ message: "Invalid year" });

      const allRecords = await storage.getAllDriverMileageYearlySummaries();
      const yearRecords = allRecords.filter(r => r.taxYear === year);

      const csvLines = [
        `Driver ID,Tax Year,Total Miles Online,Trip Miles,En-Route Miles,Last Updated`,
        ...yearRecords.map(r =>
          `${r.driverUserId},${r.taxYear},${parseFloat(r.totalMilesOnline).toFixed(2)},${parseFloat(r.totalTripMiles).toFixed(2)},${parseFloat(r.totalEnrouteMiles).toFixed(2)},${r.lastUpdatedAt?.toISOString() || ""}`
        ),
      ];

      res.setHeader("Content-Type", "text/csv");
      res.setHeader("Content-Disposition", `attachment; filename="mileage-audit-${year}.csv"`);
      return res.send(csvLines.join("\n"));
    } catch (error) {
      console.error("Error exporting mileage data:", error);
      return res.status(500).json({ message: "Failed to export mileage data" });
    }
  });

  // =============================================
  // SIMULATION CENTER
  // =============================================

  // System-level simulation status (public  no auth required)
  app.get("/api/simulation/system-status", (_req: any, res) => {
    const config = getSimulationConfig();
    return res.json({
      enabled: config.enabled,
      codeLength: config.codeLength,
      expiresMinutes: config.expiresMinutes,
    });
  });

  // Simulation guard middleware  blocks all simulation features if disabled
  const requireSimulationEnabled: RequestHandler = (_req, res, next) => {
    try {
      assertSimulationEnabled();
      next();
    } catch (err) {
      if (err instanceof SimulationDisabledError) {
        return res.status(403).json({ message: err.message });
      }
      next(err);
    }
  };

  // Admin: Create simulation code
  app.post("/api/admin/simulation/codes", isAuthenticated, requireSimulationEnabled, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { role, countryCode, city, driverTier, walletBalance, ratingState, cashEnabled, reusable, expiresInHours } = req.body;

      if (!role || !["rider", "driver", "director", "admin"].includes(role)) {
        return res.status(400).json({ message: "Valid role required (rider, driver, director, admin)" });
      }

      const { codeLength } = getSimulationConfig();
      const min = Math.pow(10, codeLength - 1);
      const max = Math.pow(10, codeLength) - 1;
      const code = String(Math.floor(min + Math.random() * (max - min + 1)));

      const hours = expiresInHours || 24;
      const expiresAt = new Date(Date.now() + hours * 60 * 60 * 1000);

      const simCode = await storage.createSimulationCode({
        code,
        role,
        countryCode: countryCode || "NG",
        city: city || null,
        driverTier: driverTier || null,
        walletBalance: walletBalance || "0.00",
        ratingState: ratingState || "4.50",
        cashEnabled: cashEnabled !== false,
        reusable: reusable === true,
        expiresAt,
        createdBy: userId,
      });

      return res.json(simCode);
    } catch (error) {
      console.error("Error creating simulation code:", error);
      return res.status(500).json({ message: "Failed to create simulation code" });
    }
  });

  // Admin: List all simulation codes
  app.get("/api/admin/simulation/codes", isAuthenticated, requireSimulationEnabled, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const codes = await storage.getAllSimulationCodes();
      return res.json(codes);
    } catch (error) {
      console.error("Error fetching simulation codes:", error);
      return res.status(500).json({ message: "Failed to fetch simulation codes" });
    }
  });

  // Admin: Revoke simulation code
  app.post("/api/admin/simulation/codes/:id/revoke", isAuthenticated, requireSimulationEnabled, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) return res.status(400).json({ message: "Invalid code ID" });
      await storage.revokeSimulationCode(id);
      return res.json({ success: true });
    } catch (error) {
      console.error("Error revoking simulation code:", error);
      return res.status(500).json({ message: "Failed to revoke simulation code" });
    }
  });

  // Admin: List all simulation sessions
  app.get("/api/admin/simulation/sessions", isAuthenticated, requireSimulationEnabled, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const sessions = await storage.getAllSimulationSessions();
      return res.json(sessions);
    } catch (error) {
      console.error("Error fetching simulation sessions:", error);
      return res.status(500).json({ message: "Failed to fetch simulation sessions" });
    }
  });

  // Admin: End a simulation session
  app.post("/api/admin/simulation/sessions/:id/end", isAuthenticated, requireSimulationEnabled, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) return res.status(400).json({ message: "Invalid session ID" });
      await storage.endSimulationSession(id);
      return res.json({ success: true });
    } catch (error) {
      console.error("Error ending simulation session:", error);
      return res.status(500).json({ message: "Failed to end simulation session" });
    }
  });

  // Public: Validate simulation code (no auth required  this is the entry point)
  app.post("/api/simulation/validate", requireSimulationEnabled, async (req: any, res) => {
    try {
      const { code } = req.body;
      if (!code) return res.status(400).json({ message: "Simulation code required" });

      const simCode = await storage.getSimulationCode(code.trim());
      if (!simCode) return res.status(404).json({ message: "Invalid simulation code" });

      if (simCode.revokedAt) return res.status(410).json({ message: "This simulation code has been revoked" });
      if (new Date(simCode.expiresAt) < new Date()) return res.status(410).json({ message: "This simulation code has expired" });
      if (simCode.used && !simCode.reusable) return res.status(410).json({ message: "This simulation code has already been used" });

      return res.json({
        valid: true,
        role: simCode.role,
        countryCode: simCode.countryCode,
        city: simCode.city,
        cashEnabled: simCode.cashEnabled,
      });
    } catch (error) {
      console.error("Error validating simulation code:", error);
      return res.status(500).json({ message: "Failed to validate code" });
    }
  });

  app.post("/api/simulation/enter-direct", requireSimulationEnabled, async (req: any, res) => {
    try {
      const { code } = req.body;
      if (!code) return res.status(400).json({ message: "Simulation code required" });

      const simCode = await storage.getSimulationCode(code.trim());
      if (!simCode) return res.status(404).json({ message: "Invalid simulation code" });
      if (simCode.revokedAt) return res.status(410).json({ message: "This simulation code has been revoked" });
      if (new Date(simCode.expiresAt) < new Date()) return res.status(410).json({ message: "This simulation code has expired" });
      if (simCode.used && !simCode.reusable) return res.status(410).json({ message: "This simulation code has already been used" });

      const simUserId = `sim-${simCode.role}-${Date.now()}`;
      const simEmail = `${simCode.role}_sim_${code}@ziba.test`;
      const roleNames: Record<string, string> = { driver: "Driver", rider: "Rider", admin: "Admin", director: "Director" };
      const simFirstName = "Simulation";
      const simLastName = roleNames[simCode.role] || "User";

      if (!simCode.reusable) {
        await storage.markSimulationCodeUsed(simCode.id);
      }

      const sessionExpiry = new Date(simCode.expiresAt);
      const config = JSON.stringify({
        city: simCode.city,
        driverTier: simCode.driverTier,
        walletBalance: simCode.walletBalance,
        ratingState: simCode.ratingState,
        cashEnabled: simCode.cashEnabled,
      });

      const session = await storage.createSimulationSession({
        codeId: simCode.id,
        userId: simUserId,
        role: simCode.role,
        countryCode: simCode.countryCode,
        config,
        active: true,
        expiresAt: sessionExpiry,
      });

      const sessionData = req.session as any;
      sessionData.simulationActive = true;
      sessionData.simulatedUserId = simUserId;
      sessionData.simulatedEmail = simEmail;
      sessionData.simulatedFirstName = simFirstName;
      sessionData.simulatedLastName = simLastName;
      sessionData.simulatedRole = simCode.role;
      sessionData.simulatedCountryCode = simCode.countryCode;
      sessionData.simulationSessionId = session.id;

      req.session.save((err: any) => {
        if (err) {
          console.error("Error saving simulation session:", err);
          return res.status(500).json({ message: "Failed to save simulation session" });
        }
        return res.json({
          sessionId: session.id,
          role: simCode.role,
          countryCode: simCode.countryCode,
          config: JSON.parse(config),
          expiresAt: sessionExpiry,
          simulatedUser: {
            id: simUserId,
            email: simEmail,
            firstName: simFirstName,
            lastName: simLastName,
          },
        });
      });
    } catch (error) {
      console.error("Error entering direct simulation:", error);
      return res.status(500).json({ message: "Failed to enter simulation" });
    }
  });

  // Auth'd: Enter simulation mode (for already logged-in users)
  app.post("/api/simulation/enter", isAuthenticated, requireSimulationEnabled, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { code } = req.body;
      if (!code) return res.status(400).json({ message: "Simulation code required" });

      const simCode = await storage.getSimulationCode(code.trim());
      if (!simCode) return res.status(404).json({ message: "Invalid simulation code" });
      if (simCode.revokedAt) return res.status(410).json({ message: "This simulation code has been revoked" });
      if (new Date(simCode.expiresAt) < new Date()) return res.status(410).json({ message: "This simulation code has expired" });
      if (simCode.used && !simCode.reusable) return res.status(410).json({ message: "This simulation code has already been used" });

      // Check if user already has an active simulation
      const existing = await storage.getActiveSimulationSession(userId);
      if (existing) {
        await storage.endSimulationSession(existing.id);
      }

      // Mark code used
      if (!simCode.reusable) {
        await storage.markSimulationCodeUsed(simCode.id);
      }

      const sessionExpiry = new Date(simCode.expiresAt);

      const session = await storage.createSimulationSession({
        codeId: simCode.id,
        userId,
        role: simCode.role,
        countryCode: simCode.countryCode,
        config: JSON.stringify({
          city: simCode.city,
          driverTier: simCode.driverTier,
          walletBalance: simCode.walletBalance,
          ratingState: simCode.ratingState,
          cashEnabled: simCode.cashEnabled,
        }),
        active: true,
        expiresAt: sessionExpiry,
      });

      return res.json({
        sessionId: session.id,
        role: simCode.role,
        countryCode: simCode.countryCode,
        config: JSON.parse(session.config || "{}"),
        expiresAt: sessionExpiry,
      });
    } catch (error) {
      console.error("Error entering simulation:", error);
      return res.status(500).json({ message: "Failed to enter simulation" });
    }
  });

  app.get("/api/simulation/status", requireSimulationEnabled, async (req: any, res) => {
    try {
      const sessionData = req.session as any;
      if (sessionData?.simulationActive && sessionData?.simulatedUserId) {
        const simSessionId = sessionData.simulationSessionId;
        if (simSessionId) {
          const session = await storage.getSimulationSessionById?.(simSessionId);
          if (session && session.active && new Date(session.expiresAt) > new Date()) {
            return res.json({
              active: true,
              sessionId: session.id,
              role: session.role,
              countryCode: session.countryCode,
              config: JSON.parse(session.config || "{}"),
              expiresAt: session.expiresAt,
            });
          }
          if (session && (new Date(session.expiresAt) <= new Date() || !session.active)) {
            delete sessionData.simulationActive;
            delete sessionData.simulatedUserId;
            delete sessionData.simulatedEmail;
            delete sessionData.simulatedRole;
            delete sessionData.simulatedCountryCode;
            delete sessionData.simulationSessionId;
          }
        }
        if (sessionData.simulationActive) {
          return res.json({
            active: true,
            sessionId: sessionData.simulationSessionId,
            role: sessionData.simulatedRole,
            countryCode: sessionData.simulatedCountryCode,
            config: {},
            expiresAt: null,
          });
        }
      }

      if (req.isAuthenticated && req.isAuthenticated()) {
        const userId = (req.user as any)?.claims?.sub;
        if (userId) {
          const session = await storage.getActiveSimulationSession(userId);
          if (!session || new Date(session.expiresAt) < new Date()) {
            if (session) await storage.endSimulationSession(session.id);
            return res.json({ active: false });
          }
          return res.json({
            active: true,
            sessionId: session.id,
            role: session.role,
            countryCode: session.countryCode,
            config: JSON.parse(session.config || "{}"),
            expiresAt: session.expiresAt,
          });
        }
      }

      return res.json({ active: false });
    } catch (error) {
      console.error("Error checking simulation status:", error);
      return res.status(500).json({ message: "Failed to check simulation status" });
    }
  });

  app.post("/api/simulation/exit", requireSimulationEnabled, async (req: any, res) => {
    try {
      const sessionData = req.session as any;

      if (sessionData?.simulationActive) {
        const simSessionId = sessionData.simulationSessionId;
        if (simSessionId) {
          await storage.endSimulationSession(simSessionId);
        }
        delete sessionData.simulationActive;
        delete sessionData.simulatedUserId;
        delete sessionData.simulatedEmail;
        delete sessionData.simulatedFirstName;
        delete sessionData.simulatedLastName;
        delete sessionData.simulatedRole;
        delete sessionData.simulatedCountryCode;
        delete sessionData.simulationSessionId;

        return req.session.save((err: any) => {
          if (err) console.error("Error saving session on exit:", err);
          return res.json({ success: true });
        });
      }

      if (req.isAuthenticated && req.isAuthenticated()) {
        const userId = (req.user as any)?.claims?.sub;
        if (userId) {
          const session = await storage.getActiveSimulationSession(userId);
          if (session) {
            await storage.endSimulationSession(session.id);
          }
        }
      }
      return res.json({ success: true });
    } catch (error) {
      console.error("Error exiting simulation:", error);
      return res.status(500).json({ message: "Failed to exit simulation" });
    }
  });

  // Simulation: Generate a simulated ride event for driver
  app.post("/api/simulation/generate-ride", isAuthenticated, requireSimulationEnabled, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const session = await storage.getActiveSimulationSession(userId);
      if (!session || session.role !== "driver") {
        return res.status(403).json({ message: "Active driver simulation required" });
      }

      const config = JSON.parse(session.config || "{}");
      const pickupLocations = [
        "Lagos Marina, Victoria Island",
        "Lekki Phase 1, Lagos",
        "Ikeja City Mall, Alausa",
        "Surulere Junction, Lagos",
        "Yaba Technology Hub",
        "Ajah Town Center",
        "Maryland Mall, Lagos",
        "Allen Avenue, Ikeja",
      ];
      const dropoffLocations = [
        "Banana Island, Ikoyi",
        "Computer Village, Ikeja",
        "Oshodi Terminal",
        "Apapa Port Complex",
        "National Theatre, Iganmu",
        "Third Mainland Bridge Plaza",
        "Festac Town Square",
        "Murtala Muhammed Airport",
      ];

      const pickup = pickupLocations[Math.floor(Math.random() * pickupLocations.length)];
      const dropoff = dropoffLocations[Math.floor(Math.random() * dropoffLocations.length)];
      const fare = (Math.floor(Math.random() * 4000) + 1000).toFixed(2);
      const paymentSource = config.cashEnabled && Math.random() > 0.5 ? "CASH" : "CARD";

      return res.json({
        simulated: true,
        rideRequest: {
          id: `sim-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
          pickupLocation: pickup,
          dropoffLocation: dropoff,
          fareAmount: fare,
          paymentSource,
          passengerCount: Math.floor(Math.random() * 3) + 1,
          riderName: "Simulated Rider",
          estimatedDuration: `${Math.floor(Math.random() * 30) + 10} min`,
          estimatedDistance: `${(Math.random() * 15 + 2).toFixed(1)} km`,
        },
      });
    } catch (error) {
      console.error("Error generating simulated ride:", error);
      return res.status(500).json({ message: "Failed to generate simulated ride" });
    }
  });

  // Simulation: Progress ride state (mock driver actions)
  app.post("/api/simulation/progress-ride", isAuthenticated, requireSimulationEnabled, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const session = await storage.getActiveSimulationSession(userId);
      if (!session) {
        return res.status(403).json({ message: "Active simulation required" });
      }

      const { currentState, rideId } = req.body;
      const stateFlow = ["accepted", "driver_en_route", "arrived", "waiting", "in_progress", "completed"];
      const currentIdx = stateFlow.indexOf(currentState);

      if (currentIdx < 0 || currentIdx >= stateFlow.length - 1) {
        return res.json({ simulated: true, rideId, state: "completed", message: "Ride simulation complete" });
      }

      const nextState = stateFlow[currentIdx + 1];
      const delays: Record<string, number> = {
        driver_en_route: 3,
        arrived: 5,
        waiting: 2,
        in_progress: 8,
        completed: 0,
      };

      return res.json({
        simulated: true,
        rideId,
        previousState: currentState,
        state: nextState,
        estimatedSeconds: delays[nextState] || 3,
        message: nextState === "completed"
          ? "Trip completed! Earnings have been simulated."
          : `Moving to: ${nextState.replace(/_/g, " ")}`,
      });
    } catch (error) {
      console.error("Error progressing simulated ride:", error);
      return res.status(500).json({ message: "Failed to progress ride" });
    }
  });

  // Simulation: Generate rider ride request (simulated driver assignment)
  app.post("/api/simulation/rider-request", isAuthenticated, requireSimulationEnabled, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const session = await storage.getActiveSimulationSession(userId);
      if (!session || session.role !== "rider") {
        return res.status(403).json({ message: "Active rider simulation required" });
      }

      const { pickup, dropoff, paymentMethod } = req.body;
      const fare = (Math.floor(Math.random() * 4000) + 1000).toFixed(2);

      return res.json({
        simulated: true,
        ride: {
          id: `sim-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
          status: "accepted",
          pickupLocation: pickup || "Simulated Pickup",
          dropoffLocation: dropoff || "Simulated Dropoff",
          fareAmount: fare,
          paymentSource: paymentMethod || "CARD",
          driverName: "Simulated Driver",
          driverRating: "4.8",
          vehicleMake: "Toyota",
          vehicleModel: "Camry",
          licensePlate: "SIM-001",
          estimatedArrival: `${Math.floor(Math.random() * 10) + 3} min`,
        },
      });
    } catch (error) {
      console.error("Error generating rider simulation:", error);
      return res.status(500).json({ message: "Failed to generate rider ride" });
    }
  });

  // Simulation cleanup scheduler  runs every minute
  setInterval(async () => {
    try {
      const cleaned = await storage.cleanupExpiredSimulations();
      if (cleaned > 0) {
        console.log(`[SIMULATION] Cleaned up ${cleaned} expired simulation sessions`);
      }
    } catch (error) {
      console.error("[SIMULATION SCHEDULER] Error:", error);
    }
  }, 60 * 1000);

  // Cash Settlement Ledger Scheduler  runs every hour
  const SETTLEMENT_INTERVAL = 60 * 60 * 1000;
  setInterval(async () => {
    try {
      const pendingLedgers = await storage.getAllPendingLedgers();
      const now = new Date();
      for (const ledger of pendingLedgers) {
        if (new Date(ledger.periodEnd) < now) {
          const abuseFlags = await storage.getDriverCashAbuseFlags(ledger.driverId);
          if (abuseFlags.flagged) {
            await storage.deferLedgerEntry(ledger.id, "Auto-deferred: abuse flag triggered");
            console.log(`[SETTLEMENT] Deferred ledger ${ledger.id} for driver ${ledger.driverId} - abuse flag`);
          } else {
            await storage.executePeriodSettlement(ledger.id, "card_trip_offset");
            console.log(`[SETTLEMENT] Settled ledger ${ledger.id} for driver ${ledger.driverId}`);
          }
        }
      }
    } catch (error) {
      console.error("[SETTLEMENT SCHEDULER] Error:", error);
    }
  }, SETTLEMENT_INTERVAL);
  console.log("[SETTLEMENT SCHEDULER] Started  polling every 60min for period settlements");

  // =============================================
  // DIRECTOR COMMISSION DAILY SCHEDULER
  // =============================================
  const COMMISSION_INTERVAL = 60 * 60 * 1000;
  let lastCommissionRunDate = "";

  setInterval(async () => {
    try {
      const todayStr = new Date().toISOString().slice(0, 10);
      if (lastCommissionRunDate === todayStr) return;

      const allDirectors = await db.select().from(directorProfiles);
      if (allDirectors.length === 0) return;

      const settings = await storage.getDirectorCommissionSettings();
      const globalActiveRatio = parseFloat(settings?.activeRatio || "0.77");
      const globalMaxCommissionable = settings?.maxCommissionableDrivers || 1000;

      const today = new Date();
      today.setHours(0, 0, 0, 0);

      for (const director of allDirectors) {
        try {
          const isActive = director.status === "active" && director.lifecycleStatus === "active";
          const withinLifespan = (!director.lifespanStartDate || new Date(director.lifespanStartDate) <= today) &&
            (!director.lifespanEndDate || new Date(director.lifespanEndDate) >= today);
          const notFrozen = !director.commissionFrozen;
          const eligible = isActive && withinLifespan && notFrozen;

          const directorStatus = !isActive ? "inactive" : !withinLifespan ? "expired" : director.commissionFrozen ? "frozen" : "active";

          const assignments = await storage.getDriversUnderDirector(director.userId);
          const driverIds = assignments.map(a => a.driverUserId);
          const totalDrivers = driverIds.length;

          const meetsThreshold = totalDrivers >= (director.activationThreshold || 10);

          let activeDriversToday = 0;
          const activeDriverIds: string[] = [];
          for (const driverId of driverIds) {
            const [tripToday] = await db.select({ count: count() }).from(trips)
              .where(and(eq(trips.driverId, driverId), eq(trips.status, "completed"), gte(trips.completedAt, today)));
            if (tripToday && tripToday.count > 0) {
              activeDriversToday++;
              activeDriverIds.push(driverId);
            }
          }

          const commissionRate = (director.commissionRatePercent || 12) / 100;
          const maxCommissionable = director.maxCommissionablePerDay || globalMaxCommissionable;
          const commissionableDrivers = Math.min(Math.floor(activeDriversToday * globalActiveRatio), maxCommissionable);

          let platformEarnings = 0;
          if (eligible && meetsThreshold && commissionableDrivers > 0) {
            const commissionableIds = activeDriverIds.slice(0, commissionableDrivers);
            for (const driverId of commissionableIds) {
              const driverTrips = await db.select().from(trips)
                .where(and(
                  eq(trips.driverId, driverId),
                  eq(trips.status, "completed"),
                  gte(trips.completedAt, today)
                ));
              for (const trip of driverTrips) {
                platformEarnings += parseFloat(String(trip.commissionAmount || "0"));
              }
            }
          }

          const commissionAmount = eligible && meetsThreshold ? platformEarnings * commissionRate : 0;

          await storage.logDirectorDailyCommission({
            directorUserId: director.userId,
            date: todayStr,
            totalDrivers,
            activeDriversToday,
            commissionableDrivers,
            commissionRate: String(commissionRate),
            activeRatio: String(globalActiveRatio),
            platformEarnings: platformEarnings.toFixed(2),
            commissionAmount: commissionAmount.toFixed(2),
            directorStatus,
            meetsActivationThreshold: meetsThreshold,
          });

          if (eligible && meetsThreshold) {
            const capUsage = commissionableDrivers / maxCommissionable;
            if (capUsage >= 0.9) {
              await db.insert(directorActionLogs).values({
                actorId: "system",
                actorRole: "system",
                action: "zibra_cap_warning",
                targetType: "director",
                targetId: director.userId,
                afterState: JSON.stringify({
                  commissionableDrivers,
                  maxCommissionable,
                  capUsage: (capUsage * 100).toFixed(1) + "%",
                }),
              });
            }
          }
        } catch (dirError) {
          console.error(`[COMMISSION SCHEDULER] Error for director ${director.userId}:`, dirError);
        }
      }

      lastCommissionRunDate = todayStr;
      console.log(`[COMMISSION SCHEDULER] Daily commission snapshots created for ${allDirectors.length} directors`);
    } catch (error) {
      console.error("[COMMISSION SCHEDULER] Error:", error);
    }
  }, COMMISSION_INTERVAL);
  console.log("[COMMISSION SCHEDULER] Started  polling every 60min for daily commission snapshots");

  // =============================================
  // ZIBRA DIRECTOR OVERSIGHT SCHEDULER
  // =============================================
  const ZIBRA_OVERSIGHT_INTERVAL = 6 * 60 * 60 * 1000;
  let lastZibraOversightRunDate = "";

  setInterval(async () => {
    try {
      const todayStr = new Date().toISOString().slice(0, 10);
      if (lastZibraOversightRunDate === todayStr) return;

      const allDirectors = await db.select().from(directorProfiles);
      const today = new Date();

      for (const director of allDirectors) {
        try {
          if (director.lifecycleStatus === "terminated") continue;

          if (director.lifespanEndDate) {
            const endDate = new Date(director.lifespanEndDate);
            const daysRemaining = Math.ceil((endDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));

            if (daysRemaining <= 30 && daysRemaining > 0 && director.lifecycleStatus === "active") {
              await storage.createNotification({
                userId: director.userId,
                type: "warning",
                title: "Contract Expiry Approaching",
                message: `Your director appointment expires in ${daysRemaining} days. Please contact administration if you have questions about renewal.`,
              });

              const admins = await db.select().from(users);
              for (const admin of admins) {
                const roles = await storage.getUserRoles(admin.id);
                if (roles.includes("super_admin")) {
                  await storage.createNotification({
                    userId: admin.id,
                    type: "info",
                    title: "Director Expiry Warning",
                    message: `Director ${director.fullName || director.userId} expires in ${daysRemaining} days. Consider succession planning.`,
                  });
                }
              }

              await db.insert(directorActionLogs).values({
                actorId: "system",
                actorRole: "system",
                action: "zibra_lifespan_warning",
                targetType: "director",
                targetId: director.userId,
                afterState: JSON.stringify({ daysRemaining, lifespanEndDate: director.lifespanEndDate }),
              });
            }

            if (daysRemaining <= 0 && director.lifecycleStatus === "active") {
              await storage.updateDirectorLifecycleStatus(director.userId, "expired", { suspendedBy: "system" });

              await storage.createNotification({
                userId: director.userId,
                type: "warning",
                title: "Director Appointment Expired",
                message: "Your director appointment has expired. Your dashboard is now in read-only mode. Contact administration for next steps.",
              });

              await db.insert(directorActionLogs).values({
                actorId: "system",
                actorRole: "system",
                action: "auto_expire_director",
                targetType: "director",
                targetId: director.userId,
                afterState: JSON.stringify({ previousStatus: director.lifecycleStatus, newStatus: "expired" }),
              });
            }
          }

          const commissionLogs = await storage.getDirectorCommissionLogs(director.userId, 7);
          if (commissionLogs.length >= 5) {
            const lowActivityDays = commissionLogs.filter(l => {
              const ratio = l.totalDrivers > 0 ? l.activeDriversToday / l.totalDrivers : 0;
              return ratio < 0.3;
            }).length;

            if (lowActivityDays >= 4) {
              const admins = await db.select().from(users);
              for (const admin of admins) {
                const roles = await storage.getUserRoles(admin.id);
                if (roles.includes("admin") || roles.includes("super_admin")) {
                  await storage.createNotification({
                    userId: admin.id,
                    type: "warning",
                    title: "Director Low Activity Alert",
                    message: `Director ${director.fullName || director.userId} has had low driver activity for ${lowActivityDays} of the last ${commissionLogs.length} days. Consider review.`,
                  });
                }
              }

              await db.insert(directorActionLogs).values({
                actorId: "system",
                actorRole: "system",
                action: "zibra_low_activity_alert",
                targetType: "director",
                targetId: director.userId,
                afterState: JSON.stringify({ lowActivityDays, totalDaysChecked: commissionLogs.length }),
              });
            }
          }

          const recentActions = await db.select().from(directorActionLogs)
            .where(and(
              eq(directorActionLogs.actorId, director.userId),
              eq(directorActionLogs.action, "director_suspend_driver"),
              gte(directorActionLogs.timestamp, new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000))
            ));

          if (recentActions.length >= 5) {
            const admins = await db.select().from(users);
            for (const admin of admins) {
              const roles = await storage.getUserRoles(admin.id);
              if (roles.includes("super_admin")) {
                await storage.createNotification({
                  userId: admin.id,
                  type: "warning",
                  title: "Director Repeated Violations",
                  message: `Director ${director.fullName || director.userId} has suspended ${recentActions.length} drivers this week. Investigate for potential abuse.`,
                });
              }
            }

            await db.insert(directorActionLogs).values({
              actorId: "system",
              actorRole: "system",
              action: "zibra_repeated_violations",
              targetType: "director",
              targetId: director.userId,
              afterState: JSON.stringify({ suspensionCount: recentActions.length }),
            });
          }
        } catch (dirError) {
          console.error(`[ZIBRA OVERSIGHT] Error for director ${director.userId}:`, dirError);
        }
      }

      lastZibraOversightRunDate = todayStr;
      console.log(`[ZIBRA OVERSIGHT] Daily oversight completed for ${allDirectors.length} directors`);
    } catch (error) {
      console.error("[ZIBRA OVERSIGHT] Error:", error);
    }
  }, ZIBRA_OVERSIGHT_INTERVAL);
  console.log("[ZIBRA OVERSIGHT] Started  polling every 6hrs for director oversight");

  // =============================================
  // BANK TRANSFER WALLET FUNDING
  // =============================================

  app.post("/api/wallet/bank-transfer", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { amount, currency } = req.body;

      if (!amount || parseFloat(amount) <= 0) {
        return res.status(400).json({ message: "Valid amount is required" });
      }

      const userRole = await storage.getUserRole(userId);
      if (!userRole) {
        return res.status(403).json({ message: "User role not found" });
      }

      const userCurrency = currency || await getUserCurrency(userId);
      const referenceCode = `ZIBA-${Date.now()}-${Math.random().toString(36).substr(2, 6).toUpperCase()}`;

      const transfer = await storage.createBankTransfer({
        userId,
        userRole: userRole.role,
        amount: String(amount),
        currency: userCurrency,
        referenceCode,
        bankName: "ZIBA Payment Bank",
        accountNumber: "0123456789",
        status: "pending",
      });

      return res.json({
        referenceCode: transfer.referenceCode,
        bankName: "ZIBA Payment Bank",
        accountNumber: "0123456789",
        amount: transfer.amount,
        currency: transfer.currency,
        instructions: "Transfer the exact amount using the reference code. Funds will be credited after confirmation.",
      });
    } catch (error) {
      console.error("Error initiating bank transfer:", error);
      return res.status(500).json({ message: "Failed to initiate bank transfer" });
    }
  });

  app.get("/api/wallet/bank-transfers", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const transfers = await storage.getBankTransfersByUser(userId);
      return res.json(transfers);
    } catch (error) {
      console.error("Error fetching bank transfers:", error);
      return res.status(500).json({ message: "Failed to fetch bank transfers" });
    }
  });

  app.get("/api/admin/bank-transfers", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const status = req.query.status as string | undefined;
      const transfers = await storage.getAllBankTransfers(status);
      const transfersWithUserInfo = await Promise.all(transfers.map(async (transfer) => {
        const [user] = await db.select().from(users).where(eq(users.id, transfer.userId));
        return {
          ...transfer,
          userName: user?.firstName && user?.lastName ? `${user.firstName} ${user.lastName}` : user?.username || "Unknown",
          userEmail: user?.email || "",
        };
      }));
      return res.json(transfersWithUserInfo);
    } catch (error) {
      console.error("Error fetching admin bank transfers:", error);
      return res.status(500).json({ message: "Failed to fetch bank transfers" });
    }
  });

  app.post("/api/admin/bank-transfers/:id/approve", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const transferId = req.params.id;

      const allTransfers = await storage.getAllBankTransfers();
      const transfer = allTransfers.find(t => t.id === transferId);
      if (!transfer) {
        return res.status(404).json({ message: "Bank transfer not found" });
      }

      if (transfer.status !== "pending" && transfer.status !== "processing") {
        return res.status(400).json({ message: `Cannot approve transfer with status: ${transfer.status}` });
      }

      const updated = await storage.updateBankTransferStatus(transferId, "completed", adminId);
      if (!updated) {
        return res.status(500).json({ message: "Failed to update transfer status" });
      }

      if (transfer.userRole === "rider") {
        await storage.updateRiderWalletBalance(transfer.userId, parseFloat(transfer.amount), "credit");
      } else if (transfer.userRole === "driver") {
        await storage.creditDriverWallet(transfer.userId, transfer.amount, "bank-transfer");
      }

      await storage.createAuditLog({
        action: "bank_transfer_approved",
        entityType: "bank_transfer",
        entityId: transferId,
        performedBy: adminId,
        details: `Approved bank transfer of ${transfer.amount} ${transfer.currency} for ${transfer.userRole} ${transfer.userId}. Reference: ${transfer.referenceCode}`,
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error approving bank transfer:", error);
      return res.status(500).json({ message: "Failed to approve bank transfer" });
    }
  });

  app.post("/api/admin/bank-transfers/:id/flag", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const transferId = req.params.id;
      const { notes } = req.body;

      const updated = await storage.updateBankTransferStatus(transferId, "flagged", adminId, notes);
      if (!updated) {
        return res.status(404).json({ message: "Bank transfer not found" });
      }

      await storage.createAuditLog({
        action: "bank_transfer_flagged",
        entityType: "bank_transfer",
        entityId: transferId,
        performedBy: adminId,
        details: `Flagged bank transfer as suspicious. Notes: ${notes || "N/A"}`,
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error flagging bank transfer:", error);
      return res.status(500).json({ message: "Failed to flag bank transfer" });
    }
  });

  // =============================================
  // CORPORATE RIDE MANAGEMENT - Admin Routes
  // =============================================

  // 1. GET /api/admin/corporate/organizations - List all corporate organizations
  app.get("/api/admin/corporate/organizations", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const orgs = await db.select().from(tripCoordinatorProfiles);
      const result = await Promise.all(orgs.map(async (org) => {
        const [user] = await db.select().from(users).where(eq(users.id, org.userId));
        const [wallet] = await db.select().from(wallets).where(eq(wallets.userId, org.userId));
        const [totalRidesResult] = await db.select({ count: count() }).from(rides).where(eq(rides.riderId, org.userId));
        const monthStart = new Date();
        monthStart.setDate(1);
        monthStart.setHours(0, 0, 0, 0);
        const [monthlyRidesResult] = await db.select({ count: count() }).from(rides).where(and(eq(rides.riderId, org.userId), gte(rides.requestedAt, monthStart)));
        return {
          id: org.id,
          userId: org.userId,
          organizationName: org.organizationName,
          organizationType: org.organizationType,
          contactEmail: org.contactEmail,
          contactPhone: org.contactPhone,
          status: "Active",
          walletBalance: wallet?.balance || "0.00",
          currency: wallet?.currency || "NGN",
          totalRides: totalRidesResult?.count || 0,
          monthlyRides: monthlyRidesResult?.count || 0,
          createdAt: org.createdAt,
        };
      }));
      return res.json(result);
    } catch (error) {
      console.error("Error fetching corporate organizations:", error);
      return res.status(500).json({ message: "Failed to fetch corporate organizations" });
    }
  });

  // 2. POST /api/admin/corporate/organizations/:id/suspend - Suspend organization
  app.post("/api/admin/corporate/organizations/:id/suspend", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const performedBy = req.user.claims.sub;
      await storage.createAuditLog({
        action: "CORPORATE_ORG_SUSPENDED",
        entityType: "corporate_organization",
        entityId: id,
        performedByUserId: performedBy,
        performedByRole: req.userRole,
        metadata: JSON.stringify({ action: "suspend", timestamp: new Date().toISOString() }),
      });
      return res.json({ message: "Organization suspended successfully" });
    } catch (error) {
      console.error("Error suspending corporate organization:", error);
      return res.status(500).json({ message: "Failed to suspend organization" });
    }
  });

  // 3. POST /api/admin/corporate/organizations/:id/activate - Activate organization
  app.post("/api/admin/corporate/organizations/:id/activate", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const performedBy = req.user.claims.sub;
      await storage.createAuditLog({
        action: "CORPORATE_ORG_ACTIVATED",
        entityType: "corporate_organization",
        entityId: id,
        performedByUserId: performedBy,
        performedByRole: req.userRole,
        metadata: JSON.stringify({ action: "activate", timestamp: new Date().toISOString() }),
      });
      return res.json({ message: "Organization activated successfully" });
    } catch (error) {
      console.error("Error activating corporate organization:", error);
      return res.status(500).json({ message: "Failed to activate organization" });
    }
  });

  // 4. GET /api/admin/corporate/members - Returns corporate members
  app.get("/api/admin/corporate/members", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const coordinators = await db.select().from(tripCoordinatorProfiles);
      const coordinatorUserIds = coordinators.map(c => c.userId);
      if (coordinatorUserIds.length === 0) {
        return res.json([]);
      }
      const corporateRides = await db.select().from(rides).where(inArray(rides.riderId, coordinatorUserIds));
      const memberMap = new Map<string, { orgName: string; rideCount: number }>();
      for (const ride of corporateRides) {
        const coord = coordinators.find(c => c.userId === ride.riderId);
        if (coord) {
          const existing = memberMap.get(coord.userId) || { orgName: coord.organizationName, rideCount: 0 };
          existing.rideCount++;
          memberMap.set(coord.userId, existing);
        }
      }
      const result = await Promise.all(
        Array.from(memberMap.entries()).map(async ([userId, data]) => {
          const [user] = await db.select().from(users).where(eq(users.id, userId));
          return {
            id: userId,
            name: user ? `${user.firstName || ""} ${user.lastName || ""}`.trim() : "Unknown",
            email: user?.email || "",
            organizationName: data.orgName,
            rideCount: data.rideCount,
            status: "Active",
          };
        })
      );
      return res.json(result);
    } catch (error) {
      console.error("Error fetching corporate members:", error);
      return res.status(500).json({ message: "Failed to fetch corporate members" });
    }
  });

  // 5. GET /api/admin/corporate/trips - Returns corporate trips
  app.get("/api/admin/corporate/trips", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const { status, organizationId, startDate, endDate } = req.query;
      const coordinators = await db.select().from(tripCoordinatorProfiles);
      let coordinatorUserIds = coordinators.map(c => c.userId);
      if (organizationId) {
        const filtered = coordinators.filter(c => c.id === organizationId);
        coordinatorUserIds = filtered.map(c => c.userId);
      }
      if (coordinatorUserIds.length === 0) {
        return res.json([]);
      }
      const conditions: any[] = [inArray(rides.riderId, coordinatorUserIds)];
      if (status) {
        conditions.push(eq(rides.status, status as any));
      }
      if (startDate) {
        conditions.push(gte(rides.requestedAt, new Date(startDate as string)));
      }
      if (endDate) {
        conditions.push(lt(rides.requestedAt, new Date(endDate as string)));
      }
      const corporateRides = await db.select().from(rides).where(and(...conditions)).orderBy(desc(rides.requestedAt));
      const result = await Promise.all(corporateRides.map(async (ride) => {
        const coord = coordinators.find(c => c.userId === ride.riderId);
        const [rider] = await db.select().from(users).where(eq(users.id, ride.riderId));
        return {
          id: ride.id,
          organizationName: coord?.organizationName || "Unknown",
          riderName: rider ? `${rider.firstName || ""} ${rider.lastName || ""}`.trim() : "Unknown",
          pickupAddress: ride.pickupAddress,
          dropoffAddress: ride.dropoffAddress,
          status: ride.status,
          fareAmount: ride.totalFare,
          hasCancellationFee: ride.cancellationFee !== null && parseFloat(ride.cancellationFee || "0") > 0,
          cancellationReason: ride.cancelReason,
          cancelledAt: ride.cancelledAt,
          createdAt: ride.requestedAt,
        };
      }));
      return res.json(result);
    } catch (error) {
      console.error("Error fetching corporate trips:", error);
      return res.status(500).json({ message: "Failed to fetch corporate trips" });
    }
  });

  // 6. GET /api/admin/corporate/scheduled-rides - Returns scheduled corporate rides
  app.get("/api/admin/corporate/scheduled-rides", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const { filter } = req.query;
      const coordinators = await db.select().from(tripCoordinatorProfiles);
      const coordinatorUserIds = coordinators.map(c => c.userId);
      if (coordinatorUserIds.length === 0) {
        return res.json([]);
      }
      const conditions: any[] = [
        inArray(rides.riderId, coordinatorUserIds),
        isNotNull(rides.scheduledPickupAt),
      ];
      const now = new Date();
      if (filter === "upcoming") {
        conditions.push(gte(rides.scheduledPickupAt, now));
      } else if (filter === "completed") {
        conditions.push(eq(rides.status, "completed"));
      }
      const scheduledRides = await db.select().from(rides).where(and(...conditions)).orderBy(desc(rides.scheduledPickupAt));
      const result = await Promise.all(scheduledRides.map(async (ride) => {
        const coord = coordinators.find(c => c.userId === ride.riderId);
        const [rider] = await db.select().from(users).where(eq(users.id, ride.riderId));
        return {
          id: ride.id,
          organizationName: coord?.organizationName || "Unknown",
          riderName: rider ? `${rider.firstName || ""} ${rider.lastName || ""}`.trim() : "Unknown",
          pickupLocation: ride.pickupAddress,
          dropoffLocation: ride.dropoffAddress,
          scheduledPickupAt: ride.scheduledPickupAt,
          status: ride.status,
          fareAmount: ride.totalFare,
        };
      }));
      return res.json(result);
    } catch (error) {
      console.error("Error fetching corporate scheduled rides:", error);
      return res.status(500).json({ message: "Failed to fetch corporate scheduled rides" });
    }
  });

  // 7. GET /api/admin/corporate/wallets - Returns corporate wallets
  app.get("/api/admin/corporate/wallets", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const coordinators = await db.select().from(tripCoordinatorProfiles);
      const result = await Promise.all(coordinators.map(async (coord) => {
        const [wallet] = await db.select().from(riderWallets).where(eq(riderWallets.userId, coord.userId));
        return {
          id: wallet?.id || coord.id,
          organizationName: coord.organizationName,
          balance: wallet?.balance || "0.00",
          currency: wallet?.currency || "NGN",
          isFrozen: wallet?.isFrozen || false,
          userId: coord.userId,
        };
      }));
      return res.json(result);
    } catch (error) {
      console.error("Error fetching corporate wallets:", error);
      return res.status(500).json({ message: "Failed to fetch corporate wallets" });
    }
  });

  // 8. POST /api/admin/corporate/wallets/:userId/freeze - Freeze corporate wallet
  app.post("/api/admin/corporate/wallets/:userId/freeze", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const performedBy = req.user.claims.sub;
      await db.update(riderWallets).set({ isFrozen: true, frozenAt: new Date(), frozenBy: performedBy }).where(eq(riderWallets.userId, userId));
      await storage.createAuditLog({
        action: "CORPORATE_WALLET_FROZEN",
        entityType: "corporate_organization",
        entityId: userId,
        performedByUserId: performedBy,
        performedByRole: req.userRole,
        metadata: JSON.stringify({ action: "freeze_wallet", userId, timestamp: new Date().toISOString() }),
      });
      return res.json({ message: "Corporate wallet frozen successfully" });
    } catch (error) {
      console.error("Error freezing corporate wallet:", error);
      return res.status(500).json({ message: "Failed to freeze corporate wallet" });
    }
  });

  // 9. POST /api/admin/corporate/wallets/:userId/unfreeze - Unfreeze corporate wallet
  app.post("/api/admin/corporate/wallets/:userId/unfreeze", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const performedBy = req.user.claims.sub;
      await db.update(riderWallets).set({ isFrozen: false, frozenAt: null, frozenBy: null, frozenReason: null }).where(eq(riderWallets.userId, userId));
      await storage.createAuditLog({
        action: "CORPORATE_WALLET_UNFROZEN",
        entityType: "corporate_organization",
        entityId: userId,
        performedByUserId: performedBy,
        performedByRole: req.userRole,
        metadata: JSON.stringify({ action: "unfreeze_wallet", userId, timestamp: new Date().toISOString() }),
      });
      return res.json({ message: "Corporate wallet unfrozen successfully" });
    } catch (error) {
      console.error("Error unfreezing corporate wallet:", error);
      return res.status(500).json({ message: "Failed to unfreeze corporate wallet" });
    }
  });

  // 10. GET /api/admin/corporate/wallets/:userId/transactions - Get wallet transaction history
  app.get("/api/admin/corporate/wallets/:userId/transactions", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const [wallet] = await db.select().from(wallets).where(eq(wallets.userId, userId));
      if (!wallet) {
        return res.json([]);
      }
      const transactions = await db.select().from(walletTransactions).where(eq(walletTransactions.walletId, wallet.id)).orderBy(desc(walletTransactions.createdAt));
      return res.json(transactions);
    } catch (error) {
      console.error("Error fetching corporate wallet transactions:", error);
      return res.status(500).json({ message: "Failed to fetch wallet transactions" });
    }
  });

  // 11. POST /api/admin/corporate/members/:id/revoke - Revoke member access
  app.post("/api/admin/corporate/members/:id/revoke", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const performedBy = req.user.claims.sub;
      await storage.createAuditLog({
        action: "CORPORATE_MEMBER_REVOKED",
        entityType: "corporate_member",
        entityId: id,
        performedByUserId: performedBy,
        performedByRole: req.userRole,
        metadata: JSON.stringify({ action: "revoke_access", memberId: id, timestamp: new Date().toISOString() }),
      });
      return res.json({ message: "Member access revoked successfully" });
    } catch (error) {
      console.error("Error revoking corporate member access:", error);
      return res.status(500).json({ message: "Failed to revoke member access" });
    }
  });

  // CANCELLATION FEE SETTINGS - Admin Routes
  app.get("/api/admin/cancellation-fee-settings", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const countryCode = (req.query.countryCode as string) || "NG";
      const [rule] = await db.select().from(countryPricingRules).where(eq(countryPricingRules.countryId, countryCode));
      if (!rule) {
        return res.json({
          countryCode,
          gracePeriodMinutes: 3,
          cancellationFee: "500.00",
          cancellationFeeArrivedMultiplier: "1.50",
          feeEnRoute: 500,
          feeArrived: 750,
          currency: "NGN",
        });
      }
      const fee = parseFloat(rule.cancellationFee);
      const multiplier = parseFloat(rule.cancellationFeeArrivedMultiplier);
      return res.json({
        countryCode,
        gracePeriodMinutes: 3,
        cancellationFee: rule.cancellationFee,
        cancellationFeeArrivedMultiplier: rule.cancellationFeeArrivedMultiplier,
        feeEnRoute: fee,
        feeArrived: fee * multiplier,
        currency: rule.currency,
      });
    } catch (error) {
      console.error("Error fetching cancellation fee settings:", error);
      return res.status(500).json({ message: "Failed to fetch cancellation fee settings" });
    }
  });

  app.post("/api/admin/cancellation-fee-settings", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { countryCode = "NG", cancellationFee, cancellationFeeArrivedMultiplier } = req.body;
      if (!cancellationFee || !cancellationFeeArrivedMultiplier) {
        return res.status(400).json({ message: "cancellationFee and cancellationFeeArrivedMultiplier are required" });
      }
      const performedBy = req.user.claims.sub;
      await db.update(countryPricingRules)
        .set({
          cancellationFee: String(cancellationFee),
          cancellationFeeArrivedMultiplier: String(cancellationFeeArrivedMultiplier),
          updatedAt: new Date(),
        })
        .where(eq(countryPricingRules.countryId, countryCode));
      await storage.createAuditLog({
        action: "CANCELLATION_FEE_UPDATED",
        entityType: "country_pricing_rules",
        entityId: countryCode,
        performedByUserId: performedBy,
        performedByRole: req.userRole,
        metadata: JSON.stringify({ countryCode, cancellationFee, cancellationFeeArrivedMultiplier }),
      });
      return res.json({ message: "Cancellation fee settings updated successfully" });
    } catch (error) {
      console.error("Error updating cancellation fee settings:", error);
      return res.status(500).json({ message: "Failed to update cancellation fee settings" });
    }
  });

  // 12. POST /api/admin/corporate/members/:id/restore - Restore member access
  app.post("/api/admin/corporate/members/:id/restore", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      const performedBy = req.user.claims.sub;
      await storage.createAuditLog({
        action: "CORPORATE_MEMBER_RESTORED",
        entityType: "corporate_member",
        entityId: id,
        performedByUserId: performedBy,
        performedByRole: req.userRole,
        metadata: JSON.stringify({ action: "restore_access", memberId: id, timestamp: new Date().toISOString() }),
      });
      return res.json({ message: "Member access restored successfully" });
    } catch (error) {
      console.error("Error restoring corporate member access:", error);
      return res.status(500).json({ message: "Failed to restore member access" });
    }
  });

  // =============================================
  // CANCELLATION FEE CONFIG ROUTES
  // =============================================
  app.get("/api/admin/cancellation-fee-config", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const configs = await storage.getAllCancellationFeeConfigs();
      return res.json(configs);
    } catch (error) {
      console.error("Error getting cancellation fee configs:", error);
      return res.status(500).json({ message: "Failed to get cancellation fee configs" });
    }
  });

  app.put("/api/admin/cancellation-fee-config", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const data = { ...req.body, updatedBy: userId };
      const config = await storage.upsertCancellationFeeConfig(data);
      return res.json(config);
    } catch (error) {
      console.error("Error updating cancellation fee config:", error);
      return res.status(500).json({ message: "Failed to update cancellation fee config" });
    }
  });

  // =============================================
  // RIDER INBOX MESSAGES ROUTES
  // =============================================
  app.get("/api/rider/inbox", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      let messages = await storage.getRiderInboxMessages(userId);

      if (messages.length === 0) {
        await storage.createRiderInboxMessage({
          userId,
          title: "Welcome to ZIBA!",
          body: "We're so happy to have you here! ZIBA connects you with safe and reliable rides whenever you need them. Enjoy your journey with us.",
          type: "system_announcement",
          read: false,
        });
        messages = await storage.getRiderInboxMessages(userId);
      }

      return res.json(messages);
    } catch (error) {
      console.error("Error getting rider inbox:", error);
      return res.status(500).json({ message: "Failed to get inbox messages" });
    }
  });

  app.post("/api/rider/inbox/:messageId/read", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { messageId } = req.params;
      const message = await storage.markRiderInboxMessageRead(messageId, userId);
      if (!message) {
        return res.status(404).json({ message: "Message not found" });
      }
      return res.json(message);
    } catch (error) {
      console.error("Error marking message as read:", error);
      return res.status(500).json({ message: "Failed to mark message as read" });
    }
  });

  app.post("/api/rider/inbox/read-all", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      await storage.markAllRiderInboxMessagesRead(userId);
      return res.json({ message: "All messages marked as read" });
    } catch (error) {
      console.error("Error marking all messages as read:", error);
      return res.status(500).json({ message: "Failed to mark all messages as read" });
    }
  });

  app.get("/api/rider/inbox/unread-count", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const count = await storage.getRiderUnreadMessageCount(userId);
      return res.json({ count });
    } catch (error) {
      console.error("Error getting unread count:", error);
      return res.status(500).json({ message: "Failed to get unread count" });
    }
  });

  // ==========================================
  // DRIVER INBOX
  // ==========================================

  app.get("/api/driver/inbox", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const messages = await storage.getDriverInboxMessages(userId);
      return res.json(messages);
    } catch (error) {
      console.error("Error fetching driver inbox:", error);
      return res.status(500).json({ message: "Failed to fetch inbox messages" });
    }
  });

  app.get("/api/driver/inbox/unread-count", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const count = await storage.getDriverInboxUnreadCount(userId);
      return res.json({ count });
    } catch (error) {
      console.error("Error fetching driver inbox unread count:", error);
      return res.json({ count: 0 });
    }
  });

  app.post("/api/driver/inbox/:messageId/read", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const message = await storage.markDriverInboxMessageRead(userId, req.params.messageId);
      if (!message) {
        return res.status(404).json({ message: "Message not found" });
      }
      return res.json(message);
    } catch (error) {
      console.error("Error marking driver inbox message read:", error);
      return res.status(500).json({ message: "Failed to mark message as read" });
    }
  });

  app.post("/api/driver/inbox/read-all", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      await storage.markAllDriverInboxMessagesRead(userId);
      return res.json({ success: true });
    } catch (error) {
      console.error("Error marking all driver inbox messages read:", error);
      return res.status(500).json({ message: "Failed to mark all messages as read" });
    }
  });
  app.get("/api/driver/notification-preferences", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const prefs = await storage.getNotificationPreferences(userId);
      return res.json(prefs);
    } catch (error) {
      console.error("Error getting driver notification preferences:", error);
      return res.status(500).json({ message: "Failed to get notification preferences" });
    }
  });

  app.put("/api/driver/notification-preferences", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const updates = req.body;
      const prefs = await storage.updateNotificationPreferences(userId, updates);
      return res.json(prefs);
    } catch (error) {
      console.error("Error updating driver notification preferences:", error);
      return res.status(500).json({ message: "Failed to update notification preferences" });
    }
  });


  app.get("/api/admin/rider-inbox/:userId", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const messages = await storage.getRiderInboxMessages(userId);
      return res.json(messages);
    } catch (error) {
      console.error("Error getting rider inbox for admin:", error);
      return res.status(500).json({ message: "Failed to get rider inbox" });
    }
  });

  // =============================================
  // NOTIFICATION PREFERENCES ROUTES
  // =============================================
  app.get("/api/rider/notification-preferences", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const prefs = await storage.getNotificationPreferences(userId);
      return res.json(prefs);
    } catch (error) {
      console.error("Error getting notification preferences:", error);
      return res.status(500).json({ message: "Failed to get notification preferences" });
    }
  });

  app.put("/api/rider/notification-preferences", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const updates = req.body;
      const prefs = await storage.updateNotificationPreferences(userId, updates);
      return res.json(prefs);
    } catch (error) {
      console.error("Error updating notification preferences:", error);
      return res.status(500).json({ message: "Failed to update notification preferences" });
    }
  });

  // =============================================
  // MARKETING MESSAGES ROUTE
  // =============================================
  app.get("/api/rider/marketing-tip", isAuthenticated, requireRole(["rider"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;

      const activeTrips = await storage.getActiveTripsByUser(userId);
      if (activeTrips && activeTrips.length > 0) {
        return res.json({ eligible: false, reason: "Active trip in progress" });
      }

      const lastMessage = await storage.getLastMarketingMessage(userId);
      if (lastMessage && lastMessage.sentAt) {
        const hoursSinceLast = (Date.now() - new Date(lastMessage.sentAt).getTime()) / (1000 * 60 * 60);
        if (hoursSinceLast < 24) {
          return res.json({ eligible: false, reason: "Already received a tip today" });
        }
      }

      const tips = [
        { key: "wallet_topup", text: "Top up your wallet for faster checkouts and avoid payment delays during rides." },
        { key: "schedule_rides", text: "Schedule your rides in advance to guarantee a driver at your preferred time." },
        { key: "rate_drivers", text: "Rating your drivers helps us match you with the best rides every time." },
        { key: "trusted_contacts", text: "Add trusted contacts so they can track your trip in real time for safety." },
        { key: "promo_codes", text: "Check your inbox for promo codes and discounts on your next ride." },
        { key: "peak_hours", text: "Avoid peak hours (7-9 AM, 5-7 PM) for lower fares and faster pickups." },
      ];

      const tipIndex = Math.floor(Math.random() * tips.length);
      const tip = tips[tipIndex];

      const message = await storage.createMarketingMessage({
        userId,
        messageKey: tip.key,
        messageText: tip.text,
      });

      return res.json({ eligible: true, tip: tip.text, messageKey: tip.key, messageId: message.id });
    } catch (error) {
      console.error("Error getting marketing tip:", error);
      return res.status(500).json({ message: "Failed to get marketing tip" });
    }
  });

  // =============================================
  // SEED DEFAULT NG CANCELLATION FEE CONFIG
  // =============================================
  (async () => {
    try {
      const existingConfig = await storage.getCancellationFeeConfig("NG");
      if (!existingConfig) {
        await storage.upsertCancellationFeeConfig({
          countryCode: "NG",
          cancellationFeeAmount: "500.00",
          scheduledPenaltyAmount: "750.00",
          gracePeriodMinutes: 3,
          scheduledCancelWindowMinutes: 30,
          arrivedCancellationFeeAmount: "800.00",
          isActive: true,
        });
        console.log("[SEED] Default NG cancellation fee config created");
      }
    } catch (error) {
      console.error("[SEED] Error seeding cancellation fee config:", error);
    }
  })();

  // Saved Places
  app.get("/api/rider/saved-places", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ message: "Not authenticated" });
      const places = await storage.getSavedPlaces(userId);
      return res.json(places);
    } catch (error) {
      console.error("Error fetching saved places:", error);
      return res.status(500).json({ message: "Failed to fetch saved places" });
    }
  });

  app.put("/api/rider/saved-places/:type", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ message: "Not authenticated" });
      const { type } = req.params;
      if (type !== "home" && type !== "work") {
        return res.status(400).json({ message: "Type must be 'home' or 'work'" });
      }
      const { address, notes, lat, lng } = req.body;
      if (!address || !address.trim()) {
        return res.status(400).json({ message: "Address is required" });
      }
      const place = await storage.upsertSavedPlace(userId, type, {
        address: address.trim(),
        notes: notes?.trim() || null,
        lat: lat || null,
        lng: lng || null,
      });
      return res.json(place);
    } catch (error) {
      console.error("Error saving place:", error);
      return res.status(500).json({ message: "Failed to save place" });
    }
  });

  // =============================================
  // PHASES 27-32: DIRECTOR GOVERNANCE
  // =============================================

  app.post("/api/admin/directors/:directorUserId/lifespan", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { directorUserId } = req.params;
      const { startDate, endDate } = req.body;

      if (!startDate || !endDate) {
        return res.status(400).json({ message: "startDate and endDate are required" });
      }

      if (new Date(endDate) <= new Date(startDate)) {
        return res.status(400).json({ message: "endDate must be after startDate" });
      }

      const profile = await storage.getDirectorProfile(directorUserId);
      const beforeLifespan = { lifespanStartDate: profile?.lifespanStartDate, lifespanEndDate: profile?.lifespanEndDate };

      await storage.setDirectorLifespan(directorUserId, new Date(startDate), new Date(endDate), adminUserId);

      await storage.updateDirectorProfile(directorUserId, {
        lastModifiedBy: adminUserId,
        lastModifiedAt: new Date(),
      });

      await storage.createDirectorActionLog({
        actorId: adminUserId,
        actorRole: "admin",
        action: "set_director_lifespan",
        targetType: "director",
        targetId: directorUserId,
        beforeState: JSON.stringify(beforeLifespan),
        afterState: JSON.stringify({ startDate, endDate }),
        metadata: null,
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });

      return res.json({ message: "Director lifespan set" });
    } catch (error) {
      console.error("Error setting director lifespan:", error);
      return res.status(500).json({ message: "Failed to set director lifespan" });
    }
  });

  app.post("/api/admin/directors/check-lifespan-expiry", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const expiredDirectors = await storage.getExpiredDirectors();
      let processedCount = 0;

      for (const director of expiredDirectors) {
        await storage.updateDirectorLifecycleStatus(director.userId, "suspended", { suspendedBy: "system" });
        await storage.createDirectorCoachingLog({
          directorUserId: director.userId,
          coachingType: "lifespan_expired",
          message: "Your contract lifespan has expired. Your account has been suspended and commissions frozen pending review.",
          severity: "critical",
        });
        processedCount++;
      }

      return res.json({ message: "Lifespan expiry check complete", processedCount });
    } catch (error) {
      console.error("Error checking lifespan expiry:", error);
      return res.status(500).json({ message: "Failed to check lifespan expiry" });
    }
  });

  app.get("/api/director/lifespan", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getDirectorProfile(userId);
      if (!profile) {
        return res.status(404).json({ message: "Director profile not found" });
      }

      let daysRemaining: number | null = null;
      if (profile.lifespanEndDate) {
        const now = new Date();
        const end = new Date(profile.lifespanEndDate);
        daysRemaining = Math.max(0, Math.ceil((end.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)));
      }

      return res.json({
        lifespanStartDate: profile.lifespanStartDate || null,
        lifespanEndDate: profile.lifespanEndDate || null,
        daysRemaining,
      });
    } catch (error) {
      console.error("Error getting director lifespan:", error);
      return res.status(500).json({ message: "Failed to get director lifespan" });
    }
  });

  app.post("/api/director/cells", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getDirectorProfile(userId);
      if (!profile) {
        return res.status(404).json({ message: "Director profile not found" });
      }

      if (profile.directorType !== "contract") {
        return res.status(403).json({ message: "Only contract directors can create cells" });
      }

      const existingCells = await storage.getDirectorCells(userId);
      if (existingCells.length >= 3) {
        return res.status(400).json({ message: "Maximum of 3 cells allowed" });
      }

      const { cellName } = req.body;
      const cell = await storage.createDirectorCell({
        directorUserId: userId,
        cellNumber: existingCells.length + 1,
        cellName: cellName || "Cell " + (existingCells.length + 1),
      });

      return res.json(cell);
    } catch (error) {
      console.error("Error creating director cell:", error);
      return res.status(500).json({ message: "Failed to create director cell" });
    }
  });

  app.get("/api/director/cells", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const cells = await storage.getDirectorCells(userId);

      const cellsWithCounts = await Promise.all(
        cells.map(async (cell: any) => {
          const driverCount = await storage.getDriverCountInCell(userId, cell.cellNumber);
          return { ...cell, driverCount };
        })
      );

      return res.json(cellsWithCounts);
    } catch (error) {
      console.error("Error getting director cells:", error);
      return res.status(500).json({ message: "Failed to get director cells" });
    }
  });

  app.get("/api/director/cells/:cellNumber/metrics", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { cellNumber } = req.params;
      const metrics = await storage.getCellMetrics(userId, parseInt(cellNumber));
      return res.json(metrics);
    } catch (error) {
      console.error("Error getting cell metrics:", error);
      return res.status(500).json({ message: "Failed to get cell metrics" });
    }
  });

  app.get("/api/director/dashboard/full", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getDirectorProfile(userId);
      if (!profile) {
        return res.status(404).json({ message: "Director profile not found" });
      }

      const metrics = await storage.getDirectorDailyMetrics(userId);
      const cells = await storage.getDirectorCells(userId);
      const cellsWithCounts = await Promise.all(
        cells.map(async (cell: any) => {
          const driverCount = await storage.getDriverCountInCell(userId, cell.cellNumber);
          return { ...cell, driverCount };
        })
      );
      const staff = await storage.getDirectorStaff(userId);
      const coachingLogs = await storage.getDirectorCoachingLogs(userId);

      let daysRemaining: number | null = null;
      if (profile.lifespanEndDate) {
        const now = new Date();
        const end = new Date(profile.lifespanEndDate);
        daysRemaining = Math.max(0, Math.ceil((end.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)));
      }

      const actionLogs = await storage.getDirectorActionLogs({ actorId: userId }) || [];

      let trustScoreSummary = { averageScore: 0, highCount: 0, mediumCount: 0, lowCount: 0, totalDrivers: 0 };
      try {
        const drivers = await storage.getDriversUnderDirector(userId);
        if (drivers && drivers.length > 0) {
          const driverUserIds = drivers.map((d: any) => d.userId || d.driverUserId);
          let totalScore = 0;
          let count = 0;
          for (const duid of driverUserIds) {
            const trustProfile = await storage.getUserTrustProfile(duid);
            if (trustProfile) {
              const score = typeof trustProfile.trustScore === 'number' ? trustProfile.trustScore : parseFloat(String(trustProfile.trustScore || '75'));
              totalScore += score;
              count++;
              if (score >= 80) trustScoreSummary.highCount++;
              else if (score >= 60) trustScoreSummary.mediumCount++;
              else trustScoreSummary.lowCount++;
            }
          }
          trustScoreSummary.totalDrivers = count;
          trustScoreSummary.averageScore = count > 0 ? Math.round(totalScore / count) : 0;
        }
      } catch (e) {
        console.warn("[DIRECTOR] Failed to compute trust score summary:", e);
      }

      return res.json({
        directorType: profile.directorType,
        status: profile.status,
        lifecycleStatus: profile.lifecycleStatus,
        onboardingCompleted: profile.onboardingCompleted,
        activationThreshold: profile.activationThreshold,
        maxCellSize: profile.maxCellSize,
        totalDrivers: metrics.totalDrivers,
        activeDriversToday: metrics.activeDriversToday,
        suspendedDrivers: metrics.suspendedDrivers,
        cells: cellsWithCounts,
        staff,
        coachingLogs,
        actionLogs: actionLogs.slice(0, 100),
        trustScoreSummary,
        lifespan: {
          startDate: profile.lifespanStartDate || null,
          endDate: profile.lifespanEndDate || null,
          daysRemaining,
        },
      });
    } catch (error) {
      console.error("Error getting full director dashboard:", error);
      return res.status(500).json({ message: "Failed to get full director dashboard" });
    }
  });

  app.get("/api/admin/directors/:directorUserId/dashboard", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { directorUserId } = req.params;
      const profile = await storage.getDirectorProfile(directorUserId);
      if (!profile) {
        return res.status(404).json({ message: "Director profile not found" });
      }

      const metrics = await storage.getDirectorDailyMetrics(directorUserId);
      const cells = await storage.getDirectorCells(directorUserId);
      const cellsWithCounts = await Promise.all(
        cells.map(async (cell: any) => {
          const driverCount = await storage.getDriverCountInCell(directorUserId, cell.cellNumber);
          return { ...cell, driverCount };
        })
      );
      const staff = await storage.getDirectorStaff(directorUserId);
      const coachingLogs = await storage.getDirectorCoachingLogs(directorUserId);

      let daysRemaining: number | null = null;
      if (profile.lifespanEndDate) {
        const now = new Date();
        const end = new Date(profile.lifespanEndDate);
        daysRemaining = Math.max(0, Math.ceil((end.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)));
      }

      return res.json({
        directorType: profile.directorType,
        status: profile.status,
        lifecycleStatus: profile.lifecycleStatus,
        onboardingCompleted: profile.onboardingCompleted,
        activationThreshold: profile.activationThreshold,
        maxCellSize: profile.maxCellSize,
        totalDrivers: metrics.totalDrivers,
        activeDriversToday: metrics.activeDriversToday,
        suspendedDrivers: metrics.suspendedDrivers,
        cells: cellsWithCounts,
        staff,
        coachingLogs,
        lifespan: {
          startDate: profile.lifespanStartDate || null,
          endDate: profile.lifespanEndDate || null,
          daysRemaining,
        },
      });
    } catch (error) {
      console.error("Error getting director dashboard for admin:", error);
      return res.status(500).json({ message: "Failed to get director dashboard" });
    }
  });

  app.post("/api/director/staff", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getDirectorProfile(userId);
      if (!profile) {
        return res.status(404).json({ message: "Director profile not found" });
      }

      if (profile.directorType !== "contract") {
        return res.status(403).json({ message: "Only contract directors can add staff" });
      }

      const { staffUserId, staffRole, permissions } = req.body;
      if (!staffUserId || !staffRole) {
        return res.status(400).json({ message: "staffUserId and staffRole are required" });
      }

      const staffRecord = await storage.createDirectorStaff({
        directorUserId: userId,
        staffUserId,
        staffRole,
        permissions: permissions || null,
        status: "pending",
      });

      await storage.createDirectorActionLog({
        actorId: userId,
        actorRole: "director",
        action: "add_staff",
        targetType: "staff",
        targetId: staffUserId,
        beforeState: null,
        afterState: JSON.stringify({ staffRole, permissions }),
        metadata: null,
      });

      return res.json({ message: "Staff request submitted for admin approval", staff: staffRecord });
    } catch (error) {
      console.error("Error adding director staff:", error);
      return res.status(500).json({ message: "Failed to add director staff" });
    }
  });

  app.get("/api/director/staff", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const staff = await storage.getDirectorStaff(userId);
      return res.json(staff);
    } catch (error) {
      console.error("Error getting director staff:", error);
      return res.status(500).json({ message: "Failed to get director staff" });
    }
  });

  app.post("/api/admin/director-staff/:id/approve", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { id } = req.params;

      await storage.updateDirectorStaffStatus(parseInt(id), {
        status: "approved",
        approvedByAdmin: true,
        approvedBy: adminUserId,
      });

      await storage.createDirectorActionLog({
        actorId: adminUserId,
        actorRole: "admin",
        action: "approve_staff",
        targetType: "staff",
        targetId: id,
        beforeState: JSON.stringify({ status: "pending" }),
        afterState: JSON.stringify({ status: "approved" }),
        metadata: null,
      });

      return res.json({ message: "Staff approved" });
    } catch (error) {
      console.error("Error approving director staff:", error);
      return res.status(500).json({ message: "Failed to approve director staff" });
    }
  });

  app.post("/api/admin/director-staff/:id/reject", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      await storage.updateDirectorStaffStatus(parseInt(id), { status: "rejected" });
      return res.json({ message: "Staff rejected" });
    } catch (error) {
      console.error("Error rejecting director staff:", error);
      return res.status(500).json({ message: "Failed to reject director staff" });
    }
  });

  app.delete("/api/director/staff/:id", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id } = req.params;

      const staff = await storage.getDirectorStaffById(parseInt(id));
      if (!staff || staff.directorUserId !== userId) {
        return res.status(403).json({ message: "Staff does not belong to this director" });
      }

      await storage.removeDirectorStaff(parseInt(id));

      await storage.createDirectorActionLog({
        actorId: userId,
        actorRole: "director",
        action: "remove_staff",
        targetType: "staff",
        targetId: id,
        beforeState: JSON.stringify({ staffUserId: staff.staffUserId, staffRole: staff.staffRole }),
        afterState: null,
        metadata: null,
      });

      return res.json({ message: "Staff removed" });
    } catch (error) {
      console.error("Error removing director staff:", error);
      return res.status(500).json({ message: "Failed to remove director staff" });
    }
  });

  app.get("/api/admin/director-staff/pending", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const pendingStaff = await storage.getAllPendingDirectorStaff();
      return res.json(pendingStaff);
    } catch (error) {
      console.error("Error getting pending director staff:", error);
      return res.status(500).json({ message: "Failed to get pending director staff" });
    }
  });

  app.get("/api/admin/director-action-logs", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { actorId, targetId, action, limit } = req.query;
      const filters: any = {};
      if (actorId) filters.actorId = actorId;
      if (targetId) filters.targetId = targetId;
      if (action) filters.action = action;

      const logs = await storage.getDirectorActionLogs(filters, limit ? parseInt(limit as string) : undefined);
      return res.json(logs);
    } catch (error) {
      console.error("Error getting director action logs:", error);
      return res.status(500).json({ message: "Failed to get director action logs" });
    }
  });

  app.get("/api/director/action-logs", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const logs = await storage.getDirectorActionLogs({ actorId: userId });
      return res.json(logs);
    } catch (error) {
      console.error("Error getting director action logs:", error);
      return res.status(500).json({ message: "Failed to get director action logs" });
    }
  });

  app.get("/api/director/coaching", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const logs = await storage.getDirectorCoachingLogs(userId);
      return res.json(logs);
    } catch (error) {
      console.error("Error getting director coaching logs:", error);
      return res.status(500).json({ message: "Failed to get director coaching logs" });
    }
  });

  app.post("/api/director/coaching/:id/dismiss", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const { id } = req.params;
      await storage.dismissDirectorCoachingLog(parseInt(id));
      return res.json({ message: "Coaching log dismissed" });
    } catch (error) {
      console.error("Error dismissing coaching log:", error);
      return res.status(500).json({ message: "Failed to dismiss coaching log" });
    }
  });

  app.post("/api/director/coaching/generate", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getDirectorProfile(userId);
      if (!profile) {
        return res.status(404).json({ message: "Director profile not found" });
      }

      const metrics = await storage.getDirectorDailyMetrics(userId);
      const generated: any[] = [];

      if (metrics.totalDrivers > 0 && metrics.activeDriversToday / metrics.totalDrivers < 0.5) {
        const log = await storage.createDirectorCoachingLog({
          directorUserId: userId,
          coachingType: "low_activity",
          message: "Less than half of your drivers were active today. Consider reaching out to inactive drivers to boost engagement.",
          severity: "warning",
        });
        generated.push(log);
      }

      if (metrics.totalDrivers > 0 && metrics.suspendedDrivers / metrics.totalDrivers > 0.3) {
        const log = await storage.createDirectorCoachingLog({
          directorUserId: userId,
          coachingType: "high_suspensions",
          message: "A significant portion of your drivers are suspended. Review their cases and work on compliance to reduce suspensions.",
          severity: "warning",
        });
        generated.push(log);
      }

      if (profile.lifespanEndDate) {
        const now = new Date();
        const end = new Date(profile.lifespanEndDate);
        const daysLeft = Math.ceil((end.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
        if (daysLeft <= 14 && daysLeft > 0) {
          const log = await storage.createDirectorCoachingLog({
            directorUserId: userId,
            coachingType: "lifespan_expiry",
            message: `Your contract expires in ${daysLeft} days. Contact administration for renewal.`,
            severity: "critical",
          });
          generated.push(log);
        }
      }

      const maxCellSize = profile.maxCellSize || 1300;
      if (maxCellSize > 0 && metrics.totalDrivers / maxCellSize > 0.9) {
        const log = await storage.createDirectorCoachingLog({
          directorUserId: userId,
          coachingType: "approaching_capacity",
          message: "You are approaching your maximum driver capacity. Consider optimizing your cell structure or requesting a capacity increase.",
          severity: "info",
        });
        generated.push(log);
      }

      return res.json(generated);
    } catch (error) {
      console.error("Error generating coaching prompts:", error);
      return res.status(500).json({ message: "Failed to generate coaching prompts" });
    }
  });

  app.post("/api/admin/directors/:directorUserId/coaching/send", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { directorUserId } = req.params;
      const { coachingType, message, severity } = req.body;

      if (!coachingType || !message) {
        return res.status(400).json({ message: "coachingType and message are required" });
      }

      const log = await storage.createDirectorCoachingLog({
        directorUserId,
        coachingType,
        message,
        severity: severity || "info",
      });

      await storage.createDirectorActionLog({
        actorId: adminUserId,
        actorRole: "admin",
        action: "send_coaching",
        targetType: "director",
        targetId: directorUserId,
        beforeState: null,
        afterState: JSON.stringify({ coachingType, message, severity }),
        metadata: null,
      });

      return res.json(log);
    } catch (error) {
      console.error("Error sending coaching prompt:", error);
      return res.status(500).json({ message: "Failed to send coaching prompt" });
    }
  });

  app.get("/api/training/modules/:role", isAuthenticated, async (req: any, res) => {
    try {
      const { role } = req.params;
      const { trainingModules } = await import("../shared/training-content");
      const modules = trainingModules.filter((m: any) => m.role === role);
      res.json(modules);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch training modules" });
    }
  });

  app.get("/api/training/acknowledgements", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });
      const acks = await storage.getTrainingAcknowledgements(userId);
      res.json(acks);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch acknowledgements" });
    }
  });

  app.post("/api/training/acknowledge", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });
      const { moduleId, role } = req.body;
      if (!moduleId || !role) {
        return res.status(400).json({ error: "moduleId and role are required" });
      }
      const existing = await storage.getTrainingAcknowledgements(userId);
      if (existing.some((a: any) => a.moduleId === moduleId)) {
        return res.status(409).json({ error: "Already acknowledged" });
      }
      const ack = await storage.acknowledgeTraining({ userId, moduleId, role });
      res.json(ack);
    } catch (error) {
      res.status(500).json({ error: "Failed to acknowledge training" });
    }
  });

  app.get("/api/alerts/my", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });
      const alerts = await storage.getPerformanceAlerts(userId);
      res.json(alerts);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch alerts" });
    }
  });

  app.get("/api/alerts/admin", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const alerts = await storage.getAdminAlerts();
      res.json(alerts);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch admin alerts" });
    }
  });

  app.post("/api/alerts/:id/read", isAuthenticated, async (req: any, res) => {
    try {
      const alert = await storage.markAlertRead(req.params.id);
      if (!alert) return res.status(404).json({ error: "Alert not found" });
      res.json(alert);
    } catch (error) {
      res.status(500).json({ error: "Failed to mark alert read" });
    }
  });

  app.post("/api/alerts/:id/dismiss", isAuthenticated, async (req: any, res) => {
    try {
      const alert = await storage.dismissAlert(req.params.id);
      if (!alert) return res.status(404).json({ error: "Alert not found" });
      res.json(alert);
    } catch (error) {
      res.status(500).json({ error: "Failed to dismiss alert" });
    }
  });

  app.post("/api/alerts/generate-health-check", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });
      
      const alertTypes = [
        { type: "driver_activity_drop", severity: "warning", title: "Driver Activity Declining", message: "Several drivers in your cell have shown reduced activity over the past 7 days. Review their status and reach out if needed.", targetRole: "director" },
        { type: "high_suspension_rate", severity: "warning", title: "Elevated Suspension Rate", message: "The suspension rate in your cell exceeds typical levels. Review recent suspensions to confirm they follow platform policy.", targetRole: "director" },
        { type: "cell_cap_approaching", severity: "info", title: "Approaching Cell Capacity", message: "Your driver cell is nearing its capacity limit. Plan for capacity management and coordinate with administration if needed.", targetRole: "director" },
        { type: "low_active_percentage", severity: "warning", title: "Low Active Driver Percentage", message: "The percentage of active drivers in your cell has dropped below expected levels. Consider reviewing driver engagement.", targetRole: "director" },
        { type: "director_abuse_pattern", severity: "critical", title: "Potential Director Abuse Detected", message: "Unusual suspension patterns detected for a director account. Review the director's recent actions in the audit log.", targetRole: "admin" },
        { type: "excessive_suspensions", severity: "warning", title: "Excessive Suspensions Flagged", message: "A director has suspended an unusually high number of drivers this week. Investigate for potential policy violations.", targetRole: "admin" },
        { type: "appeal_volume_spike", severity: "info", title: "Appeal Volume Spike", message: "The number of director appeals has increased significantly. Review the appeals queue and allocate resources as needed.", targetRole: "admin" },
      ];
      
      res.json({ generated: alertTypes.length, alertTypes: alertTypes.map(a => a.type) });
    } catch (error) {
      res.status(500).json({ error: "Failed to generate health check" });
    }
  });

  // =============================================
  // FUND ANOTHER WALLET
  // =============================================

  app.get("/api/wallet-funding/settings", isAuthenticated, async (req: any, res) => {
    try {
      const [settings] = await db.select().from(walletFundingSettings).limit(1);
      if (!settings) {
        const [created] = await db.insert(walletFundingSettings).values({}).returning();
        return res.json(created);
      }
      res.json(settings);
    } catch (error) {
      res.status(500).json({ error: "Failed to load funding settings" });
    }
  });

  app.post("/api/wallet-funding/lookup", isAuthenticated, async (req: any, res) => {
    try {
      const { identifier } = req.body;
      if (!identifier || typeof identifier !== "string" || identifier.trim().length < 3) {
        return res.status(400).json({ error: "Please enter a valid email, phone number, or ZIBA ID" });
      }
      const trimmed = identifier.trim().toLowerCase();
      const allUsers = await db.select({
        id: users.id,
        email: users.email,
        firstName: users.firstName,
        lastName: users.lastName,
        profileImageUrl: users.profileImageUrl,
        roles: users.roles,
      }).from(users);

      let found = allUsers.find(u => u.email?.toLowerCase() === trimmed || u.id === trimmed);
      if (!found) {
        const riderP = await db.select({ userId: riderProfiles.userId, phone: riderProfiles.phone })
          .from(riderProfiles).where(eq(riderProfiles.phone, trimmed));
        if (riderP.length > 0) {
          found = allUsers.find(u => u.id === riderP[0].userId);
        }
      }
      if (!found) {
        return res.status(404).json({ error: "No ZIBA user found with that identifier" });
      }

      const senderUserId = req.user?.claims?.sub;
      const [fundSettings] = await db.select().from(walletFundingSettings).limit(1);
      if (fundSettings && !fundSettings.selfFundingAllowed && found.id === senderUserId) {
        return res.status(400).json({ error: "You cannot fund your own wallet" });
      }

      let riderPhoto: string | null = null;
      const [rp] = await db.select({ profilePhoto: riderProfiles.profilePhoto })
        .from(riderProfiles).where(eq(riderProfiles.userId, found.id));
      if (rp) riderPhoto = rp.profilePhoto;

      const displayName = found.firstName && found.lastName
        ? `${found.firstName} ${found.lastName}`
        : found.email || "ZIBA User";
      const primaryRole = (found.roles as string[])?.[0] || "rider";

      res.json({
        userId: found.id,
        displayName,
        avatarUrl: riderPhoto || found.profileImageUrl,
        role: primaryRole,
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to lookup recipient" });
    }
  });

  app.post("/api/wallet-funding/send", isAuthenticated, async (req: any, res) => {
    try {
      const senderUserId = req.user?.claims?.sub;
      if (!senderUserId) return res.status(401).json({ error: "Not authenticated" });

      const { receiverUserId, amount, disclaimerAccepted, purpose } = req.body;
      if (!receiverUserId || !amount || !disclaimerAccepted) {
        return res.status(400).json({ error: "Missing required fields" });
      }
      const fundAmount = parseFloat(amount);
      if (isNaN(fundAmount) || fundAmount <= 0) {
        return res.status(400).json({ error: "Invalid amount" });
      }

      let [settings] = await db.select().from(walletFundingSettings).limit(1);
      if (!settings) {
        [settings] = await db.insert(walletFundingSettings).values({}).returning();
      }
      if (!settings.isEnabled) {
        return res.status(403).json({ error: "Wallet funding is currently disabled" });
      }
      if (!settings.selfFundingAllowed && receiverUserId === senderUserId) {
        return res.status(400).json({ error: "You cannot fund your own wallet" });
      }
      const minAmt = parseFloat(settings.minAmount as string);
      const maxAmt = parseFloat(settings.maxAmount as string);
      if (fundAmount < minAmt) return res.status(400).json({ error: `Minimum amount is ${minAmt}` });
      if (fundAmount > maxAmt) return res.status(400).json({ error: `Maximum amount is ${maxAmt}` });

      const now = new Date();
      const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);

      const [dailyTotal] = await db.select({ total: sql<string>`COALESCE(SUM(amount::numeric), 0)` })
        .from(walletFundingTransactions)
        .where(and(
          eq(walletFundingTransactions.senderUserId, senderUserId),
          inArray(walletFundingTransactions.status, ["completed", "pending"]),
          gte(walletFundingTransactions.createdAt, startOfDay)
        ));
      if (parseFloat(dailyTotal?.total || "0") + fundAmount > parseFloat(settings.dailyLimit as string)) {
        return res.status(400).json({ error: "Daily funding limit exceeded" });
      }

      const [monthlyTotal] = await db.select({ total: sql<string>`COALESCE(SUM(amount::numeric), 0)` })
        .from(walletFundingTransactions)
        .where(and(
          eq(walletFundingTransactions.senderUserId, senderUserId),
          inArray(walletFundingTransactions.status, ["completed", "pending"]),
          gte(walletFundingTransactions.createdAt, startOfMonth)
        ));
      if (parseFloat(monthlyTotal?.total || "0") + fundAmount > parseFloat(settings.monthlyLimit as string)) {
        return res.status(400).json({ error: "Monthly funding limit exceeded" });
      }

      const [receiver] = await db.select().from(users).where(eq(users.id, receiverUserId));
      if (!receiver) return res.status(404).json({ error: "Recipient not found" });

      const [sender] = await db.select().from(users).where(eq(users.id, senderUserId));
      const senderRoles = (sender?.roles as string[]) || [];
      const receiverRoles = (receiver.roles as string[]) || [];
      const senderRole = senderRoles[0] || "rider";
      const receiverRole = receiverRoles[0] || "rider";

      const [repeatCount] = await db.select({ cnt: sql<number>`COUNT(*)` })
        .from(walletFundingTransactions)
        .where(and(
          eq(walletFundingTransactions.senderUserId, senderUserId),
          eq(walletFundingTransactions.receiverUserId, receiverUserId),
          eq(walletFundingTransactions.status, "completed")
        ));
      const threshold = settings.repeatFundingThreshold || 5;
      const isFlagged = (repeatCount?.cnt || 0) >= threshold;
      const flagReason = isFlagged ? `Repeated funding to same user (${repeatCount?.cnt} previous transactions)` : null;

      const amountStr = fundAmount.toFixed(2);

      const [txn] = await db.insert(walletFundingTransactions).values({
        senderUserId,
        receiverUserId,
        amount: amountStr,
        status: "pending",
        senderRole,
        receiverRole,
        purpose: purpose || null,
        disclaimerAccepted: true,
        flagged: isFlagged,
        flagReason,
      }).returning();

      const senderName = sender?.firstName && sender?.lastName
        ? `${sender.firstName} ${sender.lastName}` : sender?.email || "A ZIBA user";
      const receiverName = receiver.firstName && receiver.lastName
        ? `${receiver.firstName} ${receiver.lastName}` : receiver.email || "ZIBA User";

      const senderNotifRole = senderRoles.includes("driver") ? "driver" as const
        : senderRoles.includes("director") ? "director" as const : "rider" as const;
      const receiverNotifRole = receiverRoles.includes("driver") ? "driver" as const
        : receiverRoles.includes("director") ? "director" as const : "rider" as const;

      await storage.createNotification({
        userId: senderUserId,
        role: senderNotifRole,
        type: "success",
        title: "Wallet Funding Sent",
        message: `You sent \u20A6${parseFloat(amountStr).toLocaleString()} to ${receiverName}'s ZIBA wallet.`,
      });

      await storage.createNotification({
        userId: receiverUserId,
        role: receiverNotifRole,
        type: "info",
        title: "Pending Wallet Funding",
        message: `You have a pending wallet funding request of \u20A6${parseFloat(amountStr).toLocaleString()} from ${senderName}. Open Fund Another Wallet to accept or decline.`,
      });

      res.json({ success: true, transaction: txn });
    } catch (error) {
      console.error("Wallet funding error:", error);
      res.status(500).json({ error: "Failed to process wallet funding" });
    }
  });

  app.get("/api/wallet-funding/history", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const sent = await db.select().from(walletFundingTransactions)
        .where(eq(walletFundingTransactions.senderUserId, userId))
        .orderBy(desc(walletFundingTransactions.createdAt))
        .limit(50);
      const received = await db.select().from(walletFundingTransactions)
        .where(eq(walletFundingTransactions.receiverUserId, userId))
        .orderBy(desc(walletFundingTransactions.createdAt))
        .limit(50);

      const allUserIds = [...new Set([...sent.map(t => t.receiverUserId), ...received.map(t => t.senderUserId)])];
      const userNames: Record<string, string> = {};
      if (allUserIds.length > 0) {
        const foundUsers = await db.select({ id: users.id, email: users.email, firstName: users.firstName, lastName: users.lastName })
          .from(users).where(inArray(users.id, allUserIds));
        for (const u of foundUsers) {
          userNames[u.id] = u.firstName && u.lastName ? `${u.firstName} ${u.lastName}` : u.email || "ZIBA User";
        }
      }

      res.json({
        sent: sent.map(t => ({ ...t, recipientName: userNames[t.receiverUserId] || "ZIBA User" })),
        received: received.map(t => ({ ...t, senderName: userNames[t.senderUserId] || "ZIBA User" })),
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to load funding history" });
    }
  });

  app.get("/api/wallet-funding/pending", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const pending = await db.select().from(walletFundingTransactions)
        .where(and(
          eq(walletFundingTransactions.receiverUserId, userId),
          eq(walletFundingTransactions.status, "pending")
        ))
        .orderBy(desc(walletFundingTransactions.createdAt));

      const senderIds = [...new Set(pending.map(t => t.senderUserId))];
      const senderNames: Record<string, string> = {};
      if (senderIds.length > 0) {
        const senders = await db.select({ id: users.id, email: users.email, firstName: users.firstName, lastName: users.lastName })
          .from(users).where(inArray(users.id, senderIds));
        for (const u of senders) {
          senderNames[u.id] = u.firstName && u.lastName ? `${u.firstName} ${u.lastName}` : u.email || "ZIBA User";
        }
      }

      res.json(pending.map(t => ({ ...t, senderName: senderNames[t.senderUserId] || "ZIBA User" })));
    } catch (error) {
      res.status(500).json({ error: "Failed to load pending funding" });
    }
  });

  app.post("/api/wallet-funding/:id/accept", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const txnId = req.params.id;
      const [txn] = await db.select().from(walletFundingTransactions)
        .where(and(
          eq(walletFundingTransactions.id, txnId),
          eq(walletFundingTransactions.receiverUserId, userId),
          eq(walletFundingTransactions.status, "pending")
        ));

      if (!txn) return res.status(404).json({ error: "Pending funding not found" });

      const amountStr = txn.amount;
      const [receiver] = await db.select().from(users).where(eq(users.id, userId));
      const receiverRoles = (receiver?.roles as string[]) || [];

      if (receiverRoles.includes("driver")) {
        const [wallet] = await db.select().from(driverWallets).where(eq(driverWallets.userId, userId));
        if (wallet) {
          await db.update(driverWallets)
            .set({ balance: sql`(${driverWallets.balance}::numeric + ${amountStr}::numeric)::text`, updatedAt: new Date() })
            .where(eq(driverWallets.userId, userId));
        } else {
          await db.insert(driverWallets).values({ userId, balance: amountStr });
        }
      } else {
        const [wallet] = await db.select().from(riderWallets).where(eq(riderWallets.userId, userId));
        if (wallet) {
          await db.update(riderWallets)
            .set({ balance: sql`(${riderWallets.balance}::numeric + ${amountStr}::numeric)::text`, updatedAt: new Date() })
            .where(eq(riderWallets.userId, userId));
        } else {
          await db.insert(riderWallets).values({ userId, balance: amountStr });
        }
      }

      const [updated] = await db.update(walletFundingTransactions)
        .set({ status: "completed", acceptedAt: new Date() })
        .where(eq(walletFundingTransactions.id, txnId))
        .returning();

      const senderRoles = (await db.select().from(users).where(eq(users.id, txn.senderUserId)))?.[0]?.roles as string[] || [];
      const senderNotifRole = senderRoles.includes("driver") ? "driver" as const
        : senderRoles.includes("director") ? "director" as const : "rider" as const;
      const receiverName = receiver?.firstName && receiver?.lastName
        ? `${receiver.firstName} ${receiver.lastName}` : receiver?.email || "The recipient";

      await storage.createNotification({
        userId: txn.senderUserId,
        role: senderNotifRole,
        type: "success",
        title: "Funding Accepted",
        message: `${receiverName} accepted your \u20A6${parseFloat(amountStr).toLocaleString()} wallet funding.`,
      });

      res.json(updated);
    } catch (error) {
      res.status(500).json({ error: "Failed to accept funding" });
    }
  });

  app.post("/api/wallet-funding/:id/decline", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const txnId = req.params.id;
      const [txn] = await db.select().from(walletFundingTransactions)
        .where(and(
          eq(walletFundingTransactions.id, txnId),
          eq(walletFundingTransactions.receiverUserId, userId),
          eq(walletFundingTransactions.status, "pending")
        ));

      if (!txn) return res.status(404).json({ error: "Pending funding not found" });

      const [updated] = await db.update(walletFundingTransactions)
        .set({ status: "declined", declinedAt: new Date() })
        .where(eq(walletFundingTransactions.id, txnId))
        .returning();

      const [sender] = await db.select().from(users).where(eq(users.id, txn.senderUserId));
      const senderRoles = (sender?.roles as string[]) || [];
      const senderNotifRole = senderRoles.includes("driver") ? "driver" as const
        : senderRoles.includes("director") ? "director" as const : "rider" as const;
      const [receiver] = await db.select().from(users).where(eq(users.id, userId));
      const receiverName = receiver?.firstName && receiver?.lastName
        ? `${receiver.firstName} ${receiver.lastName}` : receiver?.email || "The recipient";

      await storage.createNotification({
        userId: txn.senderUserId,
        role: senderNotifRole,
        type: "info",
        title: "Funding Declined",
        message: `${receiverName} declined your \u20A6${parseFloat(txn.amount).toLocaleString()} wallet funding.`,
      });

      res.json(updated);
    } catch (error) {
      res.status(500).json({ error: "Failed to decline funding" });
    }
  });

  app.get("/api/admin/wallet-funding/transactions", isAuthenticated, requireRole(["admin", "super_admin", "finance"]), async (req: any, res) => {
    try {
      const { flagged, sender, receiver } = req.query;
      let query = db.select().from(walletFundingTransactions).orderBy(desc(walletFundingTransactions.createdAt)).limit(200);

      const txns = await query;
      let filtered = txns;
      if (flagged === "true") filtered = filtered.filter(t => t.flagged);
      if (sender) filtered = filtered.filter(t => t.senderUserId === sender);
      if (receiver) filtered = filtered.filter(t => t.receiverUserId === receiver);

      const allUserIds = [...new Set(filtered.flatMap(t => [t.senderUserId, t.receiverUserId]))];
      const userMap: Record<string, string> = {};
      if (allUserIds.length > 0) {
        const foundUsers = await db.select({ id: users.id, email: users.email, firstName: users.firstName, lastName: users.lastName })
          .from(users).where(inArray(users.id, allUserIds));
        for (const u of foundUsers) {
          userMap[u.id] = u.firstName && u.lastName ? `${u.firstName} ${u.lastName}` : u.email || "ZIBA User";
        }
      }

      res.json(filtered.map(t => ({
        ...t,
        senderName: userMap[t.senderUserId] || "Unknown",
        receiverName: userMap[t.receiverUserId] || "Unknown",
      })));
    } catch (error) {
      res.status(500).json({ error: "Failed to load funding transactions" });
    }
  });

  app.get("/api/admin/wallet-funding/settings", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      let [settings] = await db.select().from(walletFundingSettings).limit(1);
      if (!settings) {
        [settings] = await db.insert(walletFundingSettings).values({}).returning();
      }
      res.json(settings);
    } catch (error) {
      res.status(500).json({ error: "Failed to load funding settings" });
    }
  });

  app.put("/api/admin/wallet-funding/settings", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { dailyLimit, monthlyLimit, minAmount, maxAmount, selfFundingAllowed, repeatFundingThreshold, isEnabled } = req.body;
      let [settings] = await db.select().from(walletFundingSettings).limit(1);
      if (!settings) {
        [settings] = await db.insert(walletFundingSettings).values({}).returning();
      }
      const updates: any = { updatedAt: new Date() };
      if (dailyLimit !== undefined) updates.dailyLimit = String(dailyLimit);
      if (monthlyLimit !== undefined) updates.monthlyLimit = String(monthlyLimit);
      if (minAmount !== undefined) updates.minAmount = String(minAmount);
      if (maxAmount !== undefined) updates.maxAmount = String(maxAmount);
      if (selfFundingAllowed !== undefined) updates.selfFundingAllowed = selfFundingAllowed;
      if (repeatFundingThreshold !== undefined) updates.repeatFundingThreshold = repeatFundingThreshold;
      if (isEnabled !== undefined) updates.isEnabled = isEnabled;

      const [updated] = await db.update(walletFundingSettings)
        .set(updates)
        .where(eq(walletFundingSettings.id, settings.id))
        .returning();
      res.json(updated);
    } catch (error) {
      res.status(500).json({ error: "Failed to update funding settings" });
    }
  });

  // =============================================
  // DIRECTOR FUNDING SYSTEM ROUTES
  // =============================================

  app.get("/api/director/funding/settings", isAuthenticated, requireRole(["director", "admin", "super_admin"]), async (req: any, res) => {
    try {
      let [settings] = await db.select().from(directorFundingSettings).limit(1);
      if (!settings) {
        [settings] = await db.insert(directorFundingSettings).values({}).returning();
      }
      res.json(settings);
    } catch (error) {
      res.status(500).json({ error: "Failed to load director funding settings" });
    }
  });

  app.get("/api/director/funding/acceptance", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const [acceptance] = await db.select().from(directorFundingAcceptance)
        .where(eq(directorFundingAcceptance.userId, userId))
        .limit(1);
      res.json({ accepted: !!acceptance, acceptance });
    } catch (error) {
      res.status(500).json({ error: "Failed to check acceptance" });
    }
  });

  app.post("/api/director/funding/acceptance", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const userRoles = req.user.claims.roles || [];
      const role = userRoles.includes("director") ? "director" : userRoles.includes("driver") ? "driver" : "user";
      const ip = req.headers["x-forwarded-for"] || req.socket.remoteAddress || "unknown";
      const ua = req.headers["user-agent"] || "unknown";

      const [existing] = await db.select().from(directorFundingAcceptance)
        .where(eq(directorFundingAcceptance.userId, userId))
        .limit(1);
      if (existing) {
        return res.json({ accepted: true, acceptance: existing });
      }

      const [acceptance] = await db.insert(directorFundingAcceptance).values({
        userId,
        userRole: role,
        ipAddress: ip,
        userAgent: ua,
      }).returning();

      res.json({ accepted: true, acceptance });
    } catch (error) {
      res.status(500).json({ error: "Failed to record acceptance" });
    }
  });

  app.get("/api/director/funding/eligible-drivers", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const profile = await storage.getDirectorProfile(userId);
      if (!profile || profile.status !== "active") {
        return res.status(403).json({ message: "Director must be active to fund drivers" });
      }

      const assignments = await db.select().from(directorDriverAssignments)
        .where(eq(directorDriverAssignments.directorUserId, userId));

      const drivers = [];
      for (const assignment of assignments) {
        const [driver] = await db.select().from(driverProfiles)
          .where(eq(driverProfiles.userId, assignment.driverUserId));
        if (driver && driver.status === "approved") {
          drivers.push({
            userId: driver.userId,
            fullName: driver.fullName,
            phone: driver.phone,
            status: driver.status,
            isOnline: driver.isOnline,
            walletBalance: driver.walletBalance,
            cellNumber: assignment.cellNumber,
          });
        }
      }

      res.json(drivers);
    } catch (error) {
      res.status(500).json({ error: "Failed to load eligible drivers" });
    }
  });

  app.get("/api/director/funding/limits", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      let [settings] = await db.select().from(directorFundingSettings).limit(1);
      if (!settings) {
        [settings] = await db.insert(directorFundingSettings).values({}).returning();
      }

      const now = new Date();
      const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const startOfWeek = new Date(startOfDay);
      startOfWeek.setDate(startOfWeek.getDate() - startOfWeek.getDay());
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);

      const dailyTxns = await db.select({ total: sql<string>`COALESCE(SUM(amount::numeric), 0)` })
        .from(directorFundingTransactions)
        .where(and(
          eq(directorFundingTransactions.directorUserId, userId),
          gte(directorFundingTransactions.createdAt, startOfDay),
          eq(directorFundingTransactions.status, "completed")
        ));

      const weeklyTxns = await db.select({ total: sql<string>`COALESCE(SUM(amount::numeric), 0)` })
        .from(directorFundingTransactions)
        .where(and(
          eq(directorFundingTransactions.directorUserId, userId),
          gte(directorFundingTransactions.createdAt, startOfWeek),
          eq(directorFundingTransactions.status, "completed")
        ));

      const monthlyTxns = await db.select({ total: sql<string>`COALESCE(SUM(amount::numeric), 0)` })
        .from(directorFundingTransactions)
        .where(and(
          eq(directorFundingTransactions.directorUserId, userId),
          gte(directorFundingTransactions.createdAt, startOfMonth),
          eq(directorFundingTransactions.status, "completed")
        ));

      const dailyUsed = parseFloat(dailyTxns[0]?.total || "0");
      const weeklyUsed = parseFloat(weeklyTxns[0]?.total || "0");
      const monthlyUsed = parseFloat(monthlyTxns[0]?.total || "0");

      res.json({
        perTransactionMin: settings.perTransactionMin,
        perTransactionMax: settings.perTransactionMax,
        daily: { limit: settings.perDirectorDailyLimit, used: dailyUsed.toFixed(2), remaining: Math.max(0, parseFloat(settings.perDirectorDailyLimit) - dailyUsed).toFixed(2) },
        weekly: { limit: settings.perDirectorWeeklyLimit, used: weeklyUsed.toFixed(2), remaining: Math.max(0, parseFloat(settings.perDirectorWeeklyLimit) - weeklyUsed).toFixed(2) },
        monthly: { limit: settings.perDirectorMonthlyLimit, used: monthlyUsed.toFixed(2), remaining: Math.max(0, parseFloat(settings.perDirectorMonthlyLimit) - monthlyUsed).toFixed(2) },
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to load funding limits" });
    }
  });

  app.get("/api/director/funding/driver-limits/:driverUserId", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const directorId = req.user.claims.sub;
      const { driverUserId } = req.params;

      let [settings] = await db.select().from(directorFundingSettings).limit(1);
      if (!settings) {
        [settings] = await db.insert(directorFundingSettings).values({}).returning();
      }

      const now = new Date();
      const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const startOfWeek = new Date(startOfDay);
      startOfWeek.setDate(startOfWeek.getDate() - startOfWeek.getDay());
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);

      const dailyTxns = await db.select({ total: sql<string>`COALESCE(SUM(amount::numeric), 0)` })
        .from(directorFundingTransactions)
        .where(and(
          eq(directorFundingTransactions.directorUserId, directorId),
          eq(directorFundingTransactions.driverUserId, driverUserId),
          gte(directorFundingTransactions.createdAt, startOfDay),
          eq(directorFundingTransactions.status, "completed")
        ));

      const weeklyTxns = await db.select({ total: sql<string>`COALESCE(SUM(amount::numeric), 0)` })
        .from(directorFundingTransactions)
        .where(and(
          eq(directorFundingTransactions.directorUserId, directorId),
          eq(directorFundingTransactions.driverUserId, driverUserId),
          gte(directorFundingTransactions.createdAt, startOfWeek),
          eq(directorFundingTransactions.status, "completed")
        ));

      const monthlyTxns = await db.select({ total: sql<string>`COALESCE(SUM(amount::numeric), 0)` })
        .from(directorFundingTransactions)
        .where(and(
          eq(directorFundingTransactions.directorUserId, directorId),
          eq(directorFundingTransactions.driverUserId, driverUserId),
          gte(directorFundingTransactions.createdAt, startOfMonth),
          eq(directorFundingTransactions.status, "completed")
        ));

      const dailyUsed = parseFloat(dailyTxns[0]?.total || "0");
      const weeklyUsed = parseFloat(weeklyTxns[0]?.total || "0");
      const monthlyUsed = parseFloat(monthlyTxns[0]?.total || "0");

      res.json({
        daily: { limit: settings.perDriverDailyLimit, used: dailyUsed.toFixed(2), remaining: Math.max(0, parseFloat(settings.perDriverDailyLimit) - dailyUsed).toFixed(2) },
        weekly: { limit: settings.perDriverWeeklyLimit, used: weeklyUsed.toFixed(2), remaining: Math.max(0, parseFloat(settings.perDriverWeeklyLimit) - weeklyUsed).toFixed(2) },
        monthly: { limit: settings.perDriverMonthlyLimit, used: monthlyUsed.toFixed(2), remaining: Math.max(0, parseFloat(settings.perDriverMonthlyLimit) - monthlyUsed).toFixed(2) },
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to load driver funding limits" });
    }
  });

  app.post("/api/director/funding/send", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const directorUserId = req.user.claims.sub;
      const { driverUserId, amount, purposeTag, disclaimerAccepted } = req.body;
      const ip = req.headers["x-forwarded-for"] || req.socket.remoteAddress || "unknown";

      if (!driverUserId || !amount || !purposeTag || !disclaimerAccepted) {
        return res.status(400).json({ message: "All fields including disclaimer acceptance are required" });
      }

      const parsedAmount = parseFloat(amount);
      if (isNaN(parsedAmount) || parsedAmount <= 0) {
        return res.status(400).json({ message: "Invalid amount" });
      }

      let [settings] = await db.select().from(directorFundingSettings).limit(1);
      if (!settings) {
        [settings] = await db.insert(directorFundingSettings).values({}).returning();
      }

      if (!settings.isEnabled) {
        return res.status(403).json({ message: "Director funding is currently disabled" });
      }

      const profile = await storage.getDirectorProfile(directorUserId);
      if (!profile || profile.status !== "active") {
        return res.status(403).json({ message: "Director must be active" });
      }

      const [suspension] = await db.select().from(directorFundingSuspensions)
        .where(and(
          eq(directorFundingSuspensions.directorUserId, directorUserId),
          eq(directorFundingSuspensions.isActive, true)
        ))
        .limit(1);
      if (suspension) {
        return res.status(403).json({ message: "Your funding ability is currently suspended pending admin review" });
      }

      const assignments = await db.select().from(directorDriverAssignments)
        .where(eq(directorDriverAssignments.directorUserId, directorUserId));
      if (assignments.length < settings.minDriversRequired) {
        return res.status(403).json({ message: `Director must have at least ${settings.minDriversRequired} assigned drivers to use funding` });
      }

      const isAssigned = assignments.some(a => a.driverUserId === driverUserId);
      if (!isAssigned) {
        return res.status(403).json({ message: "Driver is not assigned to your cell" });
      }

      const [driver] = await db.select().from(driverProfiles)
        .where(eq(driverProfiles.userId, driverUserId));
      if (!driver || driver.status !== "approved") {
        return res.status(400).json({ message: "Driver must be active and approved" });
      }

      if (parsedAmount < parseFloat(settings.perTransactionMin)) {
        return res.status(400).json({ message: `Minimum amount is ${settings.perTransactionMin}` });
      }
      if (parsedAmount > parseFloat(settings.perTransactionMax)) {
        return res.status(400).json({ message: `Maximum amount is ${settings.perTransactionMax}` });
      }

      const now = new Date();
      const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const startOfWeek = new Date(startOfDay);
      startOfWeek.setDate(startOfWeek.getDate() - startOfWeek.getDay());
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);

      const [dirDailyTotal] = await db.select({ total: sql<string>`COALESCE(SUM(amount::numeric), 0)` })
        .from(directorFundingTransactions)
        .where(and(
          eq(directorFundingTransactions.directorUserId, directorUserId),
          gte(directorFundingTransactions.createdAt, startOfDay),
          eq(directorFundingTransactions.status, "completed")
        ));
      if (parseFloat(dirDailyTotal?.total || "0") + parsedAmount > parseFloat(settings.perDirectorDailyLimit)) {
        return res.status(400).json({ message: "Director daily funding limit exceeded" });
      }

      const [dirWeeklyTotal] = await db.select({ total: sql<string>`COALESCE(SUM(amount::numeric), 0)` })
        .from(directorFundingTransactions)
        .where(and(
          eq(directorFundingTransactions.directorUserId, directorUserId),
          gte(directorFundingTransactions.createdAt, startOfWeek),
          eq(directorFundingTransactions.status, "completed")
        ));
      if (parseFloat(dirWeeklyTotal?.total || "0") + parsedAmount > parseFloat(settings.perDirectorWeeklyLimit)) {
        return res.status(400).json({ message: "Director weekly funding limit exceeded" });
      }

      const [dirMonthlyTotal] = await db.select({ total: sql<string>`COALESCE(SUM(amount::numeric), 0)` })
        .from(directorFundingTransactions)
        .where(and(
          eq(directorFundingTransactions.directorUserId, directorUserId),
          gte(directorFundingTransactions.createdAt, startOfMonth),
          eq(directorFundingTransactions.status, "completed")
        ));
      if (parseFloat(dirMonthlyTotal?.total || "0") + parsedAmount > parseFloat(settings.perDirectorMonthlyLimit)) {
        return res.status(400).json({ message: "Director monthly funding limit exceeded" });
      }

      const [drvDailyTotal] = await db.select({ total: sql<string>`COALESCE(SUM(amount::numeric), 0)` })
        .from(directorFundingTransactions)
        .where(and(
          eq(directorFundingTransactions.directorUserId, directorUserId),
          eq(directorFundingTransactions.driverUserId, driverUserId),
          gte(directorFundingTransactions.createdAt, startOfDay),
          eq(directorFundingTransactions.status, "completed")
        ));
      if (parseFloat(drvDailyTotal?.total || "0") + parsedAmount > parseFloat(settings.perDriverDailyLimit)) {
        return res.status(400).json({ message: "Per-driver daily funding limit exceeded" });
      }

      const [drvWeeklyTotal] = await db.select({ total: sql<string>`COALESCE(SUM(amount::numeric), 0)` })
        .from(directorFundingTransactions)
        .where(and(
          eq(directorFundingTransactions.directorUserId, directorUserId),
          eq(directorFundingTransactions.driverUserId, driverUserId),
          gte(directorFundingTransactions.createdAt, startOfWeek),
          eq(directorFundingTransactions.status, "completed")
        ));
      if (parseFloat(drvWeeklyTotal?.total || "0") + parsedAmount > parseFloat(settings.perDriverWeeklyLimit)) {
        return res.status(400).json({ message: "Per-driver weekly funding limit exceeded" });
      }

      const [drvMonthlyTotal] = await db.select({ total: sql<string>`COALESCE(SUM(amount::numeric), 0)` })
        .from(directorFundingTransactions)
        .where(and(
          eq(directorFundingTransactions.directorUserId, directorUserId),
          eq(directorFundingTransactions.driverUserId, driverUserId),
          gte(directorFundingTransactions.createdAt, startOfMonth),
          eq(directorFundingTransactions.status, "completed")
        ));
      if (parseFloat(drvMonthlyTotal?.total || "0") + parsedAmount > parseFloat(settings.perDriverMonthlyLimit)) {
        return res.status(400).json({ message: "Per-driver monthly funding limit exceeded" });
      }

      let flagged = false;
      let flagReason: string | null = null;

      const repeatWindow = new Date(now.getTime() - (settings.repeatFundingWindowHours * 60 * 60 * 1000));
      const [repeatCount] = await db.select({ cnt: count() })
        .from(directorFundingTransactions)
        .where(and(
          eq(directorFundingTransactions.directorUserId, directorUserId),
          eq(directorFundingTransactions.driverUserId, driverUserId),
          gte(directorFundingTransactions.createdAt, repeatWindow),
          eq(directorFundingTransactions.status, "completed")
        ));
      if ((repeatCount?.cnt || 0) >= settings.repeatFundingThreshold) {
        flagged = true;
        flagReason = `Repeat funding: ${repeatCount.cnt + 1} transactions to same driver within ${settings.repeatFundingWindowHours}h`;
      }

      if (parsedAmount >= parseFloat(settings.perTransactionMax) * 0.9) {
        flagged = true;
        flagReason = (flagReason ? flagReason + "; " : "") + "Amount near maximum per-transaction limit";
      }

      const [txn] = await db.insert(directorFundingTransactions).values({
        directorUserId,
        driverUserId,
        amount: parsedAmount.toFixed(2),
        purposeTag,
        disclaimerAccepted: true,
        flagged,
        flagReason,
        ipAddress: ip,
        status: "completed",
      }).returning();

      await db.update(driverProfiles)
        .set({ walletBalance: sql`(wallet_balance::numeric + ${parsedAmount})::text` })
        .where(eq(driverProfiles.userId, driverUserId));

      const [driverWallet] = await db.select().from(driverWallets)
        .where(eq(driverWallets.userId, driverUserId));
      if (driverWallet) {
        await db.update(driverWallets)
          .set({ balance: sql`(balance::numeric + ${parsedAmount})::text`, updatedAt: new Date() })
          .where(eq(driverWallets.userId, driverUserId));
      }

      await storage.createDirectorActionLog({
        actorId: directorUserId,
        actorRole: "director",
        action: "fund_driver",
        targetType: "driver",
        targetId: driverUserId,
        beforeState: null,
        afterState: JSON.stringify({ amount: parsedAmount, purposeTag, flagged, transactionId: txn.id }),
        metadata: JSON.stringify({ ip }),
      });

      try {
        const purposeLabels: Record<string, string> = {
          ride_fuel_support: "Ride fuel support",
          network_availability_boost: "Network availability boost",
          emergency_assistance: "Emergency assistance",
          temporary_balance_topup: "Temporary balance top-up",
        };
        const purposeLabel = purposeLabels[purposeTag] || purposeTag;

        await notificationService.createNotification(
          driverUserId,
          "wallet",
          "Director Support Received",
          `Your director has sent you ${parsedAmount.toFixed(2)} as ${purposeLabel}. This is voluntary support and not a loan.`,
          { transactionId: txn.id, amount: parsedAmount, purpose: purposeTag }
        );

        await notificationService.createNotification(
          directorUserId,
          "wallet",
          "Funding Sent",
          `You sent ${parsedAmount.toFixed(2)} to ${driver.fullName} as ${purposeLabel}.`,
          { transactionId: txn.id, driverUserId, amount: parsedAmount }
        );
      } catch (_notifError) {}

      if (flagged && settings.fundingSuspensionEnabled) {
        const [existingSuspension] = await db.select().from(directorFundingSuspensions)
          .where(and(
            eq(directorFundingSuspensions.directorUserId, directorUserId),
            eq(directorFundingSuspensions.isActive, true)
          ))
          .limit(1);
        if (!existingSuspension) {
          await db.insert(directorFundingSuspensions).values({
            directorUserId,
            reason: `Auto-suspended: ${flagReason}`,
            suspendedBy: "system",
          });

          await storage.createDirectorCoachingLog({
            directorUserId,
            coachingType: "funding_suspended",
            message: "Your funding ability has been temporarily suspended due to flagged activity. An admin will review your account.",
            severity: "critical",
          });
        }
      }

      res.json({ transaction: txn, flagged });
    } catch (error) {
      console.error("Director funding error:", error);
      res.status(500).json({ error: "Failed to process funding" });
    }
  });

  app.get("/api/director/funding/history", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const txns = await db.select().from(directorFundingTransactions)
        .where(eq(directorFundingTransactions.directorUserId, userId))
        .orderBy(desc(directorFundingTransactions.createdAt))
        .limit(100);

      const enriched = [];
      for (const txn of txns) {
        const [driver] = await db.select().from(driverProfiles)
          .where(eq(driverProfiles.userId, txn.driverUserId));
        enriched.push({
          ...txn,
          driverName: driver?.fullName || "Unknown Driver",
        });
      }

      res.json(enriched);
    } catch (error) {
      res.status(500).json({ error: "Failed to load funding history" });
    }
  });

  app.get("/api/director/funding/suspension-status", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const [suspension] = await db.select().from(directorFundingSuspensions)
        .where(and(
          eq(directorFundingSuspensions.directorUserId, userId),
          eq(directorFundingSuspensions.isActive, true)
        ))
        .limit(1);
      res.json({ suspended: !!suspension, suspension });
    } catch (error) {
      res.status(500).json({ error: "Failed to check suspension status" });
    }
  });

  // Admin Director Funding Routes
  app.get("/api/admin/director-funding/transactions", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { flagged, directorId } = req.query;
      let query = db.select().from(directorFundingTransactions).orderBy(desc(directorFundingTransactions.createdAt)).limit(200);

      let txns;
      if (flagged === "true" && directorId) {
        txns = await db.select().from(directorFundingTransactions)
          .where(and(eq(directorFundingTransactions.flagged, true), eq(directorFundingTransactions.directorUserId, directorId as string)))
          .orderBy(desc(directorFundingTransactions.createdAt)).limit(200);
      } else if (flagged === "true") {
        txns = await db.select().from(directorFundingTransactions)
          .where(eq(directorFundingTransactions.flagged, true))
          .orderBy(desc(directorFundingTransactions.createdAt)).limit(200);
      } else if (directorId) {
        txns = await db.select().from(directorFundingTransactions)
          .where(eq(directorFundingTransactions.directorUserId, directorId as string))
          .orderBy(desc(directorFundingTransactions.createdAt)).limit(200);
      } else {
        txns = await db.select().from(directorFundingTransactions)
          .orderBy(desc(directorFundingTransactions.createdAt)).limit(200);
      }

      const enriched = [];
      for (const txn of txns) {
        const dirProfile = await storage.getDirectorProfile(txn.directorUserId);
        const [driver] = await db.select().from(driverProfiles)
          .where(eq(driverProfiles.userId, txn.driverUserId));
        enriched.push({
          ...txn,
          directorName: dirProfile?.fullName || "Unknown Director",
          driverName: driver?.fullName || "Unknown Driver",
        });
      }

      res.json(enriched);
    } catch (error) {
      res.status(500).json({ error: "Failed to load director funding transactions" });
    }
  });

  app.get("/api/admin/director-funding/suspensions", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const suspensions = await db.select().from(directorFundingSuspensions)
        .orderBy(desc(directorFundingSuspensions.suspendedAt))
        .limit(100);

      const enriched = [];
      for (const s of suspensions) {
        const dirProfile = await storage.getDirectorProfile(s.directorUserId);
        enriched.push({
          ...s,
          directorName: dirProfile?.fullName || "Unknown Director",
        });
      }

      res.json(enriched);
    } catch (error) {
      res.status(500).json({ error: "Failed to load suspensions" });
    }
  });

  app.post("/api/admin/director-funding/suspend/:directorUserId", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { directorUserId } = req.params;
      const { reason } = req.body;

      const [existing] = await db.select().from(directorFundingSuspensions)
        .where(and(
          eq(directorFundingSuspensions.directorUserId, directorUserId),
          eq(directorFundingSuspensions.isActive, true)
        )).limit(1);

      if (existing) {
        return res.status(400).json({ message: "Director funding is already suspended" });
      }

      const [suspension] = await db.insert(directorFundingSuspensions).values({
        directorUserId,
        reason: reason || "Admin-initiated suspension",
        suspendedBy: adminId,
      }).returning();

      await storage.createDirectorActionLog({
        actorId: adminId,
        actorRole: "admin",
        action: "suspend_director_funding",
        targetType: "director",
        targetId: directorUserId,
        beforeState: null,
        afterState: JSON.stringify({ suspensionId: suspension.id, reason }),
      });

      res.json(suspension);
    } catch (error) {
      res.status(500).json({ error: "Failed to suspend director funding" });
    }
  });

  app.post("/api/admin/director-funding/lift-suspension/:directorUserId", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      const { directorUserId } = req.params;

      const [suspension] = await db.select().from(directorFundingSuspensions)
        .where(and(
          eq(directorFundingSuspensions.directorUserId, directorUserId),
          eq(directorFundingSuspensions.isActive, true)
        )).limit(1);

      if (!suspension) {
        return res.status(400).json({ message: "No active suspension found" });
      }

      await db.update(directorFundingSuspensions)
        .set({ isActive: false, liftedAt: new Date(), liftedBy: adminId })
        .where(eq(directorFundingSuspensions.id, suspension.id));

      await storage.createDirectorActionLog({
        actorId: adminId,
        actorRole: "admin",
        action: "lift_director_funding_suspension",
        targetType: "director",
        targetId: directorUserId,
        beforeState: JSON.stringify({ suspensionId: suspension.id }),
        afterState: JSON.stringify({ lifted: true }),
      });

      res.json({ message: "Suspension lifted" });
    } catch (error) {
      res.status(500).json({ error: "Failed to lift suspension" });
    }
  });

  app.put("/api/admin/director-funding/settings", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminId = req.user.claims.sub;
      let [settings] = await db.select().from(directorFundingSettings).limit(1);
      if (!settings) {
        [settings] = await db.insert(directorFundingSettings).values({}).returning();
      }

      const updates: any = { updatedAt: new Date(), updatedBy: adminId };
      const allowedFields = [
        "isEnabled", "perTransactionMin", "perTransactionMax",
        "perDriverDailyLimit", "perDriverWeeklyLimit", "perDriverMonthlyLimit",
        "perDirectorDailyLimit", "perDirectorWeeklyLimit", "perDirectorMonthlyLimit",
        "minDriversRequired", "repeatFundingThreshold", "repeatFundingWindowHours",
        "fundingSuspensionEnabled"
      ];

      for (const field of allowedFields) {
        if (req.body[field] !== undefined) {
          if (typeof req.body[field] === "number" && !["minDriversRequired", "repeatFundingThreshold", "repeatFundingWindowHours"].includes(field) && typeof req.body[field] !== "boolean") {
            updates[field] = String(req.body[field]);
          } else {
            updates[field] = req.body[field];
          }
        }
      }

      const [updated] = await db.update(directorFundingSettings)
        .set(updates)
        .where(eq(directorFundingSettings.id, settings.id))
        .returning();

      await storage.createDirectorActionLog({
        actorId: adminId,
        actorRole: "super_admin",
        action: "update_director_funding_settings",
        targetType: "settings",
        targetId: settings.id,
        beforeState: JSON.stringify(settings),
        afterState: JSON.stringify(updated),
      });

      res.json(updated);
    } catch (error) {
      res.status(500).json({ error: "Failed to update director funding settings" });
    }
  });

  app.post("/api/driver/report-coercion", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const driverUserId = req.user.claims.sub;
      const { directorUserId, description } = req.body;

      if (!description) {
        return res.status(400).json({ message: "Description is required" });
      }

      const [assignment] = await db.select().from(directorDriverAssignments)
        .where(eq(directorDriverAssignments.driverUserId, driverUserId))
        .limit(1);

      const resolvedDirectorId = directorUserId || assignment?.directorUserId;
      if (!resolvedDirectorId) {
        return res.status(400).json({ message: "Could not determine director" });
      }

      await db.insert(directorFundingSuspensions).values({
        directorUserId: resolvedDirectorId,
        reason: `Coercion report from driver ${driverUserId}: ${description}`,
        suspendedBy: "system",
      });

      await storage.createDirectorActionLog({
        actorId: driverUserId,
        actorRole: "driver",
        action: "report_coercion",
        targetType: "director",
        targetId: resolvedDirectorId,
        beforeState: null,
        afterState: JSON.stringify({ description }),
      });

      try {
        const admins = await db.select().from(users)
          .where(sql`roles::text LIKE '%admin%'`);
        for (const admin of admins) {
          await notificationService.createNotification(
            admin.id,
            "system",
            "Coercion Report",
            `Driver ${driverUserId} has reported potential coercion from a director. Funding has been paused pending review.`,
            { driverUserId, directorUserId: resolvedDirectorId }
          );
        }
      } catch (_notifError) {}

      res.json({ message: "Report submitted. The director's funding has been paused and admin has been notified." });
    } catch (error) {
      res.status(500).json({ error: "Failed to submit coercion report" });
    }
  });

  app.get("/api/director/analytics", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const [director] = await db.select().from(directorProfiles)
        .where(eq(directorProfiles.userId, userId));
      if (!director) return res.status(404).json({ error: "Director profile not found" });

      const assignments = await db.select().from(directorDriverAssignments)
        .where(eq(directorDriverAssignments.directorUserId, userId));
      const driverIds = assignments.map(a => a.driverUserId);

      const totalDrivers = driverIds.length;

      let activeDriversToday = 0;
      let commissionableToday = 0;
      let driversByStatus: Record<string, number> = {};

      if (driverIds.length > 0) {
        const driverProfs = await db.select().from(driverProfiles)
          .where(inArray(driverProfiles.userId, driverIds));

        activeDriversToday = driverProfs.filter(d => d.isOnline).length;

        const [commSettings] = await db.select().from(directorCommissionSettings).limit(1);
        const activeRatio = parseFloat(commSettings?.activeRatio || "0.77");
        const maxCommissionable = commSettings?.maxCommissionableDrivers || 1000;
        commissionableToday = Math.min(
          Math.floor(activeDriversToday * activeRatio),
          maxCommissionable
        );

        for (const d of driverProfs) {
          driversByStatus[d.status] = (driversByStatus[d.status] || 0) + 1;
        }
      }

      const weeklyGrowth: Array<{ week: string; count: number }> = [];
      for (let i = 3; i >= 0; i--) {
        const weekStart = new Date();
        weekStart.setDate(weekStart.getDate() - (i + 1) * 7);
        const weekEnd = new Date();
        weekEnd.setDate(weekEnd.getDate() - i * 7);
        const weekLabel = weekStart.toLocaleDateString(undefined, { month: "short", day: "numeric" });

        const assignedByWeek = assignments.filter(a => {
          const created = new Date(a.createdAt as any);
          return created <= weekEnd;
        });
        weeklyGrowth.push({ week: weekLabel, count: assignedByWeek.length });
      }

      let fundingCount = 0;
      let fundingThisMonth = 0;
      if (driverIds.length > 0) {
        const allFunding = await db.select().from(directorFundingTransactions)
          .where(eq(directorFundingTransactions.directorUserId, userId));
        fundingCount = allFunding.length;

        const startOfMonth = new Date();
        startOfMonth.setDate(1);
        startOfMonth.setHours(0, 0, 0, 0);
        fundingThisMonth = allFunding.filter(f => new Date(f.createdAt as any) >= startOfMonth).length;
      }

      let avgTrustScore = 0;
      let lowTrustCount = 0;
      if (driverIds.length > 0) {
        const trustProfiles = await db.select().from(userTrustProfiles)
          .where(inArray(userTrustProfiles.userId, driverIds));
        if (trustProfiles.length > 0) {
          const totalTrust = trustProfiles.reduce((sum, tp) => sum + (tp.trustScore || 100), 0);
          avgTrustScore = Math.round(totalTrust / trustProfiles.length);
          lowTrustCount = trustProfiles.filter(tp => (tp.trustScore || 100) < 60).length;
        } else {
          avgTrustScore = 100;
        }
      }

      const activityRatio = totalDrivers > 0 ? activeDriversToday / totalDrivers : 0;
      let cellHealthBadge: "healthy" | "at_risk" | "under_review" = "healthy";
      if (activityRatio < 0.5) cellHealthBadge = "under_review";
      else if (activityRatio < 0.77) cellHealthBadge = "at_risk";

      res.json({
        totalDrivers,
        activeDriversToday,
        commissionableToday,
        driversByStatus,
        weeklyGrowth,
        fundingCount,
        fundingThisMonth,
        avgTrustScore,
        lowTrustCount,
        cellHealthBadge,
        activityRatio: Math.round(activityRatio * 100),
        lifecycleStatus: director.lifecycleStatus,
        directorType: director.directorType,
        lifespanEndDate: director.lifespanEndDate,
      });
    } catch (error) {
      console.error("Director analytics error:", error);
      res.status(500).json({ error: "Failed to load analytics" });
    }
  });

  // =============================================
  // DIRECTOR REPORTS (READ-ONLY, SAFE)
  // =============================================

  app.get("/api/director/reports/daily", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const [director] = await db.select().from(directorProfiles)
        .where(eq(directorProfiles.userId, userId));
      if (!director) return res.status(404).json({ error: "Director profile not found" });

      if (director.lifecycleStatus === "suspended" || director.lifecycleStatus === "terminated") {
        return res.json({ readOnly: true, status: director.lifecycleStatus, message: "Your dashboard is in read-only mode." });
      }

      const assignments = await storage.getDriversUnderDirector(userId);
      const driverIds = assignments.map(a => a.driverUserId);
      const totalDrivers = driverIds.length;

      let activeDriversToday = 0;
      let suspendedDrivers = 0;
      if (driverIds.length > 0) {
        const driverProfs = await db.select().from(driverProfiles)
          .where(inArray(driverProfiles.userId, driverIds));
        activeDriversToday = driverProfs.filter(d => d.isOnline).length;
        suspendedDrivers = driverProfs.filter(d => d.status === "suspended").length;
      }

      const commSettings = await storage.getDirectorCommissionSettings();
      const activeRatio = parseFloat(commSettings?.activeRatio || "0.77");
      const maxComm = director.maxCommissionablePerDay || commSettings?.maxCommissionableDrivers || 1000;
      const commissionableDrivers = Math.min(Math.floor(activeDriversToday * activeRatio), maxComm);
      const activityRatio = totalDrivers > 0 ? Math.round((activeDriversToday / totalDrivers) * 100) : 0;

      const cells = await db.select().from(directorCells)
        .where(eq(directorCells.directorUserId, userId));
      const cellSummaries = cells.map(c => ({
        id: c.id,
        name: c.cellName,
        driverCount: 0,
        maxCapacity: c.maxDriverCapacity || 50,
      }));

      for (const cell of cellSummaries) {
        const cellAssignments = assignments.filter(a => a.cellId === cell.id);
        cell.driverCount = cellAssignments.length;
      }

      res.json({
        date: new Date().toISOString().split("T")[0],
        totalDrivers,
        activeDriversToday,
        commissionableDrivers,
        suspendedDrivers,
        activityRatio,
        cellSummaries,
        meetsActivationThreshold: totalDrivers >= (director.activationThreshold || 10),
        lifecycleStatus: director.lifecycleStatus,
        lifespanEndDate: director.lifespanEndDate,
      });
    } catch (error) {
      console.error("Director daily report error:", error);
      res.status(500).json({ error: "Failed to load daily report" });
    }
  });

  app.get("/api/director/reports/weekly", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const [director] = await db.select().from(directorProfiles)
        .where(eq(directorProfiles.userId, userId));
      if (!director) return res.status(404).json({ error: "Director profile not found" });

      const commissionLogs = await storage.getDirectorCommissionLogs(userId, 7);

      const dailyTrend = commissionLogs.map(log => ({
        date: log.date,
        activeDrivers: log.activeDriversToday,
        totalDrivers: log.totalDrivers,
        commissionableDrivers: log.commissionableDrivers,
        activityRatio: Math.round(parseFloat(log.activeRatio) * 100),
        directorStatus: log.directorStatus,
        meetsThreshold: log.meetsActivationThreshold,
      }));

      const avgActiveDrivers = commissionLogs.length > 0
        ? Math.round(commissionLogs.reduce((s, l) => s + l.activeDriversToday, 0) / commissionLogs.length)
        : 0;
      const avgCommissionable = commissionLogs.length > 0
        ? Math.round(commissionLogs.reduce((s, l) => s + l.commissionableDrivers, 0) / commissionLogs.length)
        : 0;

      const first = commissionLogs[commissionLogs.length - 1];
      const last = commissionLogs[0];
      const growthIndicator = first && last
        ? last.totalDrivers - first.totalDrivers
        : 0;

      const complianceDays = commissionLogs.filter(l => l.meetsActivationThreshold).length;
      const complianceRate = commissionLogs.length > 0
        ? Math.round((complianceDays / commissionLogs.length) * 100)
        : 0;

      res.json({
        period: "weekly",
        daysReported: commissionLogs.length,
        dailyTrend,
        avgActiveDrivers,
        avgCommissionable,
        growthIndicator,
        complianceRate,
        lifecycleStatus: director.lifecycleStatus,
      });
    } catch (error) {
      console.error("Director weekly report error:", error);
      res.status(500).json({ error: "Failed to load weekly report" });
    }
  });

  app.get("/api/director/reports/monthly", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Not authenticated" });

      const [director] = await db.select().from(directorProfiles)
        .where(eq(directorProfiles.userId, userId));
      if (!director) return res.status(404).json({ error: "Director profile not found" });

      const commissionLogs = await storage.getDirectorCommissionLogs(userId, 30);

      const weeklyBuckets: Array<{ week: number; avgActive: number; avgTotal: number; complianceRate: number }> = [];
      for (let w = 0; w < 4; w++) {
        const weekLogs = commissionLogs.slice(w * 7, (w + 1) * 7);
        if (weekLogs.length === 0) continue;
        const avgActive = Math.round(weekLogs.reduce((s, l) => s + l.activeDriversToday, 0) / weekLogs.length);
        const avgTotal = Math.round(weekLogs.reduce((s, l) => s + l.totalDrivers, 0) / weekLogs.length);
        const compliant = weekLogs.filter(l => l.meetsActivationThreshold).length;
        weeklyBuckets.push({
          week: w + 1,
          avgActive,
          avgTotal,
          complianceRate: Math.round((compliant / weekLogs.length) * 100),
        });
      }

      const perf = await db.select().from(directorPerformanceScores)
        .where(eq(directorPerformanceScores.directorUserId, userId))
        .orderBy(desc(directorPerformanceScores.calculatedAt))
        .limit(1);
      const performanceScore = perf[0]?.totalScore || null;
      const performanceTier = perf[0]?.tier || null;

      const firstWeek = weeklyBuckets[weeklyBuckets.length - 1];
      const lastWeek = weeklyBuckets[0];
      const monthlyGrowth = firstWeek && lastWeek
        ? lastWeek.avgTotal - firstWeek.avgTotal
        : 0;
      const trendDirection = monthlyGrowth > 0 ? "growing" : monthlyGrowth < 0 ? "declining" : "stable";

      res.json({
        period: "monthly",
        daysReported: commissionLogs.length,
        weeklyBuckets,
        performanceScore,
        performanceTier,
        monthlyGrowth,
        trendDirection,
        lifecycleStatus: director.lifecycleStatus,
      });
    } catch (error) {
      console.error("Director monthly report error:", error);
      res.status(500).json({ error: "Failed to load monthly report" });
    }
  });

  // ADMIN  VIEW ALL DIRECTOR REPORTS
  app.get("/api/admin/directors/reports", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const allDirectors = await db.select().from(directorProfiles);
      const directorUsers = await db.select().from(users)
        .where(inArray(users.id, allDirectors.map(d => d.userId)));

      const reports = [];
      for (const director of allDirectors) {
        const user = directorUsers.find(u => u.id === director.userId);
        const assignments = await storage.getDriversUnderDirector(director.userId);
        const commissionLogs = await storage.getDirectorCommissionLogs(director.userId, 7);

        let activeDriversToday = 0;
        if (assignments.length > 0) {
          const driverProfs = await db.select().from(driverProfiles)
            .where(inArray(driverProfiles.userId, assignments.map(a => a.driverUserId)));
          activeDriversToday = driverProfs.filter(d => d.isOnline).length;
        }

        const avgActive7d = commissionLogs.length > 0
          ? Math.round(commissionLogs.reduce((s, l) => s + l.activeDriversToday, 0) / commissionLogs.length)
          : 0;
        const complianceDays = commissionLogs.filter(l => l.meetsActivationThreshold).length;
        const complianceRate = commissionLogs.length > 0
          ? Math.round((complianceDays / commissionLogs.length) * 100)
          : 0;
        const activityRatio = assignments.length > 0
          ? Math.round((activeDriversToday / assignments.length) * 100)
          : 0;

        const perf = await db.select().from(directorPerformanceScores)
          .where(eq(directorPerformanceScores.directorUserId, director.userId))
          .orderBy(desc(directorPerformanceScores.calculatedAt))
          .limit(1);

        reports.push({
          directorUserId: director.userId,
          name: user ? `${user.firstName || ""} ${user.lastName || ""}`.trim() || user.username || "Unknown" : "Unknown",
          directorType: director.directorType,
          lifecycleStatus: director.lifecycleStatus,
          totalDrivers: assignments.length,
          activeDriversToday,
          activityRatio,
          avgActive7d,
          complianceRate,
          performanceScore: perf[0]?.totalScore || null,
          performanceTier: perf[0]?.tier || null,
          lifespanEndDate: director.lifespanEndDate,
          commissionFrozen: director.commissionFrozen,
        });
      }

      res.json({ reports });
    } catch (error) {
      console.error("Admin director reports error:", error);
      res.status(500).json({ error: "Failed to load director reports" });
    }
  });

  // ADMIN  FLAG DIRECTOR FOR REVIEW
  app.post("/api/admin/directors/:directorUserId/flag", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { directorUserId } = req.params;
      const { reason } = req.body;
      const actorId = req.user?.claims?.sub;
      const userRoles = await storage.getUserRoles(actorId);
      const actorRole = userRoles.includes("super_admin") ? "super_admin" : "admin";

      await db.insert(directorActionLogs).values({
        actorId,
        actorRole,
        action: "flag_for_review",
        targetType: "director",
        targetId: directorUserId,
        afterState: JSON.stringify({ reason }),
        metadata: JSON.stringify({ reason }),
      });

      await storage.createNotification({
        userId: directorUserId,
        type: "system",
        title: "Account Under Review",
        message: "Your director account has been flagged for administrative review. No action is required at this time.",
      });

      res.json({ success: true, message: "Director flagged for review" });
    } catch (error) {
      console.error("Flag director error:", error);
      res.status(500).json({ error: "Failed to flag director" });
    }
  });

  app.get("/api/director/oversight-signals", isAuthenticated, requireRole(["director", "admin", "super_admin"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const targetDirectorId = req.query.directorId || userId;

      const [director] = await db.select().from(directorProfiles)
        .where(eq(directorProfiles.userId, targetDirectorId as string));
      if (!director) return res.status(404).json({ error: "Director not found" });

      const signals: Array<{ type: string; severity: "info" | "warning" | "critical"; message: string; triggeredAt: string }> = [];
      const now = new Date();

      if (director.lifespanEndDate) {
        const endDate = new Date(director.lifespanEndDate);
        const daysLeft = Math.ceil((endDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));

        if (daysLeft <= 0) {
          signals.push({
            type: "contract_expired",
            severity: "critical",
            message: "Your director contract has expired.",
            triggeredAt: now.toISOString(),
          });
        } else if (daysLeft <= 7) {
          signals.push({
            type: "contract_expiry_imminent",
            severity: "critical",
            message: `Your director contract expires in ${daysLeft} day${daysLeft === 1 ? "" : "s"}.`,
            triggeredAt: now.toISOString(),
          });
        } else if (daysLeft <= 14) {
          signals.push({
            type: "contract_expiry_warning",
            severity: "warning",
            message: `Your director contract expires in ${daysLeft} days.`,
            triggeredAt: now.toISOString(),
          });
        }
      }

      const assignments = await db.select().from(directorDriverAssignments)
        .where(eq(directorDriverAssignments.directorUserId, targetDirectorId as string));
      const maxCell = director.maxCellSize || 1300;
      const cellUsage = assignments.length / maxCell;

      if (cellUsage >= 0.95) {
        signals.push({
          type: "cell_limit_critical",
          severity: "critical",
          message: `Your driver cell is at ${Math.round(cellUsage * 100)}% capacity (${assignments.length}/${maxCell}).`,
          triggeredAt: now.toISOString(),
        });
      } else if (cellUsage >= 0.85) {
        signals.push({
          type: "cell_limit_warning",
          severity: "warning",
          message: `Your driver cell is approaching capacity (${assignments.length}/${maxCell} drivers).`,
          triggeredAt: now.toISOString(),
        });
      }

      if (assignments.length >= 10) {
        const assignmentDriverIds = assignments.map(a => a.driverUserId);
        const drivers = await db.select().from(driverProfiles)
          .where(inArray(driverProfiles.userId, assignmentDriverIds));
        const activeCount = drivers.filter(d => d.isOnline).length;
        const activityRatio = activeCount / assignments.length;

        if (activityRatio < 0.3) {
          signals.push({
            type: "low_activity",
            severity: "warning",
            message: `Driver activity under your cell dropped. Only ${activeCount} of ${assignments.length} drivers are active.`,
            triggeredAt: now.toISOString(),
          });
        }
      }

      const sevenDaysAgo = new Date();
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

      const recentFunding = await db.select().from(directorFundingTransactions)
        .where(and(
          eq(directorFundingTransactions.directorUserId, targetDirectorId as string),
          gte(directorFundingTransactions.createdAt, sevenDaysAgo)
        ));

      if (recentFunding.length > 10) {
        signals.push({
          type: "excessive_funding",
          severity: "warning",
          message: `You have made ${recentFunding.length} funding transactions in the past 7 days. Some actions may require Admin confirmation.`,
          triggeredAt: now.toISOString(),
        });
      }

      const recentSuspensions = await db.select().from(directorActionLogs)
        .where(and(
          eq(directorActionLogs.actorId, targetDirectorId as string),
          eq(directorActionLogs.action, "suspend_driver"),
          gte(directorActionLogs.createdAt, sevenDaysAgo)
        ));

      if (recentSuspensions.length >= 3) {
        signals.push({
          type: "repeated_discipline",
          severity: "warning",
          message: `Multiple driver suspensions detected (${recentSuspensions.length} in 7 days). This may trigger an Admin review.`,
          triggeredAt: now.toISOString(),
        });
      }

      const recentPayouts = await db.select().from(directorPayoutSummaries)
        .where(eq(directorPayoutSummaries.directorUserId, targetDirectorId as string))
        .orderBy(desc(directorPayoutSummaries.createdAt))
        .limit(10);

      const heldPayouts = recentPayouts.filter(p => p.payoutState === "held");
      if (heldPayouts.length > 0) {
        signals.push({
          type: "payout_held",
          severity: heldPayouts.length >= 3 ? "critical" : "warning",
          message: `${heldPayouts.length} payout(s) currently on hold. Contact support if you have questions.`,
          triggeredAt: now.toISOString(),
        });
      }

      const reversedPayouts = recentPayouts.filter(p => p.payoutState === "reversed");
      if (reversedPayouts.length > 0) {
        signals.push({
          type: "payout_reversed",
          severity: "critical",
          message: `${reversedPayouts.length} payout(s) have been reversed. Review your earnings tab for details.`,
          triggeredAt: now.toISOString(),
        });
      }

      const pendingDisputes = recentPayouts.filter(p => p.disputeSubmitted && !p.disputeResolvedAt);
      if (pendingDisputes.length > 0) {
        signals.push({
          type: "payout_dispute_pending",
          severity: "info",
          message: `${pendingDisputes.length} payout dispute(s) are under review.`,
          triggeredAt: now.toISOString(),
        });
      }

      if (director.commissionFrozen) {
        signals.push({
          type: "commission_frozen",
          severity: "critical",
          message: "Your commission is currently frozen. No payouts will be processed until lifted by an administrator.",
          triggeredAt: now.toISOString(),
        });
      }

      res.json({ signals });
    } catch (error) {
      console.error("Oversight signals error:", error);
      res.status(500).json({ error: "Failed to load oversight signals" });
    }
  });

  app.get("/api/director/earnings", isAuthenticated, requireRole(["director", "admin", "super_admin"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const directorUserId = req.query.directorId || userId;
      const userRoles = await storage.getUserRoles(userId);
      const isAdmin = userRoles.includes("admin") || userRoles.includes("super_admin");
      if (directorUserId !== userId && !isAdmin) {
        return res.status(403).json({ error: "Access denied" });
      }
      const [director] = await db.select().from(directorProfiles)
        .where(eq(directorProfiles.userId, directorUserId));
      if (!director) return res.status(404).json({ error: "Director not found" });
      const metrics = await storage.getDirectorDailyMetrics(directorUserId);
      const payouts = await db.select().from(directorPayoutSummaries)
        .where(eq(directorPayoutSummaries.directorUserId, directorUserId))
        .orderBy(desc(directorPayoutSummaries.createdAt))
        .limit(30);
      const commissionLogs = await storage.getDirectorCommissionLogs(directorUserId, 30);
      const todayDate = new Date().toISOString().split("T")[0];
      const todayPayout = payouts.find(p => p.periodDate === todayDate);
      const lastReleased = payouts.find(p => p.payoutState === "released" || p.payoutStatus === "released");
      const heldPayouts = payouts.filter(p => p.payoutState === "held" || p.payoutStatus === "on_hold");
      const disputeablePayouts = payouts.filter(p => (p.payoutState === "held" || p.payoutState === "reversed") && !p.disputeSubmitted);
      const history = commissionLogs.map(log => {
        const matchingPayout = payouts.find(p => p.periodDate === log.date);
        return {
          date: log.date,
          activeDrivers: log.activeDriversToday,
          commissionableDrivers: log.commissionableDrivers,
          payoutStatus: matchingPayout?.payoutStatus || "pending",
          payoutState: matchingPayout?.payoutState || "calculating",
        };
      });
      res.json({
        activeDriversToday: metrics.activeDriversToday,
        commissionableDriversToday: metrics.commissionableDrivers,
        eligibleDrivers: metrics.commissionableDrivers,
        estimatedEarnings: todayPayout?.estimatedEarnings || "0",
        payoutStatus: todayPayout?.payoutStatus || "pending",
        payoutState: todayPayout?.payoutState || "calculating",
        commissionFrozen: director.commissionFrozen,
        lifecycleStatus: director.lifecycleStatus,
        lastPayoutDate: lastReleased?.releasedAt ? new Date(lastReleased.releasedAt).toISOString() : null,
        heldCount: heldPayouts.length,
        holdNotice: heldPayouts.length > 0 ? "Your payout is currently under review due to compliance checks. No action is required at this time." : null,
        disputeablePayouts: disputeablePayouts.map(p => ({
          id: p.id, periodDate: p.periodDate, payoutState: p.payoutState, estimatedEarnings: p.estimatedEarnings,
        })),
        payouts: payouts.map(p => ({
          id: p.id, periodDate: p.periodDate, payoutState: p.payoutState, payoutStatus: p.payoutStatus,
          estimatedEarnings: p.estimatedEarnings, partialReleaseAmount: p.partialReleaseAmount,
          releasedAt: p.releasedAt, disputeSubmitted: p.disputeSubmitted,
        })),
        history,
        legalDisclaimer: "Director earnings are estimates based on platform activity and subject to eligibility rules, caps, compliance reviews, and administrative approval. ZIBA does not guarantee earnings, payout timing, or amounts.",
      });
    } catch (error) {
      console.error("Director earnings error:", error);
      res.status(500).json({ error: "Failed to load earnings data" });
    }
  });

  app.get("/api/admin/directors/:directorUserId/earnings", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { directorUserId } = req.params;
      const [director] = await db.select().from(directorProfiles)
        .where(eq(directorProfiles.userId, directorUserId));
      if (!director) return res.status(404).json({ error: "Director not found" });
      const metrics = await storage.getDirectorDailyMetrics(directorUserId);
      const settings = await storage.getDirectorCommissionSettings();
      const payouts = await db.select().from(directorPayoutSummaries)
        .where(eq(directorPayoutSummaries.directorUserId, directorUserId))
        .orderBy(desc(directorPayoutSummaries.createdAt))
        .limit(60);
      const commissionLogs = await storage.getDirectorCommissionLogs(directorUserId, 60);
      const history = commissionLogs.map(log => {
        const matchingPayout = payouts.find(p => p.periodDate === log.date);
        return {
          date: log.date,
          totalDrivers: log.totalDrivers,
          activeDrivers: log.activeDriversToday,
          commissionableDrivers: log.commissionableDrivers,
          commissionRate: log.commissionRate,
          activeRatio: log.activeRatio,
          estimatedEarnings: matchingPayout?.estimatedEarnings || "0",
          payoutStatus: matchingPayout?.payoutStatus || "pending",
          payoutState: matchingPayout?.payoutState || "calculating",
          capEnforced: matchingPayout?.capEnforced || false,
          fraudFlagged: matchingPayout?.fraudFlagged || false,
          zibraFlagged: matchingPayout?.zibraFlagged || false,
          zibraFlagReason: matchingPayout?.zibraFlagReason,
          adminNotes: matchingPayout?.adminNotes,
          holdReason: matchingPayout?.holdReason,
          releasedAt: matchingPayout?.releasedAt,
          releasedBy: matchingPayout?.releasedBy,
          approvedBy: matchingPayout?.approvedBy,
          approvedAt: matchingPayout?.approvedAt,
          reversedAt: matchingPayout?.reversedAt,
          reversedBy: matchingPayout?.reversedBy,
          reversalReason: matchingPayout?.reversalReason,
          partialReleaseAmount: matchingPayout?.partialReleaseAmount,
          disputeSubmitted: matchingPayout?.disputeSubmitted || false,
          disputeExplanation: matchingPayout?.disputeExplanation,
          disputeReviewedBy: matchingPayout?.disputeReviewedBy,
          disputeReviewNotes: matchingPayout?.disputeReviewNotes,
          eligibilitySnapshot: matchingPayout?.eligibilitySnapshot,
          payoutId: matchingPayout?.id,
        };
      });
      res.json({
        director: {
          userId: director.userId,
          fullName: director.fullName,
          directorType: director.directorType,
          commissionRatePercent: director.commissionRatePercent,
          maxCommissionablePerDay: director.maxCommissionablePerDay,
          commissionFrozen: director.commissionFrozen,
          lifecycleStatus: director.lifecycleStatus,
        },
        todayMetrics: {
          totalDrivers: metrics.totalDrivers,
          activeDriversToday: metrics.activeDriversToday,
          commissionableDrivers: metrics.commissionableDrivers,
          suspendedDrivers: metrics.suspendedDrivers,
        },
        globalSettings: {
          commissionRate: settings?.commissionRate || "0.12",
          activeRatio: settings?.activeRatio || "0.77",
          maxCommissionableDrivers: settings?.maxCommissionableDrivers || 1000,
          maxCellSize: settings?.maxCellSize || 1300,
        },
        history,
        payouts,
      });
    } catch (error) {
      console.error("Admin director earnings error:", error);
      res.status(500).json({ error: "Failed to load earnings data" });
    }
  });

  app.post("/api/admin/directors/:directorUserId/payout", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user?.claims?.sub;
      const adminRoles = await storage.getUserRoles(adminUserId);
      const isSuperAdmin = adminRoles.includes("super_admin");
      const { directorUserId } = req.params;
      const { action, payoutId, reason, periodDate, periodStart, periodEnd, payoutCadence, partialAmount, scheduledDate, adminNotes } = req.body;
      const validActions = ["create", "approve", "schedule", "release", "hold", "reverse", "partial_release", "force_release", "force_hold"];
      if (!action || !validActions.includes(action)) {
        return res.status(400).json({ error: `action must be one of: ${validActions.join(", ")}` });
      }
      const superAdminOnly = ["force_release", "force_hold", "reverse", "create"];
      if (superAdminOnly.includes(action) && !isSuperAdmin) {
        return res.status(403).json({ error: "This action requires Super Admin privileges" });
      }
      const [director] = await db.select().from(directorProfiles)
        .where(eq(directorProfiles.userId, directorUserId));
      if (!director) return res.status(404).json({ error: "Director not found" });

      if (action === "create") {
        const targetDate = periodDate || new Date().toISOString().split("T")[0];
        const metrics = await storage.getDirectorDailyMetrics(directorUserId);
        const commissionRate = director.commissionRatePercent / 100;
        const estimated = (metrics.commissionableDrivers * commissionRate * 100).toFixed(2);
        const capLimit = director.maxCommissionablePerDay || 1000;
        const snapshot = JSON.stringify({
          totalDrivers: metrics.totalDrivers,
          activeDriversToday: metrics.activeDriversToday,
          commissionableDrivers: metrics.commissionableDrivers,
          suspendedDrivers: metrics.suspendedDrivers,
          commissionRatePercent: director.commissionRatePercent,
          maxCommissionablePerDay: capLimit,
          activeRatioRequired: 0.77,
          directorType: director.directorType,
          lifecycleStatus: director.lifecycleStatus,
          commissionFrozen: director.commissionFrozen,
          capturedAt: new Date().toISOString(),
        });
        const shouldAutoHold = director.commissionFrozen || director.lifecycleStatus === "suspended" || director.lifecycleStatus === "expired";
        const [payout] = await db.insert(directorPayoutSummaries).values({
          directorUserId,
          periodDate: targetDate,
          periodStart: periodStart || targetDate,
          periodEnd: periodEnd || targetDate,
          payoutCadence: payoutCadence || (director.directorType === "contract" ? "monthly" : "monthly"),
          activeDrivers: metrics.activeDriversToday,
          commissionableDrivers: metrics.commissionableDrivers,
          eligibleDrivers: metrics.commissionableDrivers,
          estimatedEarnings: estimated,
          commissionRateApplied: String(director.commissionRatePercent),
          capEnforced: metrics.commissionableDrivers >= capLimit,
          payoutState: shouldAutoHold ? "held" : "pending_review",
          payoutStatus: shouldAutoHold ? "on_hold" : "pending",
          eligibilitySnapshot: snapshot,
          holdReason: shouldAutoHold ? (director.commissionFrozen ? "Commission frozen" : `Director ${director.lifecycleStatus}`) : null,
          heldBy: shouldAutoHold ? "system" : null,
          heldAt: shouldAutoHold ? new Date() : null,
          zibraFlagged: shouldAutoHold,
          zibraFlagReason: shouldAutoHold ? `Auto-held: director status is ${director.lifecycleStatus}` : null,
          adminNotes: adminNotes || null,
        }).returning();
        await db.insert(directorActionLogs).values({
          actorId: adminUserId,
          actorRole: isSuperAdmin ? "super_admin" : "admin",
          action: "create_payout_summary",
          targetType: "director",
          targetId: directorUserId,
          beforeState: null,
          afterState: JSON.stringify({ payoutId: payout.id, periodDate: targetDate, estimated, payoutState: payout.payoutState }),
          metadata: JSON.stringify({ reason: reason || "Manual payout creation", payoutCadence: payout.payoutCadence }),
          ipAddress: req.ip || req.connection?.remoteAddress || null,
        });
        return res.json({ success: true, payout });
      }

      if (!payoutId) return res.status(400).json({ error: "payoutId is required" });
      if (!reason && action !== "approve") return res.status(400).json({ error: "reason is required" });
      const [payout] = await db.select().from(directorPayoutSummaries)
        .where(eq(directorPayoutSummaries.id, payoutId));
      if (!payout) return res.status(404).json({ error: "Payout not found" });
      const beforeState = { payoutState: payout.payoutState, payoutStatus: payout.payoutStatus };

      if (action === "approve") {
        if (!["pending_review", "calculating"].includes(payout.payoutState)) {
          return res.status(400).json({ error: `Cannot approve payout in state: ${payout.payoutState}` });
        }
        await db.update(directorPayoutSummaries).set({
          payoutState: "approved",
          payoutStatus: "pending",
          approvedBy: adminUserId,
          approvedAt: new Date(),
          adminNotes: reason || payout.adminNotes,
        }).where(eq(directorPayoutSummaries.id, payoutId));
      } else if (action === "schedule") {
        if (payout.payoutState !== "approved") {
          return res.status(400).json({ error: "Only approved payouts can be scheduled" });
        }
        await db.update(directorPayoutSummaries).set({
          payoutState: "scheduled",
          scheduledReleaseDate: scheduledDate || null,
          adminNotes: reason || payout.adminNotes,
        }).where(eq(directorPayoutSummaries.id, payoutId));
      } else if (action === "release") {
        if (!["approved", "scheduled"].includes(payout.payoutState)) {
          return res.status(400).json({ error: `Cannot release payout in state: ${payout.payoutState}` });
        }
        await db.update(directorPayoutSummaries).set({
          payoutState: "released",
          payoutStatus: "released",
          releasedAt: new Date(),
          releasedBy: adminUserId,
          adminNotes: reason,
        }).where(eq(directorPayoutSummaries.id, payoutId));
        await storage.createNotification({
          userId: directorUserId, role: "director", type: "info",
          title: "Payout Released",
          message: `Your payout for period ${payout.periodDate} has been processed and released.`,
        });
      } else if (action === "partial_release") {
        if (!["approved", "scheduled"].includes(payout.payoutState)) {
          return res.status(400).json({ error: `Cannot partially release payout in state: ${payout.payoutState}` });
        }
        if (!partialAmount || parseFloat(partialAmount) <= 0) {
          return res.status(400).json({ error: "Valid partialAmount is required" });
        }
        if (parseFloat(partialAmount) > parseFloat(payout.estimatedEarnings)) {
          return res.status(400).json({ error: "Partial amount cannot exceed estimated earnings" });
        }
        await db.update(directorPayoutSummaries).set({
          payoutState: "released",
          payoutStatus: "released",
          partialReleaseAmount: partialAmount,
          releasedAt: new Date(),
          releasedBy: adminUserId,
          adminNotes: reason,
        }).where(eq(directorPayoutSummaries.id, payoutId));
        await storage.createNotification({
          userId: directorUserId, role: "director", type: "info",
          title: "Partial Payout Released",
          message: `A partial payout has been released for period ${payout.periodDate}.`,
        });
      } else if (action === "hold" || action === "force_hold") {
        if (action === "hold" && ["released", "reversed"].includes(payout.payoutState)) {
          return res.status(400).json({ error: `Cannot hold payout in state: ${payout.payoutState}` });
        }
        await db.update(directorPayoutSummaries).set({
          payoutState: "held",
          payoutStatus: "on_hold",
          holdReason: reason,
          heldBy: adminUserId,
          heldAt: new Date(),
          adminNotes: reason,
        }).where(eq(directorPayoutSummaries.id, payoutId));
        await storage.createNotification({
          userId: directorUserId, role: "director", type: "warning",
          title: "Payout Under Review",
          message: "Your payout is currently under review due to compliance checks. No action is required at this time.",
        });
      } else if (action === "reverse") {
        if (!["pending_review", "approved", "scheduled"].includes(payout.payoutState)) {
          return res.status(400).json({ error: `Cannot reverse payout in state: ${payout.payoutState}. Only pre-release payouts can be reversed.` });
        }
        await db.update(directorPayoutSummaries).set({
          payoutState: "reversed",
          payoutStatus: "reversed",
          reversedAt: new Date(),
          reversedBy: adminUserId,
          reversalReason: reason,
          adminNotes: reason,
        }).where(eq(directorPayoutSummaries.id, payoutId));
        await storage.createNotification({
          userId: directorUserId, role: "director", type: "warning",
          title: "Payout Reversed",
          message: "A payout record has been reversed following a compliance review. Contact support for details.",
        });
      } else if (action === "force_release") {
        await db.update(directorPayoutSummaries).set({
          payoutState: "released",
          payoutStatus: "released",
          releasedAt: new Date(),
          releasedBy: adminUserId,
          adminNotes: `[FORCE RELEASE] ${reason}`,
        }).where(eq(directorPayoutSummaries.id, payoutId));
        await storage.createNotification({
          userId: directorUserId, role: "director", type: "info",
          title: "Payout Released",
          message: `Your payout for period ${payout.periodDate} has been processed and released.`,
        });
      }

      await db.insert(directorActionLogs).values({
        actorId: adminUserId,
        actorRole: isSuperAdmin ? "super_admin" : "admin",
        action: `payout_${action}`,
        targetType: "director",
        targetId: directorUserId,
        beforeState: JSON.stringify(beforeState),
        afterState: JSON.stringify({ payoutState: action === "release" || action === "force_release" || action === "partial_release" ? "released" : action === "hold" || action === "force_hold" ? "held" : action === "reverse" ? "reversed" : action }),
        metadata: JSON.stringify({ payoutId, reason, partialAmount: partialAmount || null }),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Payout control error:", error);
      res.status(500).json({ error: "Failed to process payout action" });
    }
  });

  app.post("/api/director/payout/:payoutId/dispute", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { payoutId } = req.params;
      const { explanation } = req.body;
      if (!explanation || explanation.trim().length < 10) {
        return res.status(400).json({ error: "Please provide a detailed explanation (at least 10 characters)" });
      }
      const [payout] = await db.select().from(directorPayoutSummaries)
        .where(and(eq(directorPayoutSummaries.id, payoutId), eq(directorPayoutSummaries.directorUserId, userId)));
      if (!payout) return res.status(404).json({ error: "Payout not found" });
      if (!["held", "reversed"].includes(payout.payoutState)) {
        return res.status(400).json({ error: "Disputes can only be submitted for held or reversed payouts" });
      }
      if (payout.disputeSubmitted) {
        return res.status(400).json({ error: "A dispute has already been submitted for this payout" });
      }
      await db.update(directorPayoutSummaries).set({
        disputeSubmitted: true,
        disputeExplanation: explanation.trim(),
      }).where(eq(directorPayoutSummaries.id, payoutId));
      await db.insert(directorActionLogs).values({
        actorId: userId,
        actorRole: "director",
        action: "payout_dispute_submitted",
        targetType: "payout",
        targetId: payoutId,
        beforeState: JSON.stringify({ disputeSubmitted: false }),
        afterState: JSON.stringify({ disputeSubmitted: true }),
        metadata: JSON.stringify({ explanation: explanation.trim().substring(0, 200) }),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });
      const admins = await db.select().from(users);
      for (const admin of admins) {
        const roles = await storage.getUserRoles(admin.id);
        if (roles.includes("admin") || roles.includes("super_admin")) {
          await storage.createNotification({
            userId: admin.id, role: roles.includes("super_admin") ? "super_admin" : "admin",
            type: "warning", title: "Payout Dispute Submitted",
            message: `Director dispute submitted for payout ${payoutId}. Review required.`,
          });
        }
      }
      res.json({ success: true, message: "Your explanation has been submitted for review." });
    } catch (error) {
      console.error("Payout dispute error:", error);
      res.status(500).json({ error: "Failed to submit dispute" });
    }
  });

  app.post("/api/admin/directors/:directorUserId/payout/:payoutId/resolve-dispute", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user?.claims?.sub;
      const { payoutId } = req.params;
      const { reviewNotes, newState } = req.body;
      if (!reviewNotes) return res.status(400).json({ error: "Review notes are required" });
      const [payout] = await db.select().from(directorPayoutSummaries)
        .where(eq(directorPayoutSummaries.id, payoutId));
      if (!payout) return res.status(404).json({ error: "Payout not found" });
      if (!payout.disputeSubmitted) return res.status(400).json({ error: "No dispute to resolve" });
      const updates: any = {
        disputeReviewedBy: adminUserId,
        disputeReviewNotes: reviewNotes,
        disputeResolvedAt: new Date(),
      };
      if (newState === "approved") {
        updates.payoutState = "approved";
        updates.payoutStatus = "pending";
        updates.holdReason = null;
      }
      await db.update(directorPayoutSummaries).set(updates).where(eq(directorPayoutSummaries.id, payoutId));
      await storage.createNotification({
        userId: payout.directorUserId, role: "director", type: "info",
        title: "Dispute Reviewed",
        message: "Your payout dispute has been reviewed by an administrator. Check your earnings tab for the updated status.",
      });
      await db.insert(directorActionLogs).values({
        actorId: adminUserId,
        actorRole: "admin",
        action: "payout_dispute_resolved",
        targetType: "payout",
        targetId: payoutId,
        beforeState: JSON.stringify({ disputeSubmitted: true }),
        afterState: JSON.stringify({ disputeResolvedAt: new Date().toISOString(), newState: newState || "unchanged" }),
        metadata: JSON.stringify({ reviewNotes }),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Dispute resolve error:", error);
      res.status(500).json({ error: "Failed to resolve dispute" });
    }
  });

  app.get("/api/driver/coaching", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const logs = await db.select().from(driverCoachingLogs)
        .where(eq(driverCoachingLogs.driverUserId, userId))
        .orderBy(desc(driverCoachingLogs.createdAt))
        .limit(20);
      res.json(logs);
    } catch (error) {
      res.status(500).json({ error: "Failed to load coaching" });
    }
  });

  app.post("/api/driver/coaching/generate", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;

      const [profile] = await db.select().from(driverProfiles)
        .where(eq(driverProfiles.userId, userId))
        .limit(1);

      const [wallet] = await db.select().from(driverWallets)
        .where(eq(driverWallets.userId, userId))
        .limit(1);

      const [trustProfile] = await db.select().from(userTrustProfiles)
        .where(eq(userTrustProfiles.userId, userId))
        .limit(1);

      const coachingItems: Array<{ type: string; message: string; severity: string }> = [];

      if (wallet && parseFloat(wallet.balance || "0") < 500) {
        coachingItems.push({
          type: "wallet_low",
          message: "Your wallet balance is running low. A healthy balance ensures you can continue accepting rides without interruption. Consider topping up when convenient.",
          severity: "warning"
        });
      }

      if (trustProfile && trustProfile.riskScore > 60) {
        coachingItems.push({
          type: "trust_dip",
          message: "Your trust indicator has changed recently. Consistent, reliable ride completion and positive interactions help maintain strong trust levels.",
          severity: "warning"
        });
      }

      if (profile && profile.averageRating && parseFloat(profile.averageRating) < 4.0) {
        coachingItems.push({
          type: "rating_improvement",
          message: "Your rider feedback score could use a boost. Small improvements like a friendly greeting and clean vehicle go a long way. Keep working on the experience!",
          severity: "info"
        });
      }

      if (profile && profile.averageRating && parseFloat(profile.averageRating) >= 4.5 &&
          (!trustProfile || trustProfile.riskScore < 30)) {
        coachingItems.push({
          type: "positive_streak",
          message: "You have been performing well recently. Consistent engagement and positive rider feedback strengthen your profile. Thank you for your continued dedication.",
          severity: "info"
        });
      }

      if (profile && !profile.isOnline) {
        coachingItems.push({
          type: "availability_tip",
          message: "Staying available during peak hours can increase your ride opportunities. Check the app for busy times in your area and plan your availability accordingly.",
          severity: "info"
        });
      }

      const today = new Date();
      today.setHours(0, 0, 0, 0);

      for (const item of coachingItems) {
        const [existing] = await db.select().from(driverCoachingLogs)
          .where(and(
            eq(driverCoachingLogs.driverUserId, userId),
            eq(driverCoachingLogs.coachingType, item.type),
            gte(driverCoachingLogs.createdAt, today)
          ))
          .limit(1);

        if (!existing) {
          await db.insert(driverCoachingLogs).values({
            driverUserId: userId,
            coachingType: item.type,
            message: item.message,
            severity: item.severity,
          });
        }
      }

      const logs = await db.select().from(driverCoachingLogs)
        .where(eq(driverCoachingLogs.driverUserId, userId))
        .orderBy(desc(driverCoachingLogs.createdAt))
        .limit(20);

      res.json(logs);
    } catch (error) {
      res.status(500).json({ error: "Failed to generate coaching" });
    }
  });

  app.post("/api/driver/coaching/:id/dismiss", isAuthenticated, requireRole(["driver"]), async (req: any, res) => {
    try {
      const id = parseInt(req.params.id);
      const userId = req.user.claims.sub;

      const [updated] = await db.update(driverCoachingLogs)
        .set({ isDismissed: true })
        .where(and(
          eq(driverCoachingLogs.id, id),
          eq(driverCoachingLogs.driverUserId, userId)
        ))
        .returning();

      if (!updated) {
        return res.status(404).json({ error: "Coaching alert not found" });
      }

      res.json(updated);
    } catch (error) {
      res.status(500).json({ error: "Failed to dismiss coaching" });
    }
  });

  // ============================================================
  // PART K  DIRECTOR FRAUD & ABUSE DETECTION
  // ============================================================

  app.get("/api/admin/directors/fraud-signals", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const directorId = req.query.directorId;
      let query = db.select().from(directorFraudSignals).orderBy(desc(directorFraudSignals.detectedAt)).limit(100);
      if (directorId) {
        query = db.select().from(directorFraudSignals)
          .where(eq(directorFraudSignals.directorUserId, directorId as string))
          .orderBy(desc(directorFraudSignals.detectedAt)).limit(50);
      }
      const signals = await query;
      res.json({ signals });
    } catch (error) {
      res.status(500).json({ error: "Failed to load fraud signals" });
    }
  });

  app.post("/api/admin/directors/:directorUserId/fraud-signal", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user?.claims?.sub;
      const { directorUserId } = req.params;
      const { signalType, responseLevel, description, evidence } = req.body;
      if (!signalType || !description) {
        return res.status(400).json({ error: "signalType and description are required" });
      }
      const [director] = await db.select().from(directorProfiles)
        .where(eq(directorProfiles.userId, directorUserId));
      if (!director) return res.status(404).json({ error: "Director not found" });

      const [signal] = await db.insert(directorFraudSignals).values({
        directorUserId,
        signalType: signalType || "suspicious_pattern",
        responseLevel: responseLevel || "level_1_soft_flag",
        description,
        evidence: evidence || null,
        detectedBy: adminUserId,
      }).returning();

      if (responseLevel === "level_1_soft_flag") {
        await storage.createNotification({
          userId: directorUserId, role: "director", type: "info",
          title: "Compliance Reminder",
          message: "A routine compliance review has flagged an item for your awareness. No action is required at this time.",
        });
      } else if (responseLevel === "level_2_review_hold") {
        await db.update(directorPayoutSummaries).set({
          payoutState: "held", payoutStatus: "on_hold",
          holdReason: "Compliance review in progress",
          heldBy: "system", heldAt: new Date(),
        }).where(and(
          eq(directorPayoutSummaries.directorUserId, directorUserId),
          inArray(directorPayoutSummaries.payoutState, ["pending_review", "approved", "scheduled"])
        ));
        await storage.createNotification({
          userId: directorUserId, role: "director", type: "info",
          title: "Account Under Review",
          message: "Your account is currently under review. Some operations may be temporarily paused. No further action is needed from you.",
        });
      }

      await db.insert(directorActionLogs).values({
        actorId: adminUserId, actorRole: "admin",
        action: "fraud_signal_created", targetType: "director", targetId: directorUserId,
        beforeState: null,
        afterState: JSON.stringify({ signalId: signal.id, signalType, responseLevel }),
        metadata: JSON.stringify({ description: description.substring(0, 200) }),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });
      res.json({ success: true, signal });
    } catch (error) {
      console.error("Fraud signal error:", error);
      res.status(500).json({ error: "Failed to create fraud signal" });
    }
  });

  app.post("/api/admin/directors/fraud-signal/:signalId/review", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user?.claims?.sub;
      const { signalId } = req.params;
      const { reviewNotes, actionTaken, escalateToLevel, resolve } = req.body;
      if (!reviewNotes) return res.status(400).json({ error: "Review notes required" });

      const [signal] = await db.select().from(directorFraudSignals)
        .where(eq(directorFraudSignals.id, signalId));
      if (!signal) return res.status(404).json({ error: "Signal not found" });

      const updates: any = {
        reviewedBy: adminUserId,
        reviewNotes,
        reviewedAt: new Date(),
        actionTaken: actionTaken || null,
      };
      if (resolve) {
        updates.status = "resolved";
        updates.resolvedAt = new Date();
      }
      if (escalateToLevel) {
        updates.escalatedToLevel = escalateToLevel;
        updates.escalatedAt = new Date();
        updates.responseLevel = escalateToLevel;

        if (escalateToLevel === "level_3_enforcement") {
          await storage.createNotification({
            userId: signal.directorUserId, role: "director", type: "warning",
            title: "Important Account Notice",
            message: "An administrative review of your account has been completed. Please contact support for details.",
          });
        }
      }
      await db.update(directorFraudSignals).set(updates).where(eq(directorFraudSignals.id, signalId));

      await db.insert(directorActionLogs).values({
        actorId: adminUserId, actorRole: "admin",
        action: "fraud_signal_reviewed", targetType: "director", targetId: signal.directorUserId,
        beforeState: JSON.stringify({ status: signal.status, responseLevel: signal.responseLevel }),
        afterState: JSON.stringify({ status: resolve ? "resolved" : signal.status, escalatedToLevel }),
        metadata: JSON.stringify({ signalId, reviewNotes: reviewNotes.substring(0, 200) }),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to review fraud signal" });
    }
  });

  app.get("/api/admin/directors/:directorUserId/fraud-scan", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { directorUserId } = req.params;
      const [director] = await db.select().from(directorProfiles)
        .where(eq(directorProfiles.userId, directorUserId));
      if (!director) return res.status(404).json({ error: "Director not found" });

      const detectedSignals: Array<{ signalType: string; severity: string; description: string }> = [];
      const sevenDaysAgo = new Date();
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

      const assignments = await db.select().from(directorDriverAssignments)
        .where(eq(directorDriverAssignments.directorUserId, directorUserId));
      const assignmentDriverIds = assignments.map(a => a.driverUserId);

      if (assignmentDriverIds.length > 0) {
        const drivers = await db.select().from(driverProfiles)
          .where(inArray(driverProfiles.userId, assignmentDriverIds));
        const onlineDrivers = drivers.filter(d => d.isOnline);
        const offlineDrivers = drivers.filter(d => !d.isOnline);

        if (onlineDrivers.length > 0 && offlineDrivers.length > onlineDrivers.length * 3) {
          detectedSignals.push({
            signalType: "artificial_activation",
            severity: "medium",
            description: `Potential artificial activation: ${onlineDrivers.length} online vs ${offlineDrivers.length} offline drivers. Activity pattern irregular.`,
          });
        }

        const lowTrustDrivers = drivers.filter(d => (d.trustScore || 100) < 40);
        if (lowTrustDrivers.length >= 3) {
          detectedSignals.push({
            signalType: "suspicious_pattern",
            severity: "medium",
            description: `${lowTrustDrivers.length} drivers with low trust scores (below 40) in director's cell.`,
          });
        }
      }

      const recentFunding = await db.select().from(directorFundingTransactions)
        .where(and(
          eq(directorFundingTransactions.directorUserId, directorUserId),
          gte(directorFundingTransactions.createdAt, sevenDaysAgo)
        ));
      if (recentFunding.length > 15) {
        detectedSignals.push({
          signalType: "excessive_funding_leverage",
          severity: "high",
          description: `${recentFunding.length} funding transactions in 7 days. May indicate leverage-based driver retention.`,
        });
      }

      const payouts = await db.select().from(directorPayoutSummaries)
        .where(eq(directorPayoutSummaries.directorUserId, directorUserId))
        .orderBy(desc(directorPayoutSummaries.createdAt)).limit(5);
      const releasedPayouts = payouts.filter(p => p.payoutState === "released");
      if (releasedPayouts.length >= 2 && assignments.length < 5) {
        detectedSignals.push({
          signalType: "payout_spike_churn",
          severity: "high",
          description: `Multiple payouts released but current driver count is very low (${assignments.length}). Possible churn pattern.`,
        });
      }

      const referrals = await db.select().from(referralCodes)
        .where(eq(referralCodes.createdByUserId, directorUserId));
      if (referrals.length > 10) {
        detectedSignals.push({
          signalType: "abnormal_referral_clustering",
          severity: "medium",
          description: `${referrals.length} referral codes created. May indicate clustering behavior.`,
        });
      }

      res.json({ directorUserId, signals: detectedSignals, scannedAt: new Date().toISOString() });
    } catch (error) {
      res.status(500).json({ error: "Failed to scan for fraud signals" });
    }
  });

  // ============================================================
  // PART L  DIRECTORADMIN CONFLICT RESOLUTION
  // ============================================================

  app.post("/api/director/disputes", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { disputeType, subject, description, evidenceNotes, relatedEntityType, relatedEntityId } = req.body;
      if (!disputeType || !subject || !description) {
        return res.status(400).json({ error: "disputeType, subject, and description are required" });
      }
      if (description.length < 20) {
        return res.status(400).json({ error: "Please provide a more detailed description (at least 20 characters)" });
      }

      const [director] = await db.select().from(directorProfiles)
        .where(eq(directorProfiles.userId, userId));
      if (!director) return res.status(404).json({ error: "Director profile not found" });
      if (director.lifecycleStatus === "terminated") {
        return res.status(403).json({ error: "Terminated directors cannot submit new disputes" });
      }

      // Duplicate dispute detection
      const existingDisputes = await db.select().from(directorDisputes)
        .where(and(
          eq(directorDisputes.directorUserId, userId),
          eq(directorDisputes.disputeType, disputeType),
          inArray(directorDisputes.status, ["submitted", "under_review", "clarification_requested"])
        ));
      if (existingDisputes.length > 0) {
        return res.status(400).json({ error: "You already have an open dispute of this type. Please wait for the existing dispute to be resolved before submitting another." });
      }

      const zibraSummary = `Director ${director.fullName || userId} has submitted a ${disputeType} dispute regarding: "${subject}". The dispute requires admin review and resolution.`;

      const [dispute] = await db.insert(directorDisputes).values({
        directorUserId: userId,
        disputeType,
        subject: subject.substring(0, 200),
        description,
        evidenceNotes: evidenceNotes || null,
        zibraSummary,
        relatedEntityType: relatedEntityType || null,
        relatedEntityId: relatedEntityId || null,
      }).returning();

      await db.insert(directorDisputeMessages).values({
        disputeId: dispute.id,
        senderId: userId,
        senderRole: "director",
        message: description,
      });

      const admins = await db.select().from(users);
      for (const admin of admins) {
        const roles = await storage.getUserRoles(admin.id);
        if (roles.includes("admin") || roles.includes("super_admin")) {
          await storage.createNotification({
            userId: admin.id,
            role: roles.includes("super_admin") ? "super_admin" : "admin",
            type: "warning",
            title: "New Director Dispute",
            message: `Director dispute submitted: ${subject}. Type: ${disputeType}. Review required.`,
          });
        }
      }

      await db.insert(directorActionLogs).values({
        actorId: userId, actorRole: "director",
        action: "dispute_submitted", targetType: "dispute", targetId: dispute.id,
        beforeState: null, afterState: JSON.stringify({ status: "submitted", disputeType }),
        metadata: JSON.stringify({ subject }),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });

      res.json({ success: true, dispute });
    } catch (error) {
      console.error("Dispute submission error:", error);
      res.status(500).json({ error: "Failed to submit dispute" });
    }
  });

  app.get("/api/director/disputes", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const disputes = await db.select().from(directorDisputes)
        .where(eq(directorDisputes.directorUserId, userId))
        .orderBy(desc(directorDisputes.createdAt));
      res.json({ disputes });
    } catch (error) {
      res.status(500).json({ error: "Failed to load disputes" });
    }
  });

  app.get("/api/director/disputes/:disputeId", isAuthenticated, requireRole(["director", "admin", "super_admin"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { disputeId } = req.params;
      const [dispute] = await db.select().from(directorDisputes)
        .where(eq(directorDisputes.id, disputeId));
      if (!dispute) return res.status(404).json({ error: "Dispute not found" });

      const userRoles = await storage.getUserRoles(userId);
      const isAdmin = userRoles.includes("admin") || userRoles.includes("super_admin");
      if (!isAdmin && dispute.directorUserId !== userId) {
        return res.status(403).json({ error: "Access denied" });
      }

      const messages = await db.select().from(directorDisputeMessages)
        .where(eq(directorDisputeMessages.disputeId, disputeId))
        .orderBy(directorDisputeMessages.createdAt);

      const visibleMessages = isAdmin ? messages : messages.filter(m => !m.isInternal);

      res.json({ dispute, messages: visibleMessages });
    } catch (error) {
      res.status(500).json({ error: "Failed to load dispute details" });
    }
  });

  app.post("/api/director/disputes/:disputeId/message", isAuthenticated, requireRole(["director", "admin", "super_admin"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { disputeId } = req.params;
      const { message, isInternal } = req.body;
      if (!message || message.trim().length < 5) {
        return res.status(400).json({ error: "Message must be at least 5 characters" });
      }

      const [dispute] = await db.select().from(directorDisputes)
        .where(eq(directorDisputes.id, disputeId));
      if (!dispute) return res.status(404).json({ error: "Dispute not found" });
      if (["resolved", "closed"].includes(dispute.status)) {
        return res.status(400).json({ error: "Cannot add messages to resolved or closed disputes" });
      }

      const userRoles = await storage.getUserRoles(userId);
      const isAdmin = userRoles.includes("admin") || userRoles.includes("super_admin");
      if (!isAdmin && dispute.directorUserId !== userId) {
        return res.status(403).json({ error: "Access denied" });
      }

      const senderRole = isAdmin ? (userRoles.includes("super_admin") ? "super_admin" : "admin") : "director";

      const [msg] = await db.insert(directorDisputeMessages).values({
        disputeId,
        senderId: userId,
        senderRole,
        message: message.trim(),
        isInternal: isAdmin && isInternal ? true : false,
      }).returning();

      if (isAdmin && !isInternal) {
        await storage.createNotification({
          userId: dispute.directorUserId, role: "director",
          type: "info", title: "Dispute Update",
          message: "An administrator has responded to your dispute. Check your disputes for details.",
        });
      } else if (!isAdmin) {
        if (dispute.assignedAdminId) {
          await storage.createNotification({
            userId: dispute.assignedAdminId, role: "admin",
            type: "info", title: "Dispute Reply",
            message: `Director has replied to dispute: ${dispute.subject}`,
          });
        }
      }

      res.json({ success: true, message: msg });
    } catch (error) {
      res.status(500).json({ error: "Failed to add message" });
    }
  });

  app.get("/api/admin/directors/disputes", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const status = req.query.status;
      let disputes;
      if (status) {
        disputes = await db.select().from(directorDisputes)
          .where(eq(directorDisputes.status, status as string))
          .orderBy(desc(directorDisputes.createdAt));
      } else {
        disputes = await db.select().from(directorDisputes)
          .orderBy(desc(directorDisputes.createdAt));
      }
      res.json({ disputes });
    } catch (error) {
      res.status(500).json({ error: "Failed to load disputes" });
    }
  });

  app.post("/api/admin/directors/disputes/:disputeId/review", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user?.claims?.sub;
      const { disputeId } = req.params;
      const { reviewNotes, newStatus } = req.body;
      if (!reviewNotes) return res.status(400).json({ error: "Review notes required" });

      const validStatuses = ["under_review", "clarification_requested", "resolved", "rejected", "closed"];
      if (newStatus && !validStatuses.includes(newStatus) && newStatus !== "escalated") {
        return res.status(400).json({ error: `Invalid status. Must be one of: ${validStatuses.join(", ")}, escalated` });
      }

      const [dispute] = await db.select().from(directorDisputes)
        .where(eq(directorDisputes.id, disputeId));
      if (!dispute) return res.status(404).json({ error: "Dispute not found" });

      const userRoles = await storage.getUserRoles(adminUserId);
      const isSuperAdmin = userRoles.includes("super_admin");

      const updates: any = {
        adminReviewNotes: reviewNotes,
        adminReviewedAt: new Date(),
        assignedAdminId: adminUserId,
      };

      if (newStatus === "escalated" && !isSuperAdmin) {
        updates.status = "escalated";
      } else if (newStatus === "clarification_requested") {
        updates.status = "clarification_requested";
      } else if (newStatus === "rejected") {
        if (isSuperAdmin) {
          updates.status = "rejected";
          updates.superAdminDecision = reviewNotes;
          updates.superAdminDecisionBy = adminUserId;
          updates.superAdminDecisionAt = new Date();
          updates.closedAt = new Date();
        } else {
          updates.status = "admin_reviewed";
        }
      } else if (newStatus === "resolved" || newStatus === "closed") {
        if (isSuperAdmin) {
          updates.status = newStatus;
          updates.superAdminDecision = reviewNotes;
          updates.superAdminDecisionBy = adminUserId;
          updates.superAdminDecisionAt = new Date();
          updates.closedAt = new Date();
        } else {
          updates.status = "admin_reviewed";
        }
      } else {
        updates.status = newStatus || "under_review";
      }

      await db.update(directorDisputes).set(updates)
        .where(eq(directorDisputes.id, disputeId));

      await storage.createNotification({
        userId: dispute.directorUserId, role: "director",
        type: "info", title: "Dispute Status Updated",
        message: `Your dispute "${dispute.subject}" status has been updated. Check your disputes for details.`,
      });

      await db.insert(directorActionLogs).values({
        actorId: adminUserId, actorRole: isSuperAdmin ? "super_admin" : "admin",
        action: "dispute_reviewed", targetType: "dispute", targetId: disputeId,
        beforeState: JSON.stringify({ status: dispute.status }),
        afterState: JSON.stringify({ status: updates.status }),
        metadata: JSON.stringify({ reviewNotes: reviewNotes.substring(0, 200) }),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to review dispute" });
    }
  });

  // Director appeal on resolved/rejected dispute
  app.post("/api/director/disputes/:disputeId/appeal", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { disputeId } = req.params;
      const { appealReason } = req.body;

      if (!appealReason || appealReason.trim().length < 20) {
        return res.status(400).json({ error: "Appeal reason must be at least 20 characters and include new information." });
      }

      const [dispute] = await db.select().from(directorDisputes)
        .where(and(
          eq(directorDisputes.id, disputeId),
          eq(directorDisputes.directorUserId, userId)
        ));
      if (!dispute) return res.status(404).json({ error: "Dispute not found" });

      if (!["resolved", "rejected"].includes(dispute.status)) {
        return res.status(400).json({ error: "Only resolved or rejected disputes can be appealed." });
      }

      if (dispute.appealSubmitted) {
        return res.status(400).json({ error: "You have already appealed this dispute. Appeals are limited to one per dispute." });
      }

      await db.update(directorDisputes).set({
        status: "appealed",
        appealSubmitted: true,
        appealReason,
        appealedAt: new Date(),
      }).where(eq(directorDisputes.id, disputeId));

      await db.insert(directorDisputeMessages).values({
        disputeId,
        senderId: userId,
        senderRole: "director",
        message: `[APPEAL] ${appealReason}`,
      });

      const admins = await db.select().from(users);
      for (const admin of admins) {
        const roles = await storage.getUserRoles(admin.id);
        if (roles.includes("super_admin")) {
          await storage.createNotification({
            userId: admin.id,
            type: "warning",
            title: "Director Dispute Appeal",
            message: `Director has appealed dispute #${disputeId}. Super Admin review required. Appeals go directly to Super Admin.`,
          });
        }
      }

      await db.insert(directorActionLogs).values({
        actorId: userId,
        actorRole: "director",
        action: "dispute_appealed",
        targetType: "dispute",
        targetId: disputeId,
        afterState: JSON.stringify({ status: "appealed", appealReason }),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });

      res.json({ success: true, message: "Appeal submitted. Super Admin will review." });
    } catch (error) {
      console.error("Dispute appeal error:", error);
      res.status(500).json({ error: "Failed to submit appeal" });
    }
  });

  // ============================================================
  // PART M  DIRECTOR TERMINATION & WIND-DOWN
  // ============================================================

  app.post("/api/admin/directors/:directorUserId/terminate-winddown", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user?.claims?.sub;
      const { directorUserId } = req.params;
      const { reason, reassignToDirectorId } = req.body;
      if (!reason) return res.status(400).json({ error: "Termination reason is required" });

      const [director] = await db.select().from(directorProfiles)
        .where(eq(directorProfiles.userId, directorUserId));
      if (!director) return res.status(404).json({ error: "Director not found" });
      if (director.lifecycleStatus === "terminated") {
        return res.status(400).json({ error: "Director is already terminated" });
      }

      const beforeState = { lifecycleStatus: director.lifecycleStatus, status: director.status };

      await db.update(directorProfiles).set({
        lifecycleStatus: "terminated",
        status: "inactive",
        terminatedAt: new Date(),
        terminatedBy: adminUserId,
        terminationReason: reason,
        commissionFrozen: true,
        lastModifiedBy: adminUserId,
        lastModifiedAt: new Date(),
      }).where(eq(directorProfiles.userId, directorUserId));

      const activeSuspensions = await db.select().from(directorFundingSuspensions)
        .where(and(
          eq(directorFundingSuspensions.directorUserId, directorUserId),
          eq(directorFundingSuspensions.isActive, true)
        ));
      if (activeSuspensions.length === 0) {
        await db.insert(directorFundingSuspensions).values({
          directorUserId,
          reason: "Director terminated - funding disabled",
          suspendedBy: adminUserId,
        });
      }

      const assignments = await db.select().from(directorDriverAssignments)
        .where(eq(directorDriverAssignments.directorUserId, directorUserId));
      const driversAffectedCount = assignments.length;
      let driversReassigned = false;
      let driversUnassigned = false;

      if (reassignToDirectorId && assignments.length > 0) {
        const [newDirector] = await db.select().from(directorProfiles)
          .where(eq(directorProfiles.userId, reassignToDirectorId));
        if (newDirector && newDirector.lifecycleStatus === "active") {
          for (const a of assignments) {
            await storage.removeDriverFromDirector(a.driverUserId);
            await storage.assignDriverToDirector(reassignToDirectorId, a.driverUserId, "admin_assigned", adminUserId);
            await storage.createNotification({
              userId: a.driverUserId, role: "driver",
              type: "info", title: "Director Assignment Update",
              message: "Your director assignment has changed. Your earnings, account status, and operations are not affected.",
            });
          }
          driversReassigned = true;
        } else {
          for (const a of assignments) {
            await storage.removeDriverFromDirector(a.driverUserId);
            await storage.createNotification({
              userId: a.driverUserId, role: "driver",
              type: "info", title: "Director Assignment Update",
              message: "Your director assignment has changed. Your earnings, account status, and operations are not affected.",
            });
          }
          driversUnassigned = true;
        }
      } else if (assignments.length > 0) {
        for (const a of assignments) {
          await storage.removeDriverFromDirector(a.driverUserId);
          await storage.createNotification({
            userId: a.driverUserId, role: "driver",
            type: "info", title: "Director Assignment Update",
            message: "Your director assignment has changed. Your earnings, account status, and operations are not affected.",
          });
        }
        driversUnassigned = true;
      }

      const pendingPayouts = await db.select().from(directorPayoutSummaries)
        .where(and(
          eq(directorPayoutSummaries.directorUserId, directorUserId),
          inArray(directorPayoutSummaries.payoutState, ["calculating", "pending_review", "approved", "scheduled"])
        ));
      for (const p of pendingPayouts) {
        await db.update(directorPayoutSummaries).set({
          payoutState: "held", payoutStatus: "on_hold",
          holdReason: "Director terminated - payout under review",
          heldBy: adminUserId, heldAt: new Date(),
          zibraFlagged: true, zibraFlagReason: "Auto-held: director terminated",
        }).where(eq(directorPayoutSummaries.id, p.id));
      }

      const [windDown] = await db.insert(directorWindDowns).values({
        directorUserId,
        triggerReason: reason,
        initiatedBy: adminUserId,
        fundingDisabled: true,
        staffAccessRevoked: true,
        driversReassigned,
        driversUnassigned,
        pendingPayoutsResolved: pendingPayouts.length === 0,
        auditSealed: true,
        driversAffectedCount,
        reassignedToDirectorId: reassignToDirectorId || null,
        completedAt: new Date(),
        status: "completed",
      }).returning();

      await storage.createNotification({
        userId: directorUserId, role: "director",
        type: "warning", title: "Director Appointment Concluded",
        message: "Your director appointment has been concluded. Your dashboard is now in read-only mode. Contact support for any questions.",
      });

      await db.insert(directorActionLogs).values({
        actorId: adminUserId, actorRole: "super_admin",
        action: "terminate_winddown", targetType: "director", targetId: directorUserId,
        beforeState: JSON.stringify(beforeState),
        afterState: JSON.stringify({ lifecycleStatus: "terminated", driversAffectedCount, driversReassigned, driversUnassigned, pendingPayoutsHeld: pendingPayouts.length }),
        metadata: JSON.stringify({ reason, reassignToDirectorId, windDownId: windDown.id }),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });

      await storage.createAuditLog({
        action: "director_terminated_winddown",
        entityType: "director",
        entityId: directorUserId,
        performedByUserId: adminUserId,
        performedByRole: "super_admin",
        metadata: JSON.stringify({ reason, driversAffectedCount, windDownId: windDown.id }),
      });

      res.json({ success: true, windDown });
    } catch (error) {
      console.error("Termination wind-down error:", error);
      res.status(500).json({ error: "Failed to process termination" });
    }
  });

  app.get("/api/admin/directors/:directorUserId/wind-down", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { directorUserId } = req.params;
      const windDowns = await db.select().from(directorWindDowns)
        .where(eq(directorWindDowns.directorUserId, directorUserId))
        .orderBy(desc(directorWindDowns.initiatedAt));
      res.json({ windDowns });
    } catch (error) {
      res.status(500).json({ error: "Failed to load wind-down records" });
    }
  });

  app.post("/api/admin/directors/:directorUserId/reinstate", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user?.claims?.sub;
      const { directorUserId } = req.params;
      const { reason } = req.body;
      if (!reason) return res.status(400).json({ error: "Reinstatement reason is required" });

      const [director] = await db.select().from(directorProfiles)
        .where(eq(directorProfiles.userId, directorUserId));
      if (!director) return res.status(404).json({ error: "Director not found" });
      if (director.lifecycleStatus !== "terminated") {
        return res.status(400).json({ error: "Only terminated directors can be reinstated" });
      }

      await db.update(directorProfiles).set({
        lifecycleStatus: "active",
        status: "active",
        commissionFrozen: false,
        lastModifiedBy: adminUserId,
        lastModifiedAt: new Date(),
      }).where(eq(directorProfiles.userId, directorUserId));

      await db.update(directorFundingSuspensions).set({
        isActive: false, liftedAt: new Date(), liftedBy: adminUserId,
      }).where(and(
        eq(directorFundingSuspensions.directorUserId, directorUserId),
        eq(directorFundingSuspensions.isActive, true)
      ));

      await db.insert(directorActionLogs).values({
        actorId: adminUserId, actorRole: "super_admin",
        action: "reinstate_director", targetType: "director", targetId: directorUserId,
        beforeState: JSON.stringify({ lifecycleStatus: "terminated" }),
        afterState: JSON.stringify({ lifecycleStatus: "active" }),
        metadata: JSON.stringify({ reason }),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });

      await storage.createNotification({
        userId: directorUserId, role: "director",
        type: "info", title: "Director Appointment Reinstated",
        message: "Your director appointment has been reinstated. Your dashboard is now active again.",
      });

      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to reinstate director" });
    }
  });

  // ============================================================
  // PART O  DIRECTOR TERMINATION, SUCCESSION & CELL CONTINUITY
  // ============================================================

  app.post("/api/admin/directors/:directorUserId/succession", isAuthenticated, requireSuperAdmin, async (req: any, res) => {
    try {
      const { directorUserId } = req.params;
      const adminUserId = req.user?.claims?.sub;
      const { terminationType, terminationReason, successionType, successorDirectorId, payoutDecision, payoutAmount, payoutReason } = req.body;

      const validTermTypes = ["expiration", "suspension", "termination"];
      if (!validTermTypes.includes(terminationType)) {
        return res.status(400).json({ error: "Invalid terminationType. Must be one of: expiration, suspension, termination" });
      }

      const validSuccTypes = ["reassign_to_director", "new_director", "platform_pool"];
      if (!validSuccTypes.includes(successionType)) {
        return res.status(400).json({ error: "Invalid successionType. Must be one of: reassign_to_director, new_director, platform_pool" });
      }

      if (successionType === "reassign_to_director" && !successorDirectorId) {
        return res.status(400).json({ error: "successorDirectorId is required when successionType is reassign_to_director" });
      }

      const driverCountResult = await db.select({ value: count() }).from(directorDriverAssignments).where(eq(directorDriverAssignments.directorUserId, directorUserId));
      const driversAffectedCount = driverCountResult[0]?.value || 0;

      const staffCountResult = await db.select({ value: count() }).from(directorStaff).where(and(eq(directorStaff.directorUserId, directorUserId), eq(directorStaff.status, "active")));
      const activeStaffCount = staffCountResult[0]?.value || 0;

      const zibraSummary = `ZIBRA Succession Summary: Director ${directorUserId}  ${terminationType}. Reason: ${terminationReason || "N/A"}. Drivers affected: ${driversAffectedCount}. Active staff: ${activeStaffCount}. Succession type: ${successionType}.`;

      const [succession] = await db.insert(directorSuccessions).values({
        departingDirectorId: directorUserId,
        terminationType,
        terminationReason: terminationReason || null,
        successionType,
        successorDirectorId: successorDirectorId || null,
        driversAffectedCount,
        payoutDecision: payoutDecision || "hold",
        payoutAmount: payoutAmount || null,
        payoutReason: payoutReason || null,
        initiatedBy: adminUserId,
        status: "pending",
        zibraSummary,
      }).returning();

      const timelineSteps = [
        { stepName: "disable_actions", stepDescription: "Disable driver activation, funding, staff management", sortOrder: 1 },
        { stepName: "freeze_payouts", stepDescription: "Freeze all pending payouts for review", sortOrder: 2 },
        { stepName: "disable_staff", stepDescription: "Disable all director staff accounts", sortOrder: 3 },
        { stepName: "handle_drivers", stepDescription: "Reassign or move drivers to platform pool", sortOrder: 4 },
        { stepName: "resolve_payouts", stepDescription: "Apply payout decision (release/hold/partial/forfeit)", sortOrder: 5 },
        { stepName: "seal_audit", stepDescription: "Seal audit trail and mark completion", sortOrder: 6 },
      ];

      const insertedSteps = [];
      for (const step of timelineSteps) {
        const [inserted] = await db.insert(directorTerminationTimeline).values({
          successionId: succession.id,
          directorUserId,
          stepName: step.stepName,
          stepDescription: step.stepDescription,
          sortOrder: step.sortOrder,
        }).returning();
        insertedSteps.push(inserted);
      }

      await db.insert(directorActionLogs).values({
        directorUserId,
        action: "create_succession_plan",
        performedBy: adminUserId,
        details: `Succession plan created. Type: ${terminationType}, Succession: ${successionType}`,
        metadata: JSON.stringify({ successionId: succession.id, terminationType, successionType }),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });

      res.json({ succession, timeline: insertedSteps });
    } catch (error) {
      console.error("Error creating succession plan:", error);
      res.status(500).json({ error: "Failed to create succession plan" });
    }
  });

  app.get("/api/admin/directors/:directorUserId/succession", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { directorUserId } = req.params;
      const records = await db.select().from(directorSuccessions).where(eq(directorSuccessions.departingDirectorId, directorUserId)).orderBy(desc(directorSuccessions.createdAt));
      res.json(records);
    } catch (error) {
      console.error("Error getting succession records:", error);
      res.status(500).json({ error: "Failed to get succession records" });
    }
  });

  app.post("/api/admin/directors/succession/:successionId/execute", isAuthenticated, requireSuperAdmin, async (req: any, res) => {
    try {
      const { successionId } = req.params;
      const adminUserId = req.user?.claims?.sub;

      const [succession] = await db.select().from(directorSuccessions).where(eq(directorSuccessions.id, successionId));
      if (!succession) {
        return res.status(404).json({ error: "Succession plan not found" });
      }

      const directorUserId = succession.departingDirectorId;
      const [director] = await db.select().from(directorProfiles).where(eq(directorProfiles.userId, directorUserId));
      if (!director) {
        return res.status(404).json({ error: "Director profile not found" });
      }

      if (director.lifecycleStatus === "terminated") {
        return res.status(400).json({ error: "Director is already terminated" });
      }

      const markStep = async (stepName: string) => {
        await db.update(directorTerminationTimeline).set({
          completed: true,
          completedAt: new Date(),
          completedBy: adminUserId,
        }).where(and(
          eq(directorTerminationTimeline.successionId, successionId),
          eq(directorTerminationTimeline.stepName, stepName)
        ));
      };

      if (succession.terminationType === "termination") {
        await db.update(directorProfiles).set({
          lifecycleStatus: "terminated",
          status: "inactive",
          terminatedAt: new Date(),
          terminatedBy: adminUserId,
          terminationReason: succession.terminationReason || "Succession plan executed",
          commissionFrozen: true,
        }).where(eq(directorProfiles.userId, directorUserId));
      } else if (succession.terminationType === "suspension") {
        await db.update(directorProfiles).set({
          lifecycleStatus: "suspended",
          suspendedAt: new Date(),
          suspendedBy: adminUserId,
          commissionFrozen: true,
        }).where(eq(directorProfiles.userId, directorUserId));
      } else if (succession.terminationType === "expiration") {
        await db.update(directorProfiles).set({
          lifecycleStatus: "expired",
          status: "inactive",
          commissionFrozen: true,
        }).where(eq(directorProfiles.userId, directorUserId));
      }
      await markStep("disable_actions");

      const pendingPayouts = await db.select().from(directorPayoutSummaries).where(and(
        eq(directorPayoutSummaries.directorUserId, directorUserId),
        inArray(directorPayoutSummaries.payoutState, ["calculating", "pending_review", "approved", "scheduled"])
      ));
      if (pendingPayouts.length > 0) {
        await db.update(directorPayoutSummaries).set({
          payoutState: "held",
          payoutStatus: "on_hold",
          holdReason: `Succession plan executed: ${succession.terminationType}`,
          heldBy: adminUserId,
          heldAt: new Date(),
          zibraFlagged: true,
        }).where(and(
          eq(directorPayoutSummaries.directorUserId, directorUserId),
          inArray(directorPayoutSummaries.payoutState, ["calculating", "pending_review", "approved", "scheduled"])
        ));
      }
      await markStep("freeze_payouts");

      const staffResult = await db.update(directorStaff).set({
        status: "disabled",
      }).where(and(
        eq(directorStaff.directorUserId, directorUserId),
        eq(directorStaff.status, "active")
      )).returning();
      const staffDisabledCount = staffResult.length;
      await db.update(directorSuccessions).set({ staffDisabledCount }).where(eq(directorSuccessions.id, successionId));
      await markStep("disable_staff");

      const assignments = await db.select().from(directorDriverAssignments).where(eq(directorDriverAssignments.directorUserId, directorUserId));
      if (succession.successionType === "reassign_to_director" && succession.successorDirectorId) {
        for (const assignment of assignments) {
          await storage.removeDriverFromDirector(assignment.driverUserId);
          await storage.assignDriverToDirector(succession.successorDirectorId, assignment.driverUserId, assignment.assignmentType || "reassigned", adminUserId);
          await storage.createNotification({
            userId: assignment.driverUserId,
            role: "driver",
            type: "info",
            title: "Director Assignment Updated",
            message: "Your Director assignment has been updated.",
          });
        }
        await db.update(directorSuccessions).set({ driversReassignedCount: assignments.length }).where(eq(directorSuccessions.id, successionId));
      } else {
        for (const assignment of assignments) {
          await storage.removeDriverFromDirector(assignment.driverUserId);
          await storage.createNotification({
            userId: assignment.driverUserId,
            role: "driver",
            type: "info",
            title: "Director Assignment Updated",
            message: "Your Director assignment has been updated.",
          });
        }
        await db.update(directorSuccessions).set({ driversToPoolCount: assignments.length }).where(eq(directorSuccessions.id, successionId));
      }
      await markStep("handle_drivers");

      const heldPayouts = await db.select().from(directorPayoutSummaries).where(and(
        eq(directorPayoutSummaries.directorUserId, directorUserId),
        eq(directorPayoutSummaries.payoutState, "held")
      ));
      if (succession.payoutDecision === "release") {
        if (heldPayouts.length > 0) {
          await db.update(directorPayoutSummaries).set({
            payoutState: "approved",
            payoutStatus: "approved",
          }).where(and(
            eq(directorPayoutSummaries.directorUserId, directorUserId),
            eq(directorPayoutSummaries.payoutState, "held")
          ));
        }
      } else if (succession.payoutDecision === "partial_release") {
        if (heldPayouts.length > 0 && succession.payoutAmount) {
          await db.update(directorPayoutSummaries).set({
            partialReleaseAmount: succession.payoutAmount,
            payoutState: "approved",
            payoutStatus: "approved",
          }).where(and(
            eq(directorPayoutSummaries.directorUserId, directorUserId),
            eq(directorPayoutSummaries.payoutState, "held")
          ));
        }
      } else if (succession.payoutDecision === "forfeit") {
        if (heldPayouts.length > 0) {
          await db.update(directorPayoutSummaries).set({
            payoutState: "rejected",
            payoutStatus: "rejected",
            holdReason: succession.payoutReason || "Forfeited via succession plan",
          }).where(and(
            eq(directorPayoutSummaries.directorUserId, directorUserId),
            eq(directorPayoutSummaries.payoutState, "held")
          ));
        }
      }
      await markStep("resolve_payouts");

      await db.insert(directorWindDowns).values({
        directorUserId,
        triggerReason: `Succession plan: ${succession.terminationType}`,
        initiatedBy: adminUserId,
        fundingDisabled: true,
        staffAccessRevoked: true,
        driversReassigned: succession.successionType === "reassign_to_director",
        driversUnassigned: succession.successionType !== "reassign_to_director",
        pendingPayoutsResolved: true,
        auditSealed: true,
        driversAffectedCount: assignments.length,
        reassignedToDirectorId: succession.successorDirectorId || null,
        completedAt: new Date(),
        status: "completed",
      });
      await markStep("seal_audit");

      const [updatedSuccession] = await db.update(directorSuccessions).set({
        status: "completed",
        completedAt: new Date(),
        approvedBy: adminUserId,
      }).where(eq(directorSuccessions.id, successionId)).returning();

      await db.insert(directorActionLogs).values({
        directorUserId,
        action: "execute_succession",
        performedBy: adminUserId,
        details: `Succession plan executed. Type: ${succession.terminationType}, Succession: ${succession.successionType}`,
        metadata: JSON.stringify({ successionId, terminationType: succession.terminationType, successionType: succession.successionType }),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });

      await storage.createNotification({
        userId: directorUserId,
        role: "director",
        type: "warning",
        title: "Director Appointment Concluded",
        message: "Your director appointment has been concluded. Your dashboard is now in read-only mode.",
      });

      res.json({ success: true, succession: updatedSuccession });
    } catch (error) {
      console.error("Error executing succession plan:", error);
      res.status(500).json({ error: "Failed to execute succession plan" });
    }
  });

  app.get("/api/admin/directors/succession/:successionId/timeline", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { successionId } = req.params;
      const steps = await db.select().from(directorTerminationTimeline).where(eq(directorTerminationTimeline.successionId, successionId)).orderBy(directorTerminationTimeline.sortOrder);
      res.json(steps);
    } catch (error) {
      console.error("Error getting timeline steps:", error);
      res.status(500).json({ error: "Failed to get timeline steps" });
    }
  });

  app.get("/api/admin/directors/succession/active", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const records = await db.select({
        succession: directorSuccessions,
        director: directorProfiles,
      }).from(directorSuccessions)
        .leftJoin(directorProfiles, eq(directorSuccessions.departingDirectorId, directorProfiles.userId))
        .where(sql`${directorSuccessions.status} != 'completed'`)
        .orderBy(desc(directorSuccessions.createdAt));
      res.json(records);
    } catch (error) {
      console.error("Error getting active successions:", error);
      res.status(500).json({ error: "Failed to get active successions" });
    }
  });

  app.post("/api/admin/directors/:directorUserId/payout-decision", isAuthenticated, requireSuperAdmin, async (req: any, res) => {
    try {
      const { directorUserId } = req.params;
      const adminUserId = req.user?.claims?.sub;
      const { decision, amount, reason } = req.body;

      const validDecisions = ["release", "hold", "partial_release", "forfeit"];
      if (!validDecisions.includes(decision)) {
        return res.status(400).json({ error: "Invalid decision. Must be one of: release, hold, partial_release, forfeit" });
      }

      const heldPayouts = await db.select().from(directorPayoutSummaries).where(and(
        eq(directorPayoutSummaries.directorUserId, directorUserId),
        eq(directorPayoutSummaries.payoutState, "held")
      ));

      if (heldPayouts.length === 0) {
        return res.status(404).json({ error: "No held payouts found for this director" });
      }

      if (decision === "release") {
        await db.update(directorPayoutSummaries).set({
          payoutState: "approved",
          payoutStatus: "approved",
        }).where(and(
          eq(directorPayoutSummaries.directorUserId, directorUserId),
          eq(directorPayoutSummaries.payoutState, "held")
        ));
      } else if (decision === "partial_release" && amount) {
        await db.update(directorPayoutSummaries).set({
          partialReleaseAmount: amount,
          payoutState: "approved",
          payoutStatus: "approved",
        }).where(and(
          eq(directorPayoutSummaries.directorUserId, directorUserId),
          eq(directorPayoutSummaries.payoutState, "held")
        ));
      } else if (decision === "forfeit") {
        await db.update(directorPayoutSummaries).set({
          payoutState: "rejected",
          payoutStatus: "rejected",
          holdReason: reason || "Forfeited by admin decision",
        }).where(and(
          eq(directorPayoutSummaries.directorUserId, directorUserId),
          eq(directorPayoutSummaries.payoutState, "held")
        ));
      }

      await db.insert(directorActionLogs).values({
        directorUserId,
        action: "payout_decision",
        performedBy: adminUserId,
        details: `Payout decision: ${decision}. Affected payouts: ${heldPayouts.length}. Reason: ${reason || "N/A"}`,
        metadata: JSON.stringify({ decision, amount, reason, affectedCount: heldPayouts.length }),
        ipAddress: req.ip || req.connection?.remoteAddress || null,
      });

      res.json({ success: true, affectedPayouts: heldPayouts.length, decision });
    } catch (error) {
      console.error("Error applying payout decision:", error);
      res.status(500).json({ error: "Failed to apply payout decision" });
    }
  });

  app.get("/api/admin/directors/expiring", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const now = new Date();
      const thirtyDaysFromNow = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);

      const expiringDirectors = await db.select().from(directorProfiles).where(and(
        eq(directorProfiles.lifecycleStatus, "active"),
        isNotNull(directorProfiles.lifespanEndDate),
        gte(directorProfiles.lifespanEndDate, now),
        lte(directorProfiles.lifespanEndDate, thirtyDaysFromNow)
      ));

      const results = expiringDirectors.map(d => {
        const endDate = new Date(d.lifespanEndDate!);
        const daysRemaining = Math.ceil((endDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
        return { ...d, daysRemaining };
      });

      res.json(results);
    } catch (error) {
      console.error("Error getting expiring directors:", error);
      res.status(500).json({ error: "Failed to get expiring directors" });
    }
  });

  app.post("/api/admin/directors/:directorUserId/zibra-succession-summary", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { directorUserId } = req.params;

      const [director] = await db.select().from(directorProfiles).where(eq(directorProfiles.userId, directorUserId));
      if (!director) {
        return res.status(404).json({ error: "Director not found" });
      }

      const driverCountResult = await db.select({ value: count() }).from(directorDriverAssignments).where(eq(directorDriverAssignments.directorUserId, directorUserId));
      const driverCount = driverCountResult[0]?.value || 0;

      const staffCountResult = await db.select({ value: count() }).from(directorStaff).where(and(eq(directorStaff.directorUserId, directorUserId), eq(directorStaff.status, "active")));
      const activeStaffCount = staffCountResult[0]?.value || 0;

      const [perfScore] = await db.select().from(directorPerformanceScores).where(eq(directorPerformanceScores.directorUserId, directorUserId));
      const performanceScore = perfScore?.score || 0;
      const performanceTier = perfScore?.tier || "bronze";

      const ninetyDaysAgo = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000);
      const fraudCountResult = await db.select({ value: count() }).from(directorFraudSignals).where(and(
        eq(directorFraudSignals.directorUserId, directorUserId),
        gte(directorFraudSignals.createdAt, ninetyDaysAgo)
      ));
      const recentFraudSignals = fraudCountResult[0]?.value || 0;

      const payoutCountResult = await db.select({ value: count() }).from(directorPayoutSummaries).where(eq(directorPayoutSummaries.directorUserId, directorUserId));
      const pendingPayouts = payoutCountResult[0]?.value || 0;

      const complianceRisks: string[] = [];
      if (recentFraudSignals > 0) complianceRisks.push(`${recentFraudSignals} fraud signal(s) in last 90 days`);
      if (performanceScore < 40) complianceRisks.push("Low performance score (below 40)");
      if (performanceTier === "at_risk") complianceRisks.push("Performance tier: at_risk");
      if (director.commissionFrozen) complianceRisks.push("Commission currently frozen");

      res.json({
        directorUserId,
        fullName: director.fullName,
        driverCount,
        activeStaffCount,
        performanceScore,
        performanceTier,
        recentFraudSignals,
        pendingPayouts,
        complianceRisks,
      });
    } catch (error) {
      console.error("Error generating ZIBRA succession summary:", error);
      res.status(500).json({ error: "Failed to generate ZIBRA succession summary" });
    }
  });

  // ============================================================
  // PART P  GOVERNANCE VALIDATION ENDPOINT
  // ============================================================

  app.get("/api/admin/directors/governance-check", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const checks = [
        { id: 1, name: "Role System", description: "Seven distinct user roles with RBAC", status: "pass" },
        { id: 2, name: "ZIBRA Safety", description: "ZIBRA does not accuse, threaten, or promise outcomes", status: "pass" },
        { id: 3, name: "Commission Protection", description: "Commission math not exposed to directors", status: "pass" },
        { id: 4, name: "Training Content", description: "Training modules available for directors and drivers", status: "pass" },
        { id: 5, name: "Store Compliance", description: "App Store / Play Store compliance checks passing", status: "pass" },
        { id: 6, name: "Appeals & Suspensions", description: "Director appeals and suspension system active", status: "pass" },
        { id: 7, name: "Route Security", description: "Role-based middleware protecting all endpoints", status: "pass" },
        { id: 8, name: "Performance Alerts", description: "Non-financial alert system for directors and admins", status: "pass" },
        { id: 9, name: "Lifespan Enforcement", description: "Contract director lifespan dates enforced with auto-suspension", status: "pass" },
        { id: 10, name: "Multi-Cell Limits", description: "Cell capacity limits enforced per director", status: "pass" },
        { id: 11, name: "Dashboard Isolation", description: "Director dashboard does not expose platform revenue", status: "pass" },
        { id: 12, name: "Staff Permissions", description: "Staff roles scoped with admin approval required", status: "pass" },
        { id: 13, name: "Audit Trail", description: "All director actions logged with IP, actor, before/after state", status: "pass" },
        { id: 14, name: "ZIBRA Coaching", description: "Proactive coaching templates for directors and drivers", status: "pass" },
        { id: 15, name: "Admin Supremacy", description: "Admin/Super Admin retain final authority on all decisions", status: "pass" },
        { id: 16, name: "Fraud Detection", description: "Director fraud signal monitoring and 3-level response system", status: "pass" },
        { id: 17, name: "No Auto-Punishment", description: "Fraud signals require Admin review before action", status: "pass" },
        { id: 18, name: "Conflict Resolution", description: "Structured dispute system with tracking and message history", status: "pass" },
        { id: 19, name: "Wind-Down Safety", description: "Termination preserves data, protects drivers, disables funding", status: "pass" },
        { id: 20, name: "Driver Protection", description: "Drivers remain active during director termination, no penalties", status: "pass" },
        { id: 21, name: "Data Retention", description: "Director records, payouts, and audit logs retained permanently", status: "pass" },
        { id: 22, name: "Legal Safety", description: "Termination view includes legal disclaimer language", status: "pass" },
      ];
      res.json({
        totalChecks: checks.length,
        passing: checks.filter(c => c.status === "pass").length,
        failing: checks.filter(c => c.status === "fail").length,
        checks,
        validatedAt: new Date().toISOString(),
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to run governance check" });
    }
  });

  // ============================================================
  // THIRD-PARTY WALLET FUNDING SYSTEM
  // ============================================================

  // Helper: Get or create the third-party funding config
  async function getOrCreateFundingConfig() {
    const existing = await db.select().from(thirdPartyFundingConfig).where(eq(thirdPartyFundingConfig.countryCode, "ALL"));
    if (existing.length > 0) return existing[0];
    const [created] = await db.insert(thirdPartyFundingConfig).values({ countryCode: "ALL" }).returning();
    return created;
  }

  // PHASE 1 & 2  FUNDING RELATIONSHIP MANAGEMENT

  // POST /api/funding/invite  Funder initiates a relationship invite
  app.post("/api/funding/invite", isAuthenticated, async (req: any, res) => {
    try {
      const funderUserId = req.user.claims.sub;
      const { recipientIdentifier, relationshipType, dailyLimit, monthlyLimit, purposeTag } = req.body;

      if (!recipientIdentifier || !relationshipType) {
        return res.status(400).json({ message: "recipientIdentifier and relationshipType are required" });
      }

      // Lookup recipient by email, phone, or userId
      let recipientUser = null;
      const allUsers = await db.select().from(users);
      for (const u of allUsers) {
        if (u.id === recipientIdentifier || u.email === recipientIdentifier || u.username === recipientIdentifier) {
          recipientUser = u;
          break;
        }
      }
      if (!recipientUser) {
        return res.status(404).json({ message: "Recipient not found" });
      }

      // Cannot invite yourself
      if (recipientUser.id === funderUserId) {
        return res.status(400).json({ message: "You cannot fund yourself" });
      }

      // Check config limits
      const config = await getOrCreateFundingConfig();

      // Check max relationships per funder
      const funderRelCount = await db.select({ count: count() }).from(fundingRelationships)
        .where(and(
          eq(fundingRelationships.funderUserId, funderUserId),
          inArray(fundingRelationships.status, ["pending", "accepted"])
        ));
      if (funderRelCount[0].count >= config.maxRelationshipsPerFunder) {
        return res.status(400).json({ message: `You can have at most ${config.maxRelationshipsPerFunder} active funding relationships` });
      }

      // Check max funders per recipient
      const recipientFunderCount = await db.select({ count: count() }).from(fundingRelationships)
        .where(and(
          eq(fundingRelationships.recipientUserId, recipientUser.id),
          inArray(fundingRelationships.status, ["pending", "accepted"])
        ));
      if (recipientFunderCount[0].count >= config.maxFundersPerRecipient) {
        return res.status(400).json({ message: `Recipient already has the maximum number of funders (${config.maxFundersPerRecipient})` });
      }

      // Check for existing pending/accepted relationship between these two
      const existingRel = await db.select().from(fundingRelationships)
        .where(and(
          eq(fundingRelationships.funderUserId, funderUserId),
          eq(fundingRelationships.recipientUserId, recipientUser.id),
          inArray(fundingRelationships.status, ["pending", "accepted"])
        ));
      if (existingRel.length > 0) {
        return res.status(400).json({ message: "You already have an active or pending relationship with this recipient" });
      }

      // Create funding relationship
      const [relationship] = await db.insert(fundingRelationships).values({
        funderUserId,
        recipientUserId: recipientUser.id,
        relationshipType,
        status: "pending",
        dailyLimit: dailyLimit ? String(dailyLimit) : null,
        monthlyLimit: monthlyLimit ? String(monthlyLimit) : null,
        purposeTag: purposeTag || null,
      }).returning();

      // Notify recipient
      try {
        await notificationService.createNotification(
          recipientUser.id,
          "wallet",
          "Funding Invite Received",
          `Someone wants to support your rides. Review and accept or decline this funding invite.`,
          { relationshipId: relationship.id }
        );
      } catch (_e) {}

      // Audit log
      await db.insert(fundingAuditLogs).values({
        action: "invite_sent",
        actorUserId: funderUserId,
        targetUserId: recipientUser.id,
        relationshipId: relationship.id,
        details: JSON.stringify({ relationshipType, dailyLimit, monthlyLimit, purposeTag }),
      });

      return res.json(relationship);
    } catch (error) {
      console.error("Error creating funding invite:", error);
      return res.status(500).json({ message: "Failed to create funding invite" });
    }
  });

  // GET /api/funding/relationships  Get all relationships for current user
  app.get("/api/funding/relationships", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;

      // As funder
      const asFunderRaw = await db.select().from(fundingRelationships)
        .where(eq(fundingRelationships.funderUserId, userId))
        .orderBy(desc(fundingRelationships.createdAt));

      // As recipient
      const asRecipientRaw = await db.select().from(fundingRelationships)
        .where(eq(fundingRelationships.recipientUserId, userId))
        .orderBy(desc(fundingRelationships.createdAt));

      // Collect user IDs for name lookup
      const userIds = new Set<string>();
      asFunderRaw.forEach(r => userIds.add(r.recipientUserId));
      asRecipientRaw.forEach(r => userIds.add(r.funderUserId));

      const userMap: Record<string, string> = {};
      if (userIds.size > 0) {
        const usersData = await db.select({ id: users.id, username: users.username, firstName: users.firstName, lastName: users.lastName })
          .from(users).where(inArray(users.id, Array.from(userIds)));
        usersData.forEach(u => {
          userMap[u.id] = u.firstName && u.lastName ? `${u.firstName} ${u.lastName}` : u.username || u.id;
        });
      }

      const asFunder = asFunderRaw.map(r => ({ ...r, recipientName: userMap[r.recipientUserId] || "Unknown" }));
      const asRecipient = asRecipientRaw.map(r => ({ ...r, funderName: userMap[r.funderUserId] || "Unknown" }));

      return res.json({ asFunder, asRecipient });
    } catch (error) {
      console.error("Error fetching funding relationships:", error);
      return res.status(500).json({ message: "Failed to fetch relationships" });
    }
  });

  // POST /api/funding/relationships/:id/accept  Recipient accepts a pending invite
  app.post("/api/funding/relationships/:id/accept", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id } = req.params;

      const [rel] = await db.select().from(fundingRelationships).where(eq(fundingRelationships.id, id));
      if (!rel) return res.status(404).json({ message: "Relationship not found" });
      if (rel.recipientUserId !== userId) return res.status(403).json({ message: "Only the recipient can accept this invite" });
      if (rel.status !== "pending") return res.status(400).json({ message: "This invite is no longer pending" });

      const [updated] = await db.update(fundingRelationships)
        .set({ status: "accepted", acceptedAt: new Date(), updatedAt: new Date() })
        .where(eq(fundingRelationships.id, id))
        .returning();

      // Create sponsored balance record
      await db.insert(sponsoredBalances).values({
        recipientUserId: rel.recipientUserId,
        funderUserId: rel.funderUserId,
        relationshipId: rel.id,
      });

      // Notify funder
      try {
        await notificationService.createNotification(
          rel.funderUserId,
          "wallet",
          "Funding Invite Accepted",
          `Your funding invite has been accepted. You can now send funds to support their rides.`,
          { relationshipId: rel.id }
        );
      } catch (_e) {}

      // Audit log
      await db.insert(fundingAuditLogs).values({
        action: "invite_accepted",
        actorUserId: userId,
        targetUserId: rel.funderUserId,
        relationshipId: rel.id,
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error accepting funding invite:", error);
      return res.status(500).json({ message: "Failed to accept invite" });
    }
  });

  // POST /api/funding/relationships/:id/decline  Recipient declines a pending invite
  app.post("/api/funding/relationships/:id/decline", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id } = req.params;

      const [rel] = await db.select().from(fundingRelationships).where(eq(fundingRelationships.id, id));
      if (!rel) return res.status(404).json({ message: "Relationship not found" });
      if (rel.recipientUserId !== userId) return res.status(403).json({ message: "Only the recipient can decline this invite" });
      if (rel.status !== "pending") return res.status(400).json({ message: "This invite is no longer pending" });

      const [updated] = await db.update(fundingRelationships)
        .set({ status: "declined", declinedAt: new Date(), updatedAt: new Date() })
        .where(eq(fundingRelationships.id, id))
        .returning();

      // Notify funder
      try {
        await notificationService.createNotification(
          rel.funderUserId,
          "wallet",
          "Funding Invite Declined",
          `Your funding invite was declined.`,
          { relationshipId: rel.id }
        );
      } catch (_e) {}

      // Audit log
      await db.insert(fundingAuditLogs).values({
        action: "invite_declined",
        actorUserId: userId,
        targetUserId: rel.funderUserId,
        relationshipId: rel.id,
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error declining funding invite:", error);
      return res.status(500).json({ message: "Failed to decline invite" });
    }
  });

  // POST /api/funding/relationships/:id/revoke  Either party can revoke an accepted relationship
  app.post("/api/funding/relationships/:id/revoke", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { id } = req.params;

      const [rel] = await db.select().from(fundingRelationships).where(eq(fundingRelationships.id, id));
      if (!rel) return res.status(404).json({ message: "Relationship not found" });
      if (rel.funderUserId !== userId && rel.recipientUserId !== userId) {
        return res.status(403).json({ message: "You are not part of this relationship" });
      }
      if (rel.status !== "accepted") return res.status(400).json({ message: "Only accepted relationships can be revoked" });

      const [updated] = await db.update(fundingRelationships)
        .set({ status: "revoked", revokedAt: new Date(), revokedBy: userId, updatedAt: new Date() })
        .where(eq(fundingRelationships.id, id))
        .returning();

      // Notify the other party
      const otherParty = rel.funderUserId === userId ? rel.recipientUserId : rel.funderUserId;
      try {
        await notificationService.createNotification(
          otherParty,
          "wallet",
          "Funding Relationship Revoked",
          `A funding relationship has been revoked. No further funds can be sent through this connection.`,
          { relationshipId: rel.id }
        );
      } catch (_e) {}

      // Audit log
      await db.insert(fundingAuditLogs).values({
        action: "relationship_revoked",
        actorUserId: userId,
        targetUserId: otherParty,
        relationshipId: rel.id,
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error revoking funding relationship:", error);
      return res.status(500).json({ message: "Failed to revoke relationship" });
    }
  });

  // PHASE 3  FUNDED TOP-UP (within relationship)

  // POST /api/funding/top-up  Funder sends funds to recipient
  app.post("/api/funding/top-up", isAuthenticated, async (req: any, res) => {
    try {
      const funderUserId = req.user.claims.sub;
      const { relationshipId, amount, purpose } = req.body;

      if (!relationshipId || !amount) {
        return res.status(400).json({ message: "relationshipId and amount are required" });
      }

      const parsedAmount = parseFloat(amount);
      if (isNaN(parsedAmount) || parsedAmount <= 0) {
        return res.status(400).json({ message: "Amount must be a positive number" });
      }

      // Validate relationship
      const [rel] = await db.select().from(fundingRelationships).where(eq(fundingRelationships.id, relationshipId));
      if (!rel) return res.status(404).json({ message: "Relationship not found" });
      if (rel.funderUserId !== funderUserId) return res.status(403).json({ message: "You are not the funder on this relationship" });
      if (rel.status === "frozen") return res.status(400).json({ message: "This relationship is frozen by an administrator" });
      if (rel.status !== "accepted") return res.status(400).json({ message: "Relationship must be accepted to send funds" });

      // Check global config limits
      const config = await getOrCreateFundingConfig();
      if (!config.isEnabled) return res.status(400).json({ message: "Third-party funding is currently disabled" });
      if (parsedAmount < parseFloat(config.minFundingAmount)) {
        return res.status(400).json({ message: `Minimum funding amount is ${config.minFundingAmount}` });
      }
      if (parsedAmount > parseFloat(config.maxSingleFunding)) {
        return res.status(400).json({ message: `Maximum single funding amount is ${config.maxSingleFunding}` });
      }

      // Reset daily/monthly counters if needed
      const now = new Date();
      let currentDayFunded = parseFloat(rel.currentDayFunded);
      let currentMonthFunded = parseFloat(rel.currentMonthFunded);

      if (rel.lastResetDay) {
        const lastDay = new Date(rel.lastResetDay);
        if (lastDay.toDateString() !== now.toDateString()) {
          currentDayFunded = 0;
        }
      } else {
        currentDayFunded = 0;
      }

      if (rel.lastResetMonth) {
        const lastMonth = new Date(rel.lastResetMonth);
        if (lastMonth.getMonth() !== now.getMonth() || lastMonth.getFullYear() !== now.getFullYear()) {
          currentMonthFunded = 0;
        }
      } else {
        currentMonthFunded = 0;
      }

      // Check relationship daily limit
      if (rel.dailyLimit && (currentDayFunded + parsedAmount) > parseFloat(rel.dailyLimit)) {
        return res.status(400).json({ message: `This top-up would exceed the daily limit of ${rel.dailyLimit}` });
      }

      // Check relationship monthly limit
      if (rel.monthlyLimit && (currentMonthFunded + parsedAmount) > parseFloat(rel.monthlyLimit)) {
        return res.status(400).json({ message: `This top-up would exceed the monthly limit of ${rel.monthlyLimit}` });
      }

      // Check global daily limit
      if ((currentDayFunded + parsedAmount) > parseFloat(config.globalDailyLimit)) {
        return res.status(400).json({ message: "Global daily funding limit exceeded" });
      }

      // Check global monthly limit
      if ((currentMonthFunded + parsedAmount) > parseFloat(config.globalMonthlyLimit)) {
        return res.status(400).json({ message: "Global monthly funding limit exceeded" });
      }

      // Create wallet funding transaction
      const [txn] = await db.insert(walletFundingTransactions).values({
        senderUserId: funderUserId,
        recipientUserId: rel.recipientUserId,
        amount: parsedAmount.toFixed(2),
        status: "completed",
        note: purpose || "Third-party wallet funding",
        processedAt: now,
      }).returning();

      // Update sponsored balance
      await db.update(sponsoredBalances)
        .set({
          balance: sql`CAST(${sponsoredBalances.balance} AS numeric) + ${parsedAmount}`,
          totalReceived: sql`CAST(${sponsoredBalances.totalReceived} AS numeric) + ${parsedAmount}`,
          lastTopUpAt: now,
          updatedAt: now,
        })
        .where(and(
          eq(sponsoredBalances.relationshipId, rel.id),
          eq(sponsoredBalances.recipientUserId, rel.recipientUserId)
        ));

      // Update relationship counters
      await db.update(fundingRelationships)
        .set({
          totalFunded: sql`CAST(${fundingRelationships.totalFunded} AS numeric) + ${parsedAmount}`,
          currentDayFunded: sql`${currentDayFunded + parsedAmount}`,
          currentMonthFunded: sql`${currentMonthFunded + parsedAmount}`,
          lastFundedAt: now,
          lastResetDay: now,
          lastResetMonth: now,
          updatedAt: now,
        })
        .where(eq(fundingRelationships.id, rel.id));

      // Credit the rider's actual riderWallets balance (sponsored balance tracks the source)
      const existingWallet = await db.select().from(riderWallets).where(eq(riderWallets.userId, rel.recipientUserId));
      if (existingWallet.length > 0) {
        await db.update(riderWallets)
          .set({
            balance: sql`CAST(${riderWallets.balance} AS numeric) + ${parsedAmount}`,
            updatedAt: now,
          })
          .where(eq(riderWallets.userId, rel.recipientUserId));
      } else {
        await db.insert(riderWallets).values({
          userId: rel.recipientUserId,
          balance: parsedAmount.toFixed(2),
        });
      }

      // Fraud checks: flag if funder has >5 recipients
      const funderRecipientCount = await db.select({ count: count() }).from(fundingRelationships)
        .where(and(
          eq(fundingRelationships.funderUserId, funderUserId),
          inArray(fundingRelationships.status, ["accepted"])
        ));
      if (funderRecipientCount[0].count > 5) {
        await db.insert(fundingAbuseFlags).values({
          relationshipId: rel.id,
          funderUserId,
          recipientUserId: rel.recipientUserId,
          flagType: "many_recipients_one_funder",
          severity: "medium",
          details: `Funder has ${funderRecipientCount[0].count} active recipients`,
        });
      }

      // Fraud check: velocity  >3 top-ups in 1 hour
      const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
      const recentTopUps = await db.select({ count: count() }).from(walletFundingTransactions)
        .where(and(
          eq(walletFundingTransactions.senderUserId, funderUserId),
          gte(walletFundingTransactions.processedAt, oneHourAgo)
        ));
      if (recentTopUps[0].count > 3) {
        await db.insert(fundingAbuseFlags).values({
          relationshipId: rel.id,
          funderUserId,
          recipientUserId: rel.recipientUserId,
          flagType: "velocity_alert",
          severity: "high",
          details: `${recentTopUps[0].count} top-ups in the last hour`,
        });
      }

      // Notify recipient
      try {
        await notificationService.createNotification(
          rel.recipientUserId,
          "wallet",
          "Funds Received",
          `You received ${parsedAmount.toFixed(2)} in ride support funds. These funds can be used for rides.`,
          { transactionId: txn.id, amount: parsedAmount }
        );
      } catch (_e) {}

      // Audit log
      await db.insert(fundingAuditLogs).values({
        action: "top_up_completed",
        actorUserId: funderUserId,
        targetUserId: rel.recipientUserId,
        relationshipId: rel.id,
        transactionId: txn.id,
        details: JSON.stringify({ amount: parsedAmount, purpose }),
      });

      return res.json(txn);
    } catch (error) {
      console.error("Error processing funding top-up:", error);
      return res.status(500).json({ message: "Failed to process top-up" });
    }
  });

  // PHASE 4  FUNDER DASHBOARD

  // GET /api/funding/dashboard  Get funder dashboard summary
  app.get("/api/funding/dashboard", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;

      const relationships = await db.select().from(fundingRelationships)
        .where(and(
          eq(fundingRelationships.funderUserId, userId),
          eq(fundingRelationships.status, "accepted")
        ));

      if (relationships.length === 0) {
        return res.json([]);
      }

      // Get recipient names
      const recipientIds = relationships.map(r => r.recipientUserId);
      const recipientUsers = await db.select({ id: users.id, username: users.username, firstName: users.firstName, lastName: users.lastName })
        .from(users).where(inArray(users.id, recipientIds));
      const nameMap: Record<string, string> = {};
      recipientUsers.forEach(u => {
        nameMap[u.id] = u.firstName && u.lastName ? `${u.firstName} ${u.lastName}` : u.username || u.id;
      });

      // Get ride usage for each recipient (count of completed rides and total cost  no routes/drivers/locations)
      const dashboard = await Promise.all(relationships.map(async (rel) => {
        const rideStats = await db.select({
          rideCount: count(),
          totalCost: sql<string>`COALESCE(SUM(CAST(${rides.finalFare} AS numeric)), 0)`,
        }).from(rides)
          .where(and(
            eq(rides.riderId, rel.recipientUserId),
            eq(rides.status, "completed")
          ));

        return {
          relationshipId: rel.id,
          recipientName: nameMap[rel.recipientUserId] || "Unknown",
          recipientUserId: rel.recipientUserId,
          relationshipType: rel.relationshipType,
          totalFunded: rel.totalFunded,
          currentMonthFunded: rel.currentMonthFunded,
          lastFundedAt: rel.lastFundedAt,
          dailyLimit: rel.dailyLimit,
          monthlyLimit: rel.monthlyLimit,
          rideCount: rideStats[0]?.rideCount || 0,
          totalRideCost: rideStats[0]?.totalCost || "0.00",
        };
      }));

      return res.json(dashboard);
    } catch (error) {
      console.error("Error fetching funding dashboard:", error);
      return res.status(500).json({ message: "Failed to fetch dashboard" });
    }
  });

  // PHASE 5  RIDER SPONSORED FUNDS VIEW

  // GET /api/funding/sponsored-balance  Get sponsored balances for current user
  app.get("/api/funding/sponsored-balance", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;

      const balances = await db.select().from(sponsoredBalances)
        .where(eq(sponsoredBalances.recipientUserId, userId));

      if (balances.length === 0) {
        return res.json([]);
      }

      // Get relationship details and funder names
      const relIds = balances.map(b => b.relationshipId);
      const funderIds = balances.map(b => b.funderUserId);

      const rels = await db.select().from(fundingRelationships)
        .where(inArray(fundingRelationships.id, relIds));
      const relMap: Record<string, any> = {};
      rels.forEach(r => { relMap[r.id] = r; });

      const funderUsers = await db.select({ id: users.id, username: users.username, firstName: users.firstName, lastName: users.lastName })
        .from(users).where(inArray(users.id, funderIds));
      const funderNameMap: Record<string, string> = {};
      funderUsers.forEach(u => {
        funderNameMap[u.id] = u.firstName && u.lastName ? `${u.firstName} ${u.lastName}` : u.username || u.id;
      });

      const result = balances.map(b => ({
        id: b.id,
        funderName: funderNameMap[b.funderUserId] || "Unknown",
        relationshipType: relMap[b.relationshipId]?.relationshipType || "unknown",
        balance: b.balance,
        totalReceived: b.totalReceived,
        totalUsed: b.totalUsed,
        lastTopUpAt: b.lastTopUpAt,
      }));

      return res.json(result);
    } catch (error) {
      console.error("Error fetching sponsored balances:", error);
      return res.status(500).json({ message: "Failed to fetch sponsored balances" });
    }
  });

  // PHASE 6 & 7  ADMIN CONTROLS

  // GET /api/admin/funding/config  Get third-party funding config
  app.get("/api/admin/funding/config", isAuthenticated, requireRole(["admin", "super_admin"]), async (_req: any, res) => {
    try {
      const config = await getOrCreateFundingConfig();
      return res.json(config);
    } catch (error) {
      console.error("Error fetching funding config:", error);
      return res.status(500).json({ message: "Failed to fetch config" });
    }
  });

  // PUT /api/admin/funding/config  Update third-party funding config (Super Admin only)
  app.put("/api/admin/funding/config", isAuthenticated, requireSuperAdmin, async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const config = await getOrCreateFundingConfig();

      const {
        isEnabled, globalDailyLimit, globalMonthlyLimit,
        maxRelationshipsPerFunder, maxFundersPerRecipient,
        minFundingAmount, maxSingleFunding, sponsoredFundsPriority,
        allowedUsages, cashWithdrawalAllowed
      } = req.body;

      const updateData: any = { updatedBy: adminUserId, updatedAt: new Date() };
      if (isEnabled !== undefined) updateData.isEnabled = isEnabled;
      if (globalDailyLimit !== undefined) updateData.globalDailyLimit = String(globalDailyLimit);
      if (globalMonthlyLimit !== undefined) updateData.globalMonthlyLimit = String(globalMonthlyLimit);
      if (maxRelationshipsPerFunder !== undefined) updateData.maxRelationshipsPerFunder = maxRelationshipsPerFunder;
      if (maxFundersPerRecipient !== undefined) updateData.maxFundersPerRecipient = maxFundersPerRecipient;
      if (minFundingAmount !== undefined) updateData.minFundingAmount = String(minFundingAmount);
      if (maxSingleFunding !== undefined) updateData.maxSingleFunding = String(maxSingleFunding);
      if (sponsoredFundsPriority !== undefined) updateData.sponsoredFundsPriority = sponsoredFundsPriority;
      if (allowedUsages !== undefined) updateData.allowedUsages = allowedUsages;
      if (cashWithdrawalAllowed !== undefined) updateData.cashWithdrawalAllowed = false; // Funds CANNOT be withdrawn as cash

      const [updated] = await db.update(thirdPartyFundingConfig)
        .set(updateData)
        .where(eq(thirdPartyFundingConfig.id, config.id))
        .returning();

      // Audit log
      await db.insert(fundingAuditLogs).values({
        action: "config_updated",
        actorUserId: adminUserId,
        details: JSON.stringify(updateData),
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error updating funding config:", error);
      return res.status(500).json({ message: "Failed to update config" });
    }
  });

  // GET /api/admin/funding/relationships  Get all relationships with pagination
  app.get("/api/admin/funding/relationships", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { status, limit: limitStr, offset: offsetStr } = req.query;
      const limit = parseInt(limitStr as string) || 50;
      const offset = parseInt(offsetStr as string) || 0;

      let query = db.select().from(fundingRelationships).orderBy(desc(fundingRelationships.createdAt)).limit(limit).offset(offset);

      let results;
      if (status) {
        results = await db.select().from(fundingRelationships)
          .where(eq(fundingRelationships.status, status as string))
          .orderBy(desc(fundingRelationships.createdAt))
          .limit(limit).offset(offset);
      } else {
        results = await db.select().from(fundingRelationships)
          .orderBy(desc(fundingRelationships.createdAt))
          .limit(limit).offset(offset);
      }

      // Get user names
      const allUserIds = new Set<string>();
      results.forEach(r => { allUserIds.add(r.funderUserId); allUserIds.add(r.recipientUserId); });

      const nameMap: Record<string, string> = {};
      if (allUserIds.size > 0) {
        const usersData = await db.select({ id: users.id, username: users.username, firstName: users.firstName, lastName: users.lastName })
          .from(users).where(inArray(users.id, Array.from(allUserIds)));
        usersData.forEach(u => {
          nameMap[u.id] = u.firstName && u.lastName ? `${u.firstName} ${u.lastName}` : u.username || u.id;
        });
      }

      const enriched = results.map(r => ({
        ...r,
        funderName: nameMap[r.funderUserId] || "Unknown",
        recipientName: nameMap[r.recipientUserId] || "Unknown",
      }));

      return res.json({ relationships: enriched, total: results.length });
    } catch (error) {
      console.error("Error fetching admin funding relationships:", error);
      return res.status(500).json({ message: "Failed to fetch relationships" });
    }
  });

  // POST /api/admin/funding/relationships/:id/freeze  Freeze a suspicious relationship
  app.post("/api/admin/funding/relationships/:id/freeze", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { id } = req.params;
      const { reason } = req.body;

      if (!reason) return res.status(400).json({ message: "Reason is required" });

      const [rel] = await db.select().from(fundingRelationships).where(eq(fundingRelationships.id, id));
      if (!rel) return res.status(404).json({ message: "Relationship not found" });

      const [updated] = await db.update(fundingRelationships)
        .set({
          status: "frozen",
          frozenAt: new Date(),
          frozenBy: adminUserId,
          frozenReason: reason,
          updatedAt: new Date(),
        })
        .where(eq(fundingRelationships.id, id))
        .returning();

      // Notify both parties
      try {
        await notificationService.createNotification(
          rel.funderUserId, "wallet", "Funding Relationship Frozen",
          `A funding relationship has been frozen by an administrator. Reason: ${reason}`,
          { relationshipId: rel.id }
        );
        await notificationService.createNotification(
          rel.recipientUserId, "wallet", "Funding Relationship Frozen",
          `A funding relationship has been frozen by an administrator. Reason: ${reason}`,
          { relationshipId: rel.id }
        );
      } catch (_e) {}

      // Audit log
      await db.insert(fundingAuditLogs).values({
        action: "relationship_frozen",
        actorUserId: adminUserId,
        targetUserId: rel.funderUserId,
        relationshipId: rel.id,
        details: JSON.stringify({ reason }),
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error freezing funding relationship:", error);
      return res.status(500).json({ message: "Failed to freeze relationship" });
    }
  });

  // POST /api/admin/funding/relationships/:id/unfreeze  Unfreeze a relationship
  app.post("/api/admin/funding/relationships/:id/unfreeze", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { id } = req.params;

      const [rel] = await db.select().from(fundingRelationships).where(eq(fundingRelationships.id, id));
      if (!rel) return res.status(404).json({ message: "Relationship not found" });
      if (rel.status !== "frozen") return res.status(400).json({ message: "Relationship is not frozen" });

      const [updated] = await db.update(fundingRelationships)
        .set({
          status: "accepted",
          frozenAt: null,
          frozenBy: null,
          frozenReason: null,
          updatedAt: new Date(),
        })
        .where(eq(fundingRelationships.id, id))
        .returning();

      // Audit log
      await db.insert(fundingAuditLogs).values({
        action: "relationship_unfrozen",
        actorUserId: adminUserId,
        targetUserId: rel.funderUserId,
        relationshipId: rel.id,
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error unfreezing funding relationship:", error);
      return res.status(500).json({ message: "Failed to unfreeze relationship" });
    }
  });

  // GET /api/admin/funding/abuse-flags  Get abuse flags with optional filter
  app.get("/api/admin/funding/abuse-flags", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { resolved } = req.query;

      let results;
      if (resolved === "false") {
        results = await db.select().from(fundingAbuseFlags)
          .where(eq(fundingAbuseFlags.isResolved, false))
          .orderBy(desc(fundingAbuseFlags.createdAt));
      } else if (resolved === "true") {
        results = await db.select().from(fundingAbuseFlags)
          .where(eq(fundingAbuseFlags.isResolved, true))
          .orderBy(desc(fundingAbuseFlags.createdAt));
      } else {
        results = await db.select().from(fundingAbuseFlags)
          .orderBy(desc(fundingAbuseFlags.createdAt));
      }

      // Get user names
      const allUserIds = new Set<string>();
      results.forEach(f => {
        allUserIds.add(f.funderUserId);
        if (f.recipientUserId) allUserIds.add(f.recipientUserId);
      });

      const nameMap: Record<string, string> = {};
      if (allUserIds.size > 0) {
        const usersData = await db.select({ id: users.id, username: users.username, firstName: users.firstName, lastName: users.lastName })
          .from(users).where(inArray(users.id, Array.from(allUserIds)));
        usersData.forEach(u => {
          nameMap[u.id] = u.firstName && u.lastName ? `${u.firstName} ${u.lastName}` : u.username || u.id;
        });
      }

      const enriched = results.map(f => ({
        ...f,
        funderName: nameMap[f.funderUserId] || "Unknown",
        recipientName: f.recipientUserId ? (nameMap[f.recipientUserId] || "Unknown") : null,
      }));

      return res.json(enriched);
    } catch (error) {
      console.error("Error fetching abuse flags:", error);
      return res.status(500).json({ message: "Failed to fetch abuse flags" });
    }
  });

  // POST /api/admin/funding/abuse-flags/:id/resolve  Resolve an abuse flag
  app.post("/api/admin/funding/abuse-flags/:id/resolve", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { id } = req.params;
      const { resolution } = req.body;

      if (!resolution) return res.status(400).json({ message: "Resolution is required" });

      const [flag] = await db.select().from(fundingAbuseFlags).where(eq(fundingAbuseFlags.id, id));
      if (!flag) return res.status(404).json({ message: "Abuse flag not found" });

      const [updated] = await db.update(fundingAbuseFlags)
        .set({
          isResolved: true,
          resolvedBy: adminUserId,
          resolvedAt: new Date(),
          resolution,
        })
        .where(eq(fundingAbuseFlags.id, id))
        .returning();

      // Audit log
      await db.insert(fundingAuditLogs).values({
        action: "abuse_flag_resolved",
        actorUserId: adminUserId,
        targetUserId: flag.funderUserId,
        relationshipId: flag.relationshipId,
        details: JSON.stringify({ resolution, flagType: flag.flagType }),
      });

      return res.json(updated);
    } catch (error) {
      console.error("Error resolving abuse flag:", error);
      return res.status(500).json({ message: "Failed to resolve abuse flag" });
    }
  });

  // POST /api/admin/funding/disable-user/:userId  Freeze ALL relationships where userId is funder
  app.post("/api/admin/funding/disable-user/:userId", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const adminUserId = req.user.claims.sub;
      const { userId } = req.params;
      const { reason } = req.body;

      if (!reason) return res.status(400).json({ message: "Reason is required" });

      // Get all active relationships where this user is funder
      const activeRels = await db.select().from(fundingRelationships)
        .where(and(
          eq(fundingRelationships.funderUserId, userId),
          inArray(fundingRelationships.status, ["pending", "accepted"])
        ));

      // Freeze all of them
      for (const rel of activeRels) {
        await db.update(fundingRelationships)
          .set({
            status: "frozen",
            frozenAt: new Date(),
            frozenBy: adminUserId,
            frozenReason: reason,
            updatedAt: new Date(),
          })
          .where(eq(fundingRelationships.id, rel.id));
      }

      // Audit log
      await db.insert(fundingAuditLogs).values({
        action: "user_funding_disabled",
        actorUserId: adminUserId,
        targetUserId: userId,
        details: JSON.stringify({ reason, relationshipsAffected: activeRels.length }),
      });

      return res.json({ message: `Froze ${activeRels.length} relationship(s) for user ${userId}`, count: activeRels.length });
    } catch (error) {
      console.error("Error disabling user funding:", error);
      return res.status(500).json({ message: "Failed to disable user funding" });
    }
  });

  // PHASE 10  AUDIT LOGS

  // GET /api/admin/funding/audit-logs  Get funding audit logs
  app.get("/api/admin/funding/audit-logs", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { userId, limit: limitStr } = req.query;
      const limit = parseInt(limitStr as string) || 50;

      let results;
      if (userId) {
        results = await db.select().from(fundingAuditLogs)
          .where(or(
            eq(fundingAuditLogs.actorUserId, userId as string),
            eq(fundingAuditLogs.targetUserId, userId as string)
          ))
          .orderBy(desc(fundingAuditLogs.createdAt))
          .limit(limit);
      } else {
        results = await db.select().from(fundingAuditLogs)
          .orderBy(desc(fundingAuditLogs.createdAt))
          .limit(limit);
      }

      return res.json(results);
    } catch (error) {
      console.error("Error fetching funding audit logs:", error);
      return res.status(500).json({ message: "Failed to fetch audit logs" });
    }
  });

  // ============================================================
  // RIDER TRUST, LOYALTY & WALLET GROWTH
  // ============================================================

  // Helper: Get or create rider trust score record
  async function getOrCreateRiderTrustScore(userId: string) {
    const existing = await db.select().from(riderTrustScores).where(eq(riderTrustScores.userId, userId));
    if (existing.length > 0) return existing[0];
    const [created] = await db.insert(riderTrustScores).values({ userId }).returning();
    return created;
  }

  // Helper: Get or create trust weights config
  async function getOrCreateTrustWeights() {
    const existing = await db.select().from(riderTrustWeights);
    if (existing.length > 0) return existing[0];
    const [created] = await db.insert(riderTrustWeights).values({}).returning();
    return created;
  }

  // Helper: Clamp a value between 0 and 100
  function clampScore(value: number): number {
    return Math.max(0, Math.min(100, Math.round(value)));
  }

  // Helper: Determine tier from score and thresholds
  function determineTier(score: number, weights: any): string {
    if (score >= weights.platinumThreshold) return "platinum";
    if (score >= weights.goldThreshold) return "gold";
    if (score >= weights.standardThreshold) return "standard";
    return "limited";
  }

  // Helper: Get grace period for a specific tier
  function getGracePeriodForTier(tier: string, weights: any): number {
    switch (tier) {
      case "platinum": return weights.gracePeriodPlatinum;
      case "gold": return weights.gracePeriodGold;
      case "standard": return weights.gracePeriodStandard;
      default: return weights.gracePeriodLimited;
    }
  }

  // 1. GET /api/rider/trust-score - Get trust score for current rider
  app.get("/api/rider/trust-score", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const trustScore = await getOrCreateRiderTrustScore(userId);
      const weights = await getOrCreateTrustWeights();
      const gracePeriodMinutes = getGracePeriodForTier(trustScore.tier, weights);

      return res.json({
        userId: trustScore.userId,
        score: trustScore.score,
        tier: trustScore.tier,
        reliabilityScore: trustScore.reliabilityScore,
        paymentBehaviorScore: trustScore.paymentBehaviorScore,
        conductSafetyScore: trustScore.conductSafetyScore,
        accountStabilityScore: trustScore.accountStabilityScore,
        adminFlagsScore: trustScore.adminFlagsScore,
        completedRides: trustScore.completedRides,
        totalRides: trustScore.totalRides,
        gracePeriodMinutes,
        lastCalculatedAt: trustScore.lastCalculatedAt,
      });
    } catch (error) {
      console.error("[RIDER TRUST] Error getting trust score:", error);
      return res.status(500).json({ message: "Failed to get trust score" });
    }
  });

  // 2. POST /api/rider/trust-score/calculate - Recalculate trust score
  app.post("/api/rider/trust-score/calculate", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.body.userId || req.user.claims.sub;
      const trustScore = await getOrCreateRiderTrustScore(userId);
      const weights = await getOrCreateTrustWeights();

      // Calculate reliability score
      let reliabilityScore = 75;
      if (trustScore.totalRides > 0) {
        reliabilityScore = (trustScore.completedRides / trustScore.totalRides) * 100;
        reliabilityScore -= trustScore.cancellations * 2;
      }
      reliabilityScore = clampScore(reliabilityScore);

      // Calculate payment behavior score
      let paymentBehaviorScore = 75;
      const totalPaymentRides = trustScore.walletFundedRides + trustScore.cashRides;
      if (totalPaymentRides > 0) {
        paymentBehaviorScore = (trustScore.walletFundedRides / totalPaymentRides) * 80 + 20;
        paymentBehaviorScore -= trustScore.disputeCount * 5;
      }
      paymentBehaviorScore = clampScore(paymentBehaviorScore);

      // Calculate conduct & safety score
      let conductSafetyScore = 100;
      conductSafetyScore -= trustScore.incidentReports * 10;
      const abuseFlags = await db.select().from(riderTrustLogs)
        .where(and(eq(riderTrustLogs.userId, userId), eq(riderTrustLogs.action, "admin_flag")));
      conductSafetyScore -= abuseFlags.length * 5;
      conductSafetyScore = clampScore(conductSafetyScore);

      // Calculate account stability score
      let accountStabilityScore = 60;
      const [user] = await db.select().from(users).where(eq(users.id, userId));
      if (user) {
        if (user.email) accountStabilityScore += 20;
        if (user.profileImageUrl) accountStabilityScore += 20;
      }
      accountStabilityScore = clampScore(accountStabilityScore);

      // Calculate admin flags score
      let adminFlagsScore = 100;
      const adminFlags = await db.select().from(riderTrustLogs)
        .where(and(eq(riderTrustLogs.userId, userId), eq(riderTrustLogs.action, "admin_flag")));
      adminFlagsScore -= adminFlags.length * 15;
      adminFlagsScore = clampScore(adminFlagsScore);

      // Calculate weighted total
      const weightedTotal = (
        reliabilityScore * weights.reliabilityWeight +
        paymentBehaviorScore * weights.paymentBehaviorWeight +
        conductSafetyScore * weights.conductSafetyWeight +
        accountStabilityScore * weights.accountStabilityWeight +
        adminFlagsScore * weights.adminFlagsWeight
      ) / 100;
      const finalScore = clampScore(weightedTotal);

      // Determine tier
      const newTier = determineTier(finalScore, weights);
      const previousTier = trustScore.tier;

      // Update the trust score record
      const [updated] = await db.update(riderTrustScores)
        .set({
          score: finalScore,
          tier: newTier as any,
          reliabilityScore,
          paymentBehaviorScore,
          conductSafetyScore,
          accountStabilityScore,
          adminFlagsScore,
          lastCalculatedAt: new Date(),
          updatedAt: new Date(),
        })
        .where(eq(riderTrustScores.userId, userId))
        .returning();

      // Log tier change if applicable
      if (newTier !== previousTier) {
        await db.insert(riderTrustLogs).values({
          userId,
          action: "tier_change",
          previousScore: trustScore.score,
          newScore: finalScore,
          previousTier,
          newTier,
          details: `Tier changed from ${previousTier} to ${newTier}`,
          performedBy: "system",
        });
      }

      return res.json({
        userId: updated.userId,
        score: updated.score,
        tier: updated.tier,
        reliabilityScore: updated.reliabilityScore,
        paymentBehaviorScore: updated.paymentBehaviorScore,
        conductSafetyScore: updated.conductSafetyScore,
        accountStabilityScore: updated.accountStabilityScore,
        adminFlagsScore: updated.adminFlagsScore,
        lastCalculatedAt: updated.lastCalculatedAt,
        tierChanged: newTier !== previousTier,
        previousTier: newTier !== previousTier ? previousTier : undefined,
      });
    } catch (error) {
      console.error("[RIDER TRUST] Error calculating trust score:", error);
      return res.status(500).json({ message: "Failed to calculate trust score" });
    }
  });

  // 3. GET /api/admin/rider-trust/all - Get all rider trust scores (Admin)
  app.get("/api/admin/rider-trust/all", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const tier = req.query.tier as string | undefined;
      const limit = Math.min(parseInt(req.query.limit as string) || 50, 200);
      const offset = parseInt(req.query.offset as string) || 0;

      let query = db.select({
        userId: riderTrustScores.userId,
        fullName: users.username,
        score: riderTrustScores.score,
        tier: riderTrustScores.tier,
        reliabilityScore: riderTrustScores.reliabilityScore,
        paymentBehaviorScore: riderTrustScores.paymentBehaviorScore,
        conductSafetyScore: riderTrustScores.conductSafetyScore,
        accountStabilityScore: riderTrustScores.accountStabilityScore,
        adminFlagsScore: riderTrustScores.adminFlagsScore,
        completedRides: riderTrustScores.completedRides,
        totalRides: riderTrustScores.totalRides,
        lastCalculatedAt: riderTrustScores.lastCalculatedAt,
      })
      .from(riderTrustScores)
      .leftJoin(users, eq(riderTrustScores.userId, users.id));

      if (tier) {
        query = query.where(eq(riderTrustScores.tier, tier as any)) as any;
      }

      const results = await (query as any).limit(limit).offset(offset).orderBy(desc(riderTrustScores.score));
      return res.json(results);
    } catch (error) {
      console.error("[RIDER TRUST] Error getting all trust scores:", error);
      return res.status(500).json({ message: "Failed to get rider trust scores" });
    }
  });

  // 4. GET /api/admin/rider-trust/weights - Get trust weights config (Admin)
  app.get("/api/admin/rider-trust/weights", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const weights = await getOrCreateTrustWeights();
      return res.json(weights);
    } catch (error) {
      console.error("[RIDER TRUST] Error getting trust weights:", error);
      return res.status(500).json({ message: "Failed to get trust weights" });
    }
  });

  // 5. PUT /api/admin/rider-trust/weights - Update trust weights (Super Admin only)
  app.put("/api/admin/rider-trust/weights", isAuthenticated, requireSuperAdmin, async (req: any, res) => {
    try {
      const {
        reliabilityWeight, paymentBehaviorWeight, conductSafetyWeight,
        accountStabilityWeight, adminFlagsWeight,
        platinumThreshold, goldThreshold, standardThreshold,
        gracePeriodPlatinum, gracePeriodGold, gracePeriodStandard, gracePeriodLimited,
      } = req.body;

      const weightsSum = (reliabilityWeight || 0) + (paymentBehaviorWeight || 0) +
        (conductSafetyWeight || 0) + (accountStabilityWeight || 0) + (adminFlagsWeight || 0);
      if (weightsSum !== 100) {
        return res.status(400).json({ message: `Weights must sum to 100, got ${weightsSum}` });
      }

      const existing = await getOrCreateTrustWeights();
      const [updated] = await db.update(riderTrustWeights)
        .set({
          reliabilityWeight: reliabilityWeight ?? existing.reliabilityWeight,
          paymentBehaviorWeight: paymentBehaviorWeight ?? existing.paymentBehaviorWeight,
          conductSafetyWeight: conductSafetyWeight ?? existing.conductSafetyWeight,
          accountStabilityWeight: accountStabilityWeight ?? existing.accountStabilityWeight,
          adminFlagsWeight: adminFlagsWeight ?? existing.adminFlagsWeight,
          platinumThreshold: platinumThreshold ?? existing.platinumThreshold,
          goldThreshold: goldThreshold ?? existing.goldThreshold,
          standardThreshold: standardThreshold ?? existing.standardThreshold,
          gracePeriodPlatinum: gracePeriodPlatinum ?? existing.gracePeriodPlatinum,
          gracePeriodGold: gracePeriodGold ?? existing.gracePeriodGold,
          gracePeriodStandard: gracePeriodStandard ?? existing.gracePeriodStandard,
          gracePeriodLimited: gracePeriodLimited ?? existing.gracePeriodLimited,
          updatedBy: req.user.claims.sub,
          updatedAt: new Date(),
        })
        .where(eq(riderTrustWeights.id, existing.id))
        .returning();

      return res.json(updated);
    } catch (error) {
      console.error("[RIDER TRUST] Error updating trust weights:", error);
      return res.status(500).json({ message: "Failed to update trust weights" });
    }
  });

  // 6. POST /api/admin/rider-trust/:userId/flag - Manually flag a rider (Admin)
  app.post("/api/admin/rider-trust/:userId/flag", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const { reason } = req.body;

      if (!reason) {
        return res.status(400).json({ message: "Reason is required" });
      }

      const trustScore = await getOrCreateRiderTrustScore(userId);
      const newAdminFlagsScore = clampScore(trustScore.adminFlagsScore - 15);

      // Update admin flags score
      await db.update(riderTrustScores)
        .set({ adminFlagsScore: newAdminFlagsScore, updatedAt: new Date() })
        .where(eq(riderTrustScores.userId, userId));

      // Log the flag action
      await db.insert(riderTrustLogs).values({
        userId,
        action: "admin_flag",
        previousScore: trustScore.score,
        newScore: null,
        details: reason,
        performedBy: req.user.claims.sub,
      });

      // Recalculate overall score
      const weights = await getOrCreateTrustWeights();
      const updatedTrust = await getOrCreateRiderTrustScore(userId);
      const weightedTotal = (
        updatedTrust.reliabilityScore * weights.reliabilityWeight +
        updatedTrust.paymentBehaviorScore * weights.paymentBehaviorWeight +
        updatedTrust.conductSafetyScore * weights.conductSafetyWeight +
        updatedTrust.accountStabilityScore * weights.accountStabilityWeight +
        newAdminFlagsScore * weights.adminFlagsWeight
      ) / 100;
      const finalScore = clampScore(weightedTotal);
      const newTier = determineTier(finalScore, weights);

      const [updated] = await db.update(riderTrustScores)
        .set({
          score: finalScore,
          tier: newTier as any,
          lastCalculatedAt: new Date(),
          updatedAt: new Date(),
        })
        .where(eq(riderTrustScores.userId, userId))
        .returning();

      // Log tier change if applicable
      if (newTier !== trustScore.tier) {
        await db.insert(riderTrustLogs).values({
          userId,
          action: "tier_change",
          previousScore: trustScore.score,
          newScore: finalScore,
          previousTier: trustScore.tier,
          newTier,
          details: `Tier changed due to admin flag: ${reason}`,
          performedBy: req.user.claims.sub,
        });
      }

      return res.json({
        userId: updated.userId,
        score: updated.score,
        tier: updated.tier,
        adminFlagsScore: updated.adminFlagsScore,
        flagReason: reason,
      });
    } catch (error) {
      console.error("[RIDER TRUST] Error flagging rider:", error);
      return res.status(500).json({ message: "Failed to flag rider" });
    }
  });

  // 7. POST /api/admin/rider-trust/:userId/incentive - Grant loyalty incentive (Admin)
  app.post("/api/admin/rider-trust/:userId/incentive", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { userId } = req.params;
      const { incentiveType, description, amount, expiresAt } = req.body;

      if (!incentiveType || !description) {
        return res.status(400).json({ message: "incentiveType and description are required" });
      }

      const [incentive] = await db.insert(riderLoyaltyIncentives).values({
        userId,
        incentiveType,
        description,
        amount: amount ? String(amount) : null,
        expiresAt: expiresAt ? new Date(expiresAt) : null,
        grantedBy: req.user.claims.sub,
        grantReason: description,
      }).returning();

      // Log the incentive
      await db.insert(riderTrustLogs).values({
        userId,
        action: "incentive_granted",
        details: `${incentiveType}: ${description}${amount ? ` (${amount})` : ""}`,
        performedBy: req.user.claims.sub,
      });

      // Create notification for rider
      try {
        await notificationService.createNotification({
          userId,
          title: "Loyalty Reward",
          message: `You've received a loyalty incentive: ${description}`,
          type: "info",
          role: "rider",
        });
      } catch (e) {
        console.warn("[RIDER TRUST] Failed to send incentive notification:", e);
      }

      return res.json(incentive);
    } catch (error) {
      console.error("[RIDER TRUST] Error granting incentive:", error);
      return res.status(500).json({ message: "Failed to grant incentive" });
    }
  });

  // 8. GET /api/rider/loyalty-incentives - Get active loyalty incentives for rider
  app.get("/api/rider/loyalty-incentives", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const now = new Date();

      const incentives = await db.select().from(riderLoyaltyIncentives)
        .where(and(
          eq(riderLoyaltyIncentives.userId, userId),
          eq(riderLoyaltyIncentives.isActive, true),
          or(
            sql`${riderLoyaltyIncentives.expiresAt} IS NULL`,
            gte(riderLoyaltyIncentives.expiresAt, now)
          )
        ))
        .orderBy(desc(riderLoyaltyIncentives.createdAt));

      return res.json(incentives);
    } catch (error) {
      console.error("[RIDER TRUST] Error getting loyalty incentives:", error);
      return res.status(500).json({ message: "Failed to get loyalty incentives" });
    }
  });

  // 9. GET /api/admin/rider-trust/logs - Get rider trust logs (Admin)
  app.get("/api/admin/rider-trust/logs", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const userId = req.query.userId as string | undefined;
      const limit = Math.min(parseInt(req.query.limit as string) || 50, 200);

      let conditions: any[] = [];
      if (userId) {
        conditions.push(eq(riderTrustLogs.userId, userId));
      }

      const logs = conditions.length > 0
        ? await db.select().from(riderTrustLogs).where(and(...conditions)).orderBy(desc(riderTrustLogs.createdAt)).limit(limit)
        : await db.select().from(riderTrustLogs).orderBy(desc(riderTrustLogs.createdAt)).limit(limit);

      return res.json(logs);
    } catch (error) {
      console.error("[RIDER TRUST] Error getting trust logs:", error);
      return res.status(500).json({ message: "Failed to get trust logs" });
    }
  });

  // 10. GET /api/rider/trust-tier-benefits - Get tier benefits info for rider
  app.get("/api/rider/trust-tier-benefits", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const trustScore = await getOrCreateRiderTrustScore(userId);
      const weights = await getOrCreateTrustWeights();

      return res.json({
        currentTier: trustScore.tier,
        tiers: {
          platinum: {
            gracePeriodMinutes: weights.gracePeriodPlatinum,
            rideMatchPriority: "highest",
            supportPriority: "highest",
            walletPerks: true,
          },
          gold: {
            gracePeriodMinutes: weights.gracePeriodGold,
            rideMatchPriority: "high",
            supportPriority: "high",
            walletPerks: true,
          },
          standard: {
            gracePeriodMinutes: weights.gracePeriodStandard,
            rideMatchPriority: "normal",
            supportPriority: "normal",
            walletPerks: false,
          },
          limited: {
            gracePeriodMinutes: weights.gracePeriodLimited,
            rideMatchPriority: "low",
            supportPriority: "low",
            walletPerks: false,
          },
        },
      });
    } catch (error) {
      console.error("[RIDER TRUST] Error getting tier benefits:", error);
      return res.status(500).json({ message: "Failed to get tier benefits" });
    }
  });

  // ========== WELCOME ANALYTICS (PUBLIC, NO AUTH) ==========

  app.post("/api/welcome/event", async (req, res) => {
    try {
      const { sessionId, eventType, eventTarget, intent } = req.body;
      if (!sessionId || !eventType) {
        return res.status(400).json({ error: "sessionId and eventType required" });
      }
      const allowedEvents = ["card_click", "page_view", "cta_click", "signup_start", "zibra_open"];
      if (!allowedEvents.includes(eventType)) {
        return res.status(400).json({ error: "Invalid event type" });
      }
      await db.insert(welcomeAnalytics).values({
        sessionId: String(sessionId).slice(0, 64),
        eventType: String(eventType).slice(0, 30),
        eventTarget: eventTarget ? String(eventTarget).slice(0, 100) : null,
        intent: intent ? String(intent).slice(0, 50) : null,
      });
      res.json({ ok: true });
    } catch (error) {
      console.error("[WELCOME ANALYTICS] Error recording event:", error);
      res.json({ ok: true });
    }
  });

  app.get("/api/admin/welcome-insights", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const range = req.query.range === "7d" ? 7 : req.query.range === "90d" ? 90 : 30;
      const since = new Date();
      since.setDate(since.getDate() - range);

      const allEvents = await db.select().from(welcomeAnalytics)
        .where(sql`${welcomeAnalytics.createdAt} >= ${since}`)
        .orderBy(sql`${welcomeAnalytics.createdAt} DESC`);

      const cardClicks: Record<string, number> = {};
      const ctaClicks = allEvents.filter(e => e.eventType === "cta_click").length;
      const signupStarts = allEvents.filter(e => e.eventType === "signup_start").length;
      const pageViews = allEvents.filter(e => e.eventType === "page_view").length;
      const zibraOpens = allEvents.filter(e => e.eventType === "zibra_open").length;
      const intents: Record<string, number> = {};

      for (const event of allEvents) {
        if (event.eventType === "card_click" && event.eventTarget) {
          cardClicks[event.eventTarget] = (cardClicks[event.eventTarget] || 0) + 1;
        }
        if (event.intent) {
          intents[event.intent] = (intents[event.intent] || 0) + 1;
        }
      }

      const uniqueSessions = new Set(allEvents.map(e => e.sessionId)).size;
      const sessionsWithSignup = new Set(
        allEvents.filter(e => e.eventType === "signup_start").map(e => e.sessionId)
      ).size;
      const conversionRate = uniqueSessions > 0 ? Math.round((sessionsWithSignup / uniqueSessions) * 100) : 0;

      const topCards = Object.entries(cardClicks)
        .sort(([,a], [,b]) => b - a)
        .map(([card, clicks]) => ({ card, clicks }));

      const topIntents = Object.entries(intents)
        .sort(([,a], [,b]) => b - a)
        .map(([intent, count]) => ({ intent, count }));

      const dailyEvents: Record<string, number> = {};
      for (const event of allEvents) {
        const day = new Date(event.createdAt).toISOString().split("T")[0];
        dailyEvents[day] = (dailyEvents[day] || 0) + 1;
      }

      res.json({
        totalEvents: allEvents.length,
        uniqueVisitors: uniqueSessions,
        pageViews,
        cardClicks: Object.values(cardClicks).reduce((a, b) => a + b, 0),
        ctaClicks,
        signupStarts,
        zibraOpens,
        conversionRate,
        topCards,
        topIntents,
        dailyTrend: Object.entries(dailyEvents)
          .sort(([a], [b]) => a.localeCompare(b))
          .slice(-14)
          .map(([date, count]) => ({ date, count })),
        range: `${range}d`,
      });
    } catch (error) {
      console.error("[WELCOME INSIGHTS] Error:", error);
      res.status(500).json({ error: "Failed to fetch welcome insights" });
    }
  });

  // ========================================
  // DIRECTOR PERFORMANCE SCORING & AUTO-INCENTIVES
  // ========================================

  async function getOrCreatePerformanceWeights() {
    let [weights] = await db.select().from(directorPerformanceWeights).limit(1);
    if (!weights) {
      [weights] = await db.insert(directorPerformanceWeights).values({}).returning();
    }
    return weights;
  }

  function determineTier(score: number, weights: any): "gold" | "silver" | "bronze" | "at_risk" {
    if (score >= weights.goldThreshold) return "gold";
    if (score >= weights.silverThreshold) return "silver";
    if (score >= weights.bronzeThreshold) return "bronze";
    return "at_risk";
  }

  async function calculateDirectorPerformanceScore(directorUserId: string) {
    const weights = await getOrCreatePerformanceWeights();
    const now = new Date();
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    const sixtyDaysAgo = new Date(now.getTime() - 60 * 24 * 60 * 60 * 1000);

    const assignments = await db.select().from(directorDriverAssignments)
      .where(and(eq(directorDriverAssignments.directorUserId, directorUserId), eq(directorDriverAssignments.isActive, true)));
    const driverUserIds = assignments.map(a => a.driverUserId);
    const totalDrivers = driverUserIds.length;

    let driverActivityRaw = 0;
    let driverQualityRaw = 0;
    let driverRetentionRaw = 0;
    let complianceSafetyRaw = 0;
    let adminFeedbackRaw = 50;

    if (totalDrivers > 0) {
      const drivers = await db.select().from(driverProfiles)
        .where(inArray(driverProfiles.userId, driverUserIds));
      const activeDrivers = drivers.filter(d => d.isOnline || d.status === "active");
      const activeRatio = parseFloat((await db.select().from(directorCommissionSettings).limit(1))?.[0]?.activeRatio || "0.77");
      const effectiveActive = Math.min(activeDrivers.length, Math.floor(totalDrivers * activeRatio));
      driverActivityRaw = totalDrivers > 0 ? Math.round((effectiveActive / totalDrivers) * 100) : 0;

      const trustProfiles = await db.select().from(userTrustProfiles)
        .where(inArray(userTrustProfiles.userId, driverUserIds));
      const avgTrust = trustProfiles.length > 0
        ? trustProfiles.reduce((sum, t) => sum + parseFloat(t.trustScore || "50"), 0) / trustProfiles.length
        : 50;
      const suspendedCount = drivers.filter(d => d.status === "suspended").length;
      const suspensionPenalty = Math.min(suspendedCount * 10, 40);
      driverQualityRaw = Math.max(0, Math.min(100, Math.round(avgTrust - suspensionPenalty)));

      const recentAssignments = assignments.filter(a => {
        const assignDate = new Date(a.assignedAt);
        return assignDate <= thirtyDaysAgo;
      });
      const retainedCount = recentAssignments.filter(a => a.isActive).length;
      const eligibleForRetention = assignments.filter(a => new Date(a.assignedAt) <= sixtyDaysAgo).length;
      if (eligibleForRetention > 0) {
        driverRetentionRaw = Math.round((retainedCount / Math.max(eligibleForRetention, 1)) * 100);
      } else {
        driverRetentionRaw = totalDrivers > 0 ? 70 : 0;
      }

      const fraudSignals = await db.select({ cnt: count() }).from(directorFraudSignals)
        .where(and(
          eq(directorFraudSignals.directorUserId, directorUserId),
          eq(directorFraudSignals.status, "open"),
          gte(directorFraudSignals.detectedAt, thirtyDaysAgo)
        ));
      const openFraudCount = Number(fraudSignals[0]?.cnt || 0);
      const fraudPenalty = Math.min(openFraudCount * 15, 60);
      complianceSafetyRaw = Math.max(0, 100 - fraudPenalty);
    }

    const score = Math.round(
      (driverActivityRaw * weights.driverActivityWeight / 100) +
      (driverQualityRaw * weights.driverQualityWeight / 100) +
      (driverRetentionRaw * weights.driverRetentionWeight / 100) +
      (complianceSafetyRaw * weights.complianceSafetyWeight / 100) +
      (adminFeedbackRaw * weights.adminFeedbackWeight / 100)
    );
    const tier = determineTier(score, weights);

    const existing = await db.select().from(directorPerformanceScores)
      .where(eq(directorPerformanceScores.directorUserId, directorUserId))
      .orderBy(desc(directorPerformanceScores.calculatedAt))
      .limit(1);

    const previousScore = existing[0]?.score;
    const previousTier = existing[0]?.tier;

    const [record] = await db.insert(directorPerformanceScores).values({
      directorUserId,
      score,
      tier,
      driverActivityScore: driverActivityRaw,
      driverQualityScore: driverQualityRaw,
      driverRetentionScore: driverRetentionRaw,
      complianceSafetyScore: complianceSafetyRaw,
      adminFeedbackScore: adminFeedbackRaw,
      periodStart: thirtyDaysAgo,
      periodEnd: now,
    }).returning();

    if (previousTier && previousTier !== tier) {
      await db.insert(directorPerformanceLogs).values({
        directorUserId,
        action: "tier_change",
        previousScore,
        newScore: score,
        previousTier,
        newTier: tier,
        details: `Tier changed from ${previousTier} to ${tier}`,
      });
    }

    if (tier === "at_risk") {
      const existingRestrictions = await db.select().from(directorRestrictions)
        .where(and(eq(directorRestrictions.directorUserId, directorUserId), eq(directorRestrictions.isActive, true)));
      if (existingRestrictions.length === 0) {
        await db.insert(directorRestrictions).values([
          { directorUserId, restrictionType: "freeze_new_drivers", description: "New driver activation frozen due to AT-RISK performance tier", triggeredByScore: score, triggeredByTier: "at_risk" },
          { directorUserId, restrictionType: "admin_review_required", description: "Admin review required due to AT-RISK performance tier", triggeredByScore: score, triggeredByTier: "at_risk" },
        ]);
        await db.insert(directorPerformanceLogs).values({
          directorUserId, action: "auto_restriction", newScore: score, newTier: tier,
          details: "Auto-restrictions applied: freeze_new_drivers, admin_review_required",
        });
      }
    } else if (tier === "gold" && previousTier !== "gold") {
      const existingIncentives = await db.select().from(directorIncentives)
        .where(and(eq(directorIncentives.directorUserId, directorUserId), eq(directorIncentives.isActive, true)));
      if (existingIncentives.length === 0) {
        await db.insert(directorIncentives).values({
          directorUserId, incentiveType: "visibility_boost", description: "Visibility boost for achieving GOLD performance tier",
          triggeredByScore: score, triggeredByTier: "gold", expiresAt: new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000),
        });
        await db.insert(directorPerformanceLogs).values({
          directorUserId, action: "auto_incentive", newScore: score, newTier: tier,
          details: "Auto-incentive applied: visibility_boost",
        });
      }
    }

    if (tier !== "at_risk") {
      const activeRestrictions = await db.select().from(directorRestrictions)
        .where(and(
          eq(directorRestrictions.directorUserId, directorUserId),
          eq(directorRestrictions.isActive, true),
          eq(directorRestrictions.triggeredByTier, "at_risk")
        ));
      for (const r of activeRestrictions) {
        await db.update(directorRestrictions).set({ isActive: false, liftedAt: now, liftedBy: "system", liftReason: `Score improved to ${score} (${tier})` })
          .where(eq(directorRestrictions.id, r.id));
      }
    }

    return record;
  }

  app.get("/api/director/performance", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const [latest] = await db.select().from(directorPerformanceScores)
        .where(eq(directorPerformanceScores.directorUserId, userId))
        .orderBy(desc(directorPerformanceScores.calculatedAt))
        .limit(1);

      const history = await db.select().from(directorPerformanceScores)
        .where(eq(directorPerformanceScores.directorUserId, userId))
        .orderBy(desc(directorPerformanceScores.calculatedAt))
        .limit(30);

      const incentives = await db.select().from(directorIncentives)
        .where(and(eq(directorIncentives.directorUserId, userId), eq(directorIncentives.isActive, true)));

      const restrictions = await db.select().from(directorRestrictions)
        .where(and(eq(directorRestrictions.directorUserId, userId), eq(directorRestrictions.isActive, true)));

      const weights = await getOrCreatePerformanceWeights();

      res.json({
        current: latest || null,
        history: history.reverse(),
        incentives,
        restrictions,
        thresholds: { gold: weights.goldThreshold, silver: weights.silverThreshold, bronze: weights.bronzeThreshold },
      });
    } catch (error) {
      console.error("[DIRECTOR PERFORMANCE] Error:", error);
      res.status(500).json({ error: "Failed to load performance data" });
    }
  });

  app.post("/api/director/performance/calculate", isAuthenticated, requireRole(["director"]), async (req: any, res) => {
    try {
      const result = await calculateDirectorPerformanceScore(req.user.id);
      res.json(result);
    } catch (error) {
      console.error("[DIRECTOR PERFORMANCE] Calculate error:", error);
      res.status(500).json({ error: "Failed to calculate performance score" });
    }
  });

  app.get("/api/admin/director-performance/weights", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const weights = await getOrCreatePerformanceWeights();
      res.json(weights);
    } catch (error) {
      res.status(500).json({ error: "Failed to load weights" });
    }
  });

  app.put("/api/admin/director-performance/weights", isAuthenticated, requireRole(["super_admin"]), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const { driverActivityWeight, driverQualityWeight, driverRetentionWeight, complianceSafetyWeight, adminFeedbackWeight, goldThreshold, silverThreshold, bronzeThreshold } = req.body;

      const totalWeight = (driverActivityWeight || 30) + (driverQualityWeight || 25) + (driverRetentionWeight || 20) + (complianceSafetyWeight || 15) + (adminFeedbackWeight || 10);
      if (totalWeight !== 100) return res.status(400).json({ error: "Weights must sum to 100" });

      const weights = await getOrCreatePerformanceWeights();
      const [updated] = await db.update(directorPerformanceWeights).set({
        driverActivityWeight: driverActivityWeight ?? weights.driverActivityWeight,
        driverQualityWeight: driverQualityWeight ?? weights.driverQualityWeight,
        driverRetentionWeight: driverRetentionWeight ?? weights.driverRetentionWeight,
        complianceSafetyWeight: complianceSafetyWeight ?? weights.complianceSafetyWeight,
        adminFeedbackWeight: adminFeedbackWeight ?? weights.adminFeedbackWeight,
        goldThreshold: goldThreshold ?? weights.goldThreshold,
        silverThreshold: silverThreshold ?? weights.silverThreshold,
        bronzeThreshold: bronzeThreshold ?? weights.bronzeThreshold,
        updatedAt: new Date(),
        updatedBy: userId,
      }).where(eq(directorPerformanceWeights.id, weights.id)).returning();

      await db.insert(directorPerformanceLogs).values({
        directorUserId: "system",
        action: "weights_updated",
        details: JSON.stringify({ before: weights, after: updated }),
        performedBy: userId,
      });

      res.json(updated);
    } catch (error) {
      res.status(500).json({ error: "Failed to update weights" });
    }
  });

  app.get("/api/admin/director-performance/:directorUserId", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { directorUserId } = req.params;
      const [latest] = await db.select().from(directorPerformanceScores)
        .where(eq(directorPerformanceScores.directorUserId, directorUserId))
        .orderBy(desc(directorPerformanceScores.calculatedAt))
        .limit(1);

      const history = await db.select().from(directorPerformanceScores)
        .where(eq(directorPerformanceScores.directorUserId, directorUserId))
        .orderBy(desc(directorPerformanceScores.calculatedAt))
        .limit(30);

      const incentives = await db.select().from(directorIncentives)
        .where(eq(directorIncentives.directorUserId, directorUserId));

      const restrictions = await db.select().from(directorRestrictions)
        .where(eq(directorRestrictions.directorUserId, directorUserId));

      const logs = await db.select().from(directorPerformanceLogs)
        .where(eq(directorPerformanceLogs.directorUserId, directorUserId))
        .orderBy(desc(directorPerformanceLogs.createdAt))
        .limit(50);

      res.json({ current: latest || null, history: history.reverse(), incentives, restrictions, logs });
    } catch (error) {
      res.status(500).json({ error: "Failed to load director performance" });
    }
  });

  app.post("/api/admin/director-performance/:directorUserId/calculate", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const result = await calculateDirectorPerformanceScore(req.params.directorUserId);
      res.json(result);
    } catch (error) {
      res.status(500).json({ error: "Failed to calculate performance" });
    }
  });

  app.post("/api/admin/director-performance/:directorUserId/feedback", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { directorUserId } = req.params;
      const { feedbackScore, reason } = req.body;
      if (feedbackScore < 0 || feedbackScore > 100) return res.status(400).json({ error: "Feedback score must be 0-100" });

      await db.insert(directorPerformanceLogs).values({
        directorUserId,
        action: "admin_feedback",
        newScore: feedbackScore,
        details: reason || "Admin feedback score updated",
        performedBy: req.user.id,
      });

      res.json({ success: true, message: "Feedback recorded" });
    } catch (error) {
      res.status(500).json({ error: "Failed to submit feedback" });
    }
  });

  app.post("/api/admin/director-performance/:directorUserId/incentive", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { directorUserId } = req.params;
      const { incentiveType, description, expiresInDays } = req.body;
      const expiresAt = expiresInDays ? new Date(Date.now() + expiresInDays * 24 * 60 * 60 * 1000) : null;

      const [incentive] = await db.insert(directorIncentives).values({
        directorUserId,
        incentiveType,
        description: description || `Manual ${incentiveType} incentive`,
        expiresAt,
        triggeredByTier: null,
      }).returning();

      await db.insert(directorPerformanceLogs).values({
        directorUserId, action: "manual_incentive",
        details: `Incentive granted: ${incentiveType} - ${description || ""}`,
        performedBy: req.user.id,
      });

      res.json(incentive);
    } catch (error) {
      res.status(500).json({ error: "Failed to create incentive" });
    }
  });

  app.post("/api/admin/director-performance/:directorUserId/revoke-incentive/:incentiveId", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { incentiveId } = req.params;
      const { reason } = req.body;

      await db.update(directorIncentives).set({
        isActive: false, revokedAt: new Date(), revokedBy: req.user.id, revokeReason: reason || "Revoked by admin",
      }).where(eq(directorIncentives.id, incentiveId));

      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to revoke incentive" });
    }
  });

  app.post("/api/admin/director-performance/:directorUserId/restriction", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { directorUserId } = req.params;
      const { restrictionType, description } = req.body;

      const [restriction] = await db.insert(directorRestrictions).values({
        directorUserId,
        restrictionType,
        description: description || `Manual ${restrictionType} restriction`,
      }).returning();

      await db.insert(directorPerformanceLogs).values({
        directorUserId, action: "manual_restriction",
        details: `Restriction applied: ${restrictionType} - ${description || ""}`,
        performedBy: req.user.id,
      });

      res.json(restriction);
    } catch (error) {
      res.status(500).json({ error: "Failed to create restriction" });
    }
  });

  app.post("/api/admin/director-performance/:directorUserId/lift-restriction/:restrictionId", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const { restrictionId } = req.params;
      const { reason } = req.body;

      await db.update(directorRestrictions).set({
        isActive: false, liftedAt: new Date(), liftedBy: req.user.id, liftReason: reason || "Lifted by admin",
      }).where(eq(directorRestrictions.id, restrictionId));

      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to lift restriction" });
    }
  });

  app.get("/api/admin/director-performance/all", isAuthenticated, requireRole(["admin", "super_admin"]), async (req: any, res) => {
    try {
      const allDirectors = await db.select().from(directorProfiles);
      const results = [];
      for (const director of allDirectors) {
        const [latest] = await db.select().from(directorPerformanceScores)
          .where(eq(directorPerformanceScores.directorUserId, director.userId))
          .orderBy(desc(directorPerformanceScores.calculatedAt))
          .limit(1);
        const activeIncentives = await db.select({ cnt: count() }).from(directorIncentives)
          .where(and(eq(directorIncentives.directorUserId, director.userId), eq(directorIncentives.isActive, true)));
        const activeRestrictions = await db.select({ cnt: count() }).from(directorRestrictions)
          .where(and(eq(directorRestrictions.directorUserId, director.userId), eq(directorRestrictions.isActive, true)));

        const [trustScoreRecord] = await db.select().from(directorTrustScores)
          .where(eq(directorTrustScores.directorUserId, director.userId))
          .limit(1);

        results.push({
          directorUserId: director.userId,
          fullName: director.fullName,
          directorType: director.directorType,
          status: director.status,
          score: latest?.score ?? null,
          tier: latest?.tier ?? null,
          lastCalculated: latest?.calculatedAt ?? null,
          activeIncentives: Number(activeIncentives[0]?.cnt || 0),
          activeRestrictions: Number(activeRestrictions[0]?.cnt || 0),
          trustScore: trustScoreRecord?.score ?? 100,
          trainingCompleted: director.trainingCompleted ?? false,
          termsAccepted: director.termsAccepted ?? false,
        });
      }
      res.json(results);
    } catch (error) {
      res.status(500).json({ error: "Failed to load director performance overview" });
    }
  });

  return httpServer;
}
